{"title":"**Gestión de tipos de datos**","markdown":{"yaml":{"title":"**Gestión de tipos de datos**","format":{"html":{"page-layout":"full","include-in-header":[{"text":"<link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n"}],"toc":true,"toc-title":"Contenidos","toc-location":"left","toc_float":true,"toc_collapsed":false,"toc_depth":4}},"number_sections":true,"anchor_sections":true},"headingText":"Exploración de datos","containsRefs":false,"markdown":"\n\n![](img/04/types.png){fig-align=\"left\" width=30%}\n\n\nEl primer paso en la exploración de un conjunto de datos es conocer su estructura y tamaño.\n\nEl tamaño está definido por la cantidad de observaciones (filas) y la cantidad de variables (columnas).\n\nLlamamos estructura a la forma en se organizan sus variables, sus tipos de datos y sus categorías/valores.\n\n```{r, echo = F, message=FALSE, warning=FALSE}\nlibrary(tidyverse)\nlibrary(readxl)\n\ndatos <- read_excel(\"datos/datos_demo.xlsx\", \n                    col_types = c(\"numeric\", \"text\", \"numeric\", \"numeric\", \"numeric\", \"logical\", \"date\")) %>% \n  mutate(fecha = as.Date(fecha),\n         id = as.integer(id))\ndatos <- as.data.frame(datos)\n```\n\nVamos a utilizar un dataframe de ejemplo con variedad en sus tipos de datos. Para ver su estructura en R base tenemos la función `str()`\n\n```{r}\nstr(datos)\n```\n\nNos informa que la tabla tiene 74 observaciones y 7 variables con su tipo de dato al lado.\n\nEn R base los tipos de datos son:\n\n-   **int** (integer): números enteros\n-   **num** (numeric): números reales\n-   **chr** (character): caracteres (texto)\n-   **logi** (logical): valores lógicos\n-   **Date**: fechas\n-   **fct** (factor): factores\n\nEn tidyverse, la función que reemplaza a str() es `glimpse()`:\n\n```{r}\nglimpse(datos)\n```\n\nParece idéntica pero tiene una ventaja cuando la tabla de datos tiene muchas variables. La lista de respuesta de str() se trunca y no nos deja visualizar la totalidad de columnas, cosa que si hace glimpse().\n\nPor otra parte vamos a encontrar distintas definiciones para los tipos de datos, del modo tidyverse:\n\n-   num para a ser **dbl** (double): números reales\n-   logi para a ser **lgl** (logical): valores lógicos\n\nY se incluyen un tipo nuevo:\n\n-   **dttm** (date-time): fechas y horas\n\nEsta exploración inicial de la estructura generalmente viene acompañada por el \"diccionario de datos\" (codebook) asociado a la tabla de datos, ya sea que esta tabla provenga de un proyecto de investigación propio (fuente primaria), producto de una fuente secundaria o de un sistema de vigilancia epidemiológica.\n\n## Comprobación y coerción de tipos de datos\n\nLa mayoría de las funciones producen un error cuando el tipo de datos que esperan no coincide con los que pasamos como argumentos. En esta situación seguiremos el siguiente camino:\n\n-   Comprobar el tipo de datos utilizando las funciones `is.*()`, que nos responden con un valor lógico (TRUE si el tipo de dato coincide y FALSE si no lo hace). Si el tipo de dato coincide con el formato esperado por el argumento de la función, entonces podemos aplicarla, de lo contrario necesitaremos continuar:\n\n-   Forzar el tipo de datos deseado coercionando con funciones de la familia `as.*()`, que fuerzan el tipo de datos, siempre y cuando esto devuelva valores correctos. Por ejemplo, no podremos obtener valores correctos si intento coercionar caracteres a tipos numéricos.\n\n```{r}\n# Ejmeplo coercionando la variable sexo de caracter a factor\n\nas.factor(datos$sexo) # llamamos a la variable con el formato <dataframe>$<variable>\n\n# detecta que hay dos niveles o categorías posibles (F y M) \n\nis.factor(as.factor(datos$sexo))\n\n# nos confirma que los datos se coercionaron a factor\n```\n\n-   Transformar el tipo de dato a partir de aplicar funciones específicas incluidas en paquetes que gestionan datos especiales, como por ejemplo las fechas (el paquete *lubridate* del tidyverse, que conoceremos más adelante, se ocupa de esto)\n\nA continuación se muestra una lista con los tipos más importantes que se pueden comprobar o forzar a partir de funciones de R base:\n\n| Tipo      | Comprobación     | Coerción         |\n|-----------|------------------|------------------|\n| character | `is.character()` | `as.character()` |\n| numeric   | `is.numeric()`   | `as.numeric()`   |\n| integer   | `is.integer()`   | `as.integer()`   |\n| double    | `is.double()`    | `as.double()`    |\n| factor    | `is.factor()`    | `as.factor()`    |\n| logical   | `is.logical()`   | `as.logical()`   |\n| NA        | `is.na()`        | `as.na()`        |\n\n## Variables de tiempo\n\n<center>\n\n![[Artwork por \\@allison_horst](https://allisonhorst.com/)](img/04/lubridate.PNG){width=40%}\n\n</center>\n\nLos eventos epidemiológicos se presentan en algun momento del tiempo, por lo que las variables de tiempo son habituales componentes de las bases de datos con las que trabaja un epidemiólogo. Estas variables pueden presentarse en distintas unidades de medida, tales como horas, días, años, decadas, etc.\n\nA veces trabajar con datos tipo fecha y hora puede ser frustrante.Las fechas vienen en muchos formatos diferentes, que hace que reconocerlos y analizarlos sea un desafío.\n\nPrimero necesitamos que los datos sean reconocidos como formato fecha (*Date*) y luego debemos lidiar con operaciones específicas como extraer componentes de los horarios, como años, meses o segundos, o cambiar zonas horarias o hacer cálculos entres fechas.\n\nPara simplificar esta tarea tidyverse trae el paquete **lubridate** que proporciona herramientas para manipular variables fecha-hora.\n\nEspecíficamente, lubridate ayuda a los usuarios a:\n\n-   Identificar y analizar los datos de fecha y hora.\n-   Extrer y modificar componentes de una fecha y hora, como años, meses, días, horas, minutos y segundos.\n-   Realizar cálculos precisos con fecha y hora.\n-   Manejar zonas horarias y horario de verano.\n\n**lubridate** se instala y activa con tidyverse:\n\n```{r, warning=FALSE, echo=FALSE}\nlibrary(tidyverse)\n```\n\n### Lectura de fechas\n\nPodemos leer fechas en R usando la serie de funciones **ymd()** proporcionada por este paquete. Estas funciones analizan el contenido de cadenas de caracteres y las transforman a fechas.\n\nLas letras y, m y d corresponden al año, mes y día de una fecha. Para leer una fecha, seleccionamos el nombre de la función que coincide con el orden de los elementos contenidos en el objeto original. Por ejemplo, en la siguiente fecha el elemento mes viene primero, seguido por el día y luego el año, al estilo estadounidense. Entonces usaríamos la función `mdy()`:\n\n```{r, echo=TRUE}\nmdy(\"01-24-2024\")\n```\n\nEl formato de salida siempre año-mes-día, es decir se organiza del elemento más grande que anida a los otros.\n\nSi en cambio tuviese la forma en que usamos las fechas nosotros, usaríamos `dmy()`.\n\n```{r}\ndmy(\"24-01-2024\")\n```\n\nComo se observa el formato de los *caracteres de entrada* pueden utilizar distintos separadores, como guión medio (-), punto (.), barra inclinada (/), guión bajo (\\_) o incluso espacios.\n\nLa clase de los objetos convertidos es **Date**.\n\n```{r}\nx <- dmy(\"24/01/2024\")\n\nclass(x)\n```\n\n| Orden de los elementos                | Función   |\n|---------------------------------------|-----------|\n| año, mes y día                        | ymd()     |\n| año, día y mes                        | ydm()     |\n| mes, día y año                        | mdy()     |\n| día, mes y año                        | dmy()     |\n| hora y minuto                         | hm()      |\n| hora, minuto y segundo                | hms()     |\n| año, mes, día, hora, minuto y segundo | ymd_hms() |\n\nLas funciones que tienen componente de hora crean objetos POSIXct.\n\nCuando una función `dmy()` se aplica a un vector de fechas, **lubridate** supone que todas las fechas tienen el mismo orden y los mismos separadores.\n\n### Manipulando fechas\n\nCada estructura fecha-hora es una combinación de diferentes elementos, cada uno con su propio valor. Por ejemplo, la mayoría de las fechas incluyen un valor de año, un valor de mes, un valor de día, etc. Juntos estos elementos especifican el momento exacto al que se refiere la fecha y la hora.\n\nPodemos extraer fácilmente cada elemento de una fecha-hora con la función de acceso que tiene su nombre, como se muestra en la siguiente tabla.\n\n| Componente de fecha         | Función  |\n|-----------------------------|----------|\n| Año                         | year()   |\n| Mes                         | month()  |\n| Semana                      | week()   |\n| Día del año                 | yday()   |\n| Día del mes                 | mday()   |\n| Día de la semana            | wday()   |\n| Hora                        | hour()   |\n| Minuto                      | minute() |\n| Segundo                     | second() |\n| Zona horaria (huso horario) | tz()     |\n\nPor ejemplo, si almacenamos la fecha y hora actual del sistema en un objeto:\n\n```{r}\nfecha <- now()\n\nfecha\n```\n\npodemos extraer cada uno de sus elementos.\n\nTengamos en cuenta que la función `now()`, perteneciente al mismo paquete lubridate, devolverá una fecha diferente cada vez que se ejecute.\n\n```{r}\nyear(fecha)\n```\n\n```{r}\nmday(fecha)\n```\n\n```{r}\nhour(fecha)\n\nminute(fecha)\n```\n\nPara los elementos de mes y día de la semana (wday), también podemos especificar si queremos extraer el valor numérico del elemento, una abreviatura del nombre del mes o día de la semana, o el nombre completo.\n\nPor ejemplo:\n\n```{r}\nmonth(fecha)\n```\n\n```{r}\nmonth(fecha, label = TRUE)\n```\n\n```{r}\nmonth(fecha, label = TRUE, abbr = FALSE)\n```\n\n```{r}\nwday(fecha, label = TRUE, abbr = FALSE)\n```\n\nOtra buena noticia es que el paquete se adapta al formato regional del sistema operativo donde se encuentra funcionando, por lo que los nombres de los meses o los días de la semana, en este caso, figuran en español (si nuestro sistema operativo está instalado bajo ese idioma).\n\nPor otra parte, también podemos usar cualquiera de las funciones de acceso para establecer el valor de un elemento. Por ejemplo,\n\n```{r}\nfecha\n\nday(fecha) <- 5\n\nfecha\n```\n\ncambia nuestra fecha al quinto día del mes. También podemos configurar los elementos para más valores complicados, por ejemplo:\n\n```{r}\nfechas <- ymd_hms(\"2017-01-01 01:00:00\", \"2017-01-01 01:30:00\")\n\nminute(fechas) <- mean(minute(fechas))\n\nfechas # promedió los minutos en los dos casos\n```\n\nSi asignamos a un elemento un valor mayor de lo admitido, la diferencia se extenderá en el siguiente elemento superior (respetando la cantidad de días del mes de mayo adecuadamente en este caso.)\n\n```{r}\nfecha\n\nday(fecha) <- 35 \n\nfecha\n```\n\nFinalmente, también podemos cambiar las fechas agregando o restando unidades de tiempo.\n\n```{r}\nfecha\n\nfecha <- fecha + hours(3)\n\nfecha\n```\n\nObservemos que `hours()` (plural) no es la misma función que `hour()` (singular).\n\nPor último, algo muy útil para nuestro trabajo es poder extraer la semana epidemiologica, con la función `epiweek()`, en la que cae una fecha en particular o un conjunto de ellas dentro de una variable.\n\n```{r}\nepiweek(fecha)\n```\n\nJunto con la semana epidemiológica se puede obtener el año epidemiológico con la función `epiyear()`\n\nPor ejemplo, la fecha 01/01/2022 es el primer día de enero de 2022 pero pertenece a la semana epidemiológica 52 de año 2021. Veamos:\n\n```{r}\nfecha <- dmy(\"01-01-2022\")\n\nfecha\n\nepiweek(fecha)\n```\n\nSi uno obtiene el año al que pertenece, nos dice que 2022 pero si lo queremos asociar con su semana epidemiológica, nos quedaría que estamos en la semana 52 del año 2022, cosa que no es cierta.\n\n```{r}\nyear(fecha)\n```\n\nEn estas situaciones que no coinciden el año de la fecha con el año epidemiológico de la semana es que se aplica `epiyear()`.\n\n```{r}\nepiyear(fecha)\n```\n\n\n### Cálculos con fecha-horas\n\nLos cálculos con fechas y horas son más complicados que la aritmética con números, pero puede hacerse con precisión y facilidad mediante este paquete.\n\n¿Qué es lo que complica a la aritmética con datos de tiempo (fechas u horas)?\n\nEl tiempo que medimos en el reloj se calibra periódicamente para ajustar las condiciones astronómicas, por caso los años bisiestos o los horarios de verano que se utilizan en muchos países.\n\nEn diferentes momentos, la duración de meses, semanas, días, horas e incluso minutos puede variar. Por lo tanto, podemos considerar que son unidades relativas de tiempo; su longitud es relativa a cuando ocurren; por el contrario, los segundos siempre tienen una longitud constante (son unidades de tiempo exactas)\n\n**lubridate** permite cálculos con unidades relativas y exactas introduciendo cuatro nuevos elementos relacionados: instantes, intervalos, duraciones y períodos. Estos conceptos son tomados del proyecto **Joda Time** *(Colebourne y O'Neill 2010)*. Conceptos similares para instantes, períodos y duraciones también aparecen en la biblioteca C++ Boost - Date Time (Garland 2011).\n\n**lubridate** proporciona funciones auxiliares, clases de objetos y métodos para usar los cuatro conceptos en el lenguaje R.\n\n#### Instantes\n\nUn instante es un momento específico en el tiempo, como el 1 de enero de 2024. Creamos un instante cada vez que convertimos una fecha a formato Date de R.\n\n```{r}\nstart_2024 <- ymd_hms(\"2024-01-01 12:00:00\")\n```\n\n**lubridate** no crea una nueva clase de objetos instantes. En cambio, reconoce cualquier objeto de fecha y hora como un instante. Podemos probar si un objeto es un instante usando el identificador `is.instant()`. Por ejemplo:\n\n```{r}\nis.instant(start_2024)\n```\n\n#### Intervalos\n\nLos intervalos, duraciones y períodos son todas formas de registrar tiempos. De estos, los intervalos son los más simples. Un intervalo es un lapso de tiempo que ocurre entre dos instantes específicos.\n\nPodemos crear objetos de intervalo restando dos instantes, mediante **%--%** o usando la función `new_interval()`.\n\n```{r}\nstart_2023 <- ymd_hms(\"2023-01-01 12:00:00\")\nstart_2024 <- ymd_hms(\"2024-01-01 12:00:00\")\nintervalo <- start_2023 %--% start_2024\nintervalo\n```\n\nPodemos acceder a las fechas de inicio y finalización de un objeto de intervalo con `int_start()` e `int_end()`.\n\nLos intervalos siempre comienzan en la fecha y hora que ocurre primero y finaliza en la fecha y hora que ocurre último. Por lo tanto, los intervalos siempre tienen una longitud positiva.\n\n```{r}\nint_start(intervalo)\n```\n\n```{r}\nint_end(intervalo)\n```\n\nDesafortunadamente, dado que los intervalos están anclados a sus fechas de inicio y finalización, no son muy útiles para cálculos de fecha y hora.\n\n#### Duraciones\n\nSi eliminamos las fechas de inicio y finalización de un intervalo, tendremos un intervalo de tiempo genérico que podemos agregar a cualquier fecha. Pero, en que unidad es conveniente medir este período de tiempo? Como vimos anteriormente, si lo almacenamos en segundos, tendrá una longitud exacta ya que los segundos siempre tienen la misma longitud.\n\nLlamamos duraciones de estos lapsos de tiempo. Alternativamente, podemos registrar el lapso de tiempo en unidades más grandes, como minutos o años.\n\nDado que la longitud de estas unidades varía con el tiempo, la longitud exacta de el lapso de tiempo dependerá de cuándo comience. Estos períodos de tiempo no exactos se llaman períodos y será discutido en la siguiente sección.\n\nLa duración de una duración es invariable para saltar años, segundos intercalares y horario de verano porque las duraciones se miden en segundos.\n\nPor lo tanto, las duraciones tienen longitudes consistentes y se puede comparar fácilmente con otras duraciones. Las duraciones son el objeto apropiado para usar cuando se comparan atributos basados en tiempo, como velocidades, tasas y tiempos de vida.\n\nEl paquete base de R tiene definido a objetos de tipo duración en la clase **difftime**.\n\n**lubridate** incorpora un segundo tipo: objetos clase **duration**\n\nEstos objetos se pueden usar con otros objetos de fecha y hora sin preocuparse sobre en qué unidades se muestran. Se puede crear un objeto de duración con la función **duration()**:\n\n```{r}\nduration(60)\n```\n\nPara duraciones grandes, resulta inconveniente describir la longitud en segundos. Por ejemplo, no muchas personas reconocerían que 31557600 segundos es la duración de un año estándar. Por esta razón, los objetos de gran duración son seguidos entre paréntesis por una longitud estimada. Un minuto son 60 segundos, una hora 3600 segundos, un día 86400, una semana 604800 y un año 31557600 (365.25 días).\n\nLos objetos de clase **duration** se pueden crear fácilmente con las funciones auxiliares `dyears()`, `dweeks()`, `ddays()`, `dhours()`, `dminutes()` y `dseconds()`. La **d** en el nombre representa duración.\n\nCada objeto se crea tomando como unidad los segundos usando las relaciones estimadas descriptas arriba. El argumento de cada función es el número de unidades estimadas que deseamos incluir en la duración.\n\n```{r}\ndminutes(1)\n```\n\n```{r}\ndseconds(60)\n```\n\n```{r}\ndminutes(2)\n```\n\n```{r}\n1:3 * dhours(1)\n```\n\nLas duraciones se pueden agregar o restar a cualquier objeto instante.\n\n```{r}\nstart_2024\n\nstart_2024 + ddays(10)\n```\n\nLas duraciones también se pueden agregar o restar de intervalos y otras duraciones. Por ejemplo:\n\n```{r}\ndweeks(1) + ddays(6) + dhours(2) + dminutes(1.5) + dseconds(3)\n```\n\nTambién podemos crear duraciones a partir de objetos intervalo y períodos usando `as.duration()`.\n\n```{r}\nas.duration(intervalo)\n```\n\n#### Períodos\n\nLos períodos registran un intervalo de tiempo en unidades mayores que segundos, como años, meses, semanas, días, horas y minutos. Para mayor comodidad, también podemos crear un período que solo use segundos, pero dicho período tendría las mismas propiedades que una duración. **lubridate** introduce la clase **period** para modelar períodos. Construimos objetos de período con las funciones auxiliares `years()`, `months()`, `weeks()`, `days()`, `hours()`, `minutes()` y `seconds()`.\n\n```{r}\nmonths(3)\n```\n\n```{r}\nmonths(3) + days(2)\n```\n\nEstas funciones no contienen una **d** en su nombre, porque no crean duraciones; ya no tienen longitudes consistentes (medidas en segundos). Por ejemplo, meses (2) siempre tiene una duración de dos meses, aunque la duración de dos meses cambiará según cuando comienza el período (podrán ser meses de 30, 31 0 28 días).\n\nPor esta razón, no podemos calcular exactamente cuánto tiempo será un período en segundos hasta que sepamos cuándo ocurre. Sin embargo, aún podemos realizar cálculos de fecha y hora con períodos. Cuando agregamos o restamos un período a un instante, el período queda asociado al instante. El instante nos dice cuándo ocurre el período, lo que nos permite calcular su longitud exacta en segundos.\n\nPor ejemplo para un año bisiesto, primero sumamos un año con `years()`:\n\n```{r}\nstart_2024 + years(1)\n```\n\nvs. sumar un año como duración con `dyears()`\n\n```{r}\nstart_2024 + dyears(1)\n```\n\nTambién podemos convertir otros objetos intervalo en períodos con la función `as.period()`.\n\n```{r}\nas.period(intervalo)\n```\n\nLos períodos se pueden agregar a instantes, intervalos y otros períodos, pero no a duraciones.\n\n### División con intervalos de tiempo\n\nA veces necesitamos responder preguntas que implican dividir un intervalo de tiempo por otro. Por ejemplo, ¿Cuántos años tiene una persona nacida el 26 de junio de 1976?\n\nObjetos de clase interval, duration y period pueden dividirse por otros objetos de las mismas clases. Los resultados de estas divisiones varían dependiendo de la naturaleza de los intervalos de tiempo involucrados. La división modular (%/%) también funciona con estas clases.\n\nPara ilustrar esto, hacemos un intervalo entre la fecha de nacimiento y la fecha actual.\n\n```{r}\nnacimiento <- ymd(\"1976-06-26\")\n\nhoy <- now()\n\nintervalo <- interval(nacimiento, hoy)\n\nintervalo\n```\n\nComo las duraciones son una medida exacta de un intervalo de tiempo, podemos dividir este intervalo por una duración para obtener una respuesta exacta.\n\n```{r}\nintervalo / dyears(1)\n```\n\nPodríamos utilizar un período en lugar de duración\n\n```{r}\nintervalo / years()\n```\n\nPero lo más útil es la división modular para redondear y quedarnos solo con los años:\n\n```{r}\nintervalo %/% dyears()\n```\n\nEn resumen, la aritmética con tipos fecha-hora puede involucrar cuatro tipos de objetos: instantes, intervalos, duraciones y períodos.\n\n**lubridate** crea nuevas clases de objetos: *interval*, *duration* y *period*. Reconoce que las clases de fecha y hora más comunes, como **POSIXt** y **Date**, se refieren a instantes. La siguiente tabla describe qué objetos se pueden combinar con otro y qué tipo de objeto resultará.\n\n|          | instante | interval   | duration | period   |\n|----------|----------|------------|----------|----------|\n| instante | NA       | instante   | instante | instante |\n| interval | instante | interval\\* | interval | interval |\n| duration | instante | interval   | duration | period   |\n| period   | instante | interval   | period   | period   |\n\n\\*= clase duration si los intervalos no se alinean.\n\n### Redondeando fechas\n\nAl igual que los números, las fechas se ordenan en forma creciente. Esto permite redondear los tipos de datos fecha-hora.\n\n**lubridate** proporciona tres métodos que ayudan a realizar este redondeo: `round_date()`, `floor_date()`, y `ceiling_date()`.\n\nEl primer argumento de cada función es la fecha-hora a ser redondeada. El segundo argumento es la unidad tomada para redondear.\n\nPor ejemplo, podríamos redondear la siguiente fecha-hora a la unidad día:\n\n```{r}\nnov23 <- ymd_hms(\"2023-11-23 09:38:29\")\n\nnov23\n\nround_date(nov23, \"day\")\n```\n\nPero también podríamos desear redondear al comienzo de mes más próximo, asi:\n\n```{r}\nround_date(nov23, \"month\")\n```\n\nTenga en cuenta que al redondear un dato fecha-hora a una unidad determinada, se establece la fecha al inicio de esa unidad (al definir día, por ejemplo se establece la información de horas, minutos y segundos en 00).\n\nLas otras dos funciones de redondeo lo hacen al comienzo del mes menor (floor) o mayor (ceiling).\n\nPor ejemplo, con `ceiling_date()`, podemos hallar el último día de cada mes, sin importar la fecha que tengamos almacenada. Luego de ubicar el inicio del próximo mes, restamos un día.\n\n```{r}\nceiling_date(nov23, \"month\") - days(1)\n```\n\n```{r}\noct02 <- ymd_hms(\"2023-10-02 00:00:00\")\n\nceiling_date(oct02, \"month\") - days(1)\n```\n\n### Zonas horarias\n\nLas zonas horarias complejizan a los datos fecha-hora, pero algunas veces nos encontramos con bases de datos o situaciones en que debemos lidiar con ellas. Cuando creamos instantes en R, la zona horaria estándar es la universal (UTC).\n\n**lubridate** ofrece dos formas de trabajar con zonas horarias.\n\nPodemos cambiar la zona horaria en la que se muestra un instante utilizando la función `with_tz()`. Esto cambia la forma en que se muestra el instante, pero continúa siendo el mismo. Por ejemplo, el objeto fecha tiene cargada una fecha-hora creada a partir de la función `now()` y al ejecutarse en un equipo con configuración regional de Argentina toma el uso horario de Buenos Aires (aparece -03 al final del día y horario)\n\n```{r}\nfecha\n```\n\nAl llevarlo a la zona horaria universal, le agrega 3 horas más, aunque sigue siendo el mismo instante.\n\n```{r}\nwith_tz(fecha, \"UTC\")\n```\n\n`force_tz()` hace lo contrario de `with_tz()`: cambia el instante real de tiempo guardado en el objeto. Por ejemplo, el siguiente código nos mueve a un nuevo instante que ocurre 3 horas más temprano.\n\n```{r}\nforce_tz(fecha, \"UTC\")\n```\n\nEn este caso, un instante horario 11:32:01 UTC correponde al instante 08:32:01 -3\n\n`with_tz()` y `force_tz()` solo funcionan con zonas horarias reconocidas por el sistema operativo de la computadora que aloja R. Esta lista de zonas horarias variará de una computadora a otra. Para más información ver la página de ayuda de R para `Sys.timezone()`.\n\nEl código de nuestra zona horaria (es conocida como UTC-03:00 - Ciudad de Buenos Aires) para incorporar al argumento es **America/Buenos_Aires**\n\n## Cadena de caracteres\n\n<center>\n\n![[Artwork por \\@allison_horst](https://allisonhorst.com/)](img/04/stringr2.PNG){width=40%}\n\n</center>\n\nEl paquete encargado de trabajar con cadenas de caracteres dentro de tidyverse es **stringr**.\n\nTodas las funciones del paquete comienzan con **str\\_** y trabajan sobre un vector de caracteres como primer argumento.\n\nHay tres grandes familias útiles de funciones en **string**:\n\n**Funciones de manipulación de caracteres**: estas funciones permiten manipular caracteres dentro de cadenas\n\n**Herramientas para tratamiento de espacios en blanco**: para agregar, eliminar y manipular espacios en blanco.\n\n**Funciones de coincidencia de patrones**: trabaja con motores de descripción de patrones, para funciones de busqueda, extracción, reemplazo, etc. Trabajan con expresiones regulares.\n\n**stringr** también se instala y activa junto a tidyverse.\n\n### Manipulación de caracteres\n\nPodemos obtener la longitud de la cadena con `str_lenght()`\n\n```{r}\nstr_length(\"abc\")\n```\n\nEsta función es equivalente a la función de R base *nchar()*.\n\nPara acceder a un carácter individual se utiliza `sub_str()`.\n\nSe necesitan tres argumentos: un vector de caracteres, una posición inicial y una posición final. Cualquiera de las posiciones puede ser un entero positivo, que cuenta a partir de la longitud, o un entero negativo que cuenta desde la derecha. Las posiciones son inclusivas, y si es más larga que la cadena, se truncarán silenciosamente.\n\n```{r}\nx <- c(\"abcdef\", \"ghifjk\")\n```\n\nla tercer letra de cada cadena\n\n```{r}\nstr_sub(x, 3, 3)\n```\n\ndesde la segunda letra hasta la anteúltima\n\n```{r}\nstr_sub(x, 2, -2)\n```\n\nTambién puede utilizar `str_sub()` para modificar cadenas de caracteres\n\n```{r}\nstr_sub(x, 3, 3) <- \"X\"\n\nx\n```\n\nEl paquete **stringr** trae incorporado algunas funciones para manipulación de mayúsculas y minúsculas, similares a `tolower()` y `toupper()`\n\n```{r}\nx <- \"Curso de lenguaje R\"\n```\n\nconvierte a mayúsculas\n\n```{r}\nstr_to_upper(x)\n```\n\nconvierte a minúsculas\n\n```{r}\nstr_to_lower(x)\n```\n\nconvierte a tipo título (la primer letra de cada palabra en mayúsculas)\n\n```{r}\nstr_to_title(x)\n```\n\nTambién existen funciones para ordenar secuencias de caracteres\n\n```{r}\nx <- c(\"y\", \"i\", \"k\")\n\nstr_order(x)\n```\n\ndevuelve el orden alfabético del índice de los elementos\n\n```{r}\nstr_sort(x)\n```\n\ndevuelve los caracteres en orden alfabético\n\n```{r}\nstr_sort(x, decreasing = T)\n```\n\nigual al anterior pero en orden decreciente\n\n### Espacios en blanco\n\nHay tres funciones que añaden, eliminan o modifican espacios en blanco\n\n`str_pad()` agrega espacio en blanco extra a una cadena a una longitud fija puede ser a izquierda, derecha o ambos lados.\n\n```{r}\nx <- c (\"abc\", \"defghi\")\n```\n\n```{r}\nstr_pad(x, 10)\n```\n\nrellena con espacios en blanco hasta alcanzar la cantidad de 10 caracteres por cadena sin definir el argumento side= lo hace a la izquierda\n\n```{r}\nstr_pad(x, 10, side = \"both\")\n```\n\naquí lo hacemos rellenando los espacios en blanco a ambos lados\n\nLo opuesto a rellenar de espacios en blanco es eliminarlos y esta tarea la realiza la función `str_trim()`\n\n```{r}\nx <- c(\"  a   \", \"b   \",  \"   c\")\n\nstr_trim(x)\n```\n\nelimina todos los espacios en blanco a ambos lados de la cadena\n\n```{r}\nstr_trim(x, side=\"left\")\n```\n\ncon el argumento *side=* le podemos indicar de que lado queremos eliminarlos\n\n### Patrones\n\n<center>\n\n![[Artwork por \\@allison_horst](https://allisonhorst.com/)](img/04/stringr.PNG){width=40%}\n\n</center>\n\nLa mayoría de las funciones de **stringr** para trabajo con patrones de caracteres funcionan con [expresiones regulares](https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular) (un lenguaje conciso para describir patrones de texto).\n\nBásicamente una expresión regular es una cadena de texto especial para describir un patrón de búsqueda que se puede utilizar para:\n\n-   localizar cadenas de caracteres (ubicar - filtrar)\n\n-   extraer una porción de los datos (extraer)\n\n-   modificar los datos localizados (reemplazar)\n\nHabitualmente se construyen concatenando la especificación de caracteres secuenciados junto a otros metacaracteres.\n\nSon muy útiles cuando tenemos variables de alfanuméricas regulares, es decir con una estructura que se repite. Por ejemplo, los códigos internacionales de enfermedad, conocidos como CIE (actualmente en la versión CIE10/CIE11)\n\nAlgunos de los metacaracteres para construir expresiones regulares son:\n\n| Símbolos y metacaracteres | Descripción                                                    |\n|-----------------------------|-------------------------------------------|\n| \\^                        | Inicio de la cadena                                            |\n| \\$                        | Final de la cadena                                             |\n| \\[ \\]                     | Cualquier carácter del conjunto entre paréntesis               |\n| \\[\\^\\]                    | Cualquier carácter no incluido en el conjunto                  |\n| ?                         | Cero o una ocurrencia de lo que precede al símbolo             |\n| \\+                        | El caracter que le precede debe aparecer al menos una vez      |\n| \\*                        | El caracter que le precede debe aparecer cero, una o más veces |\n| {x}                       | x ocurrencias del caracter que lo precede                      |\n| {x,z}                     | Entre x y z ocurrencias del caracter que lo precede            |\n| {x,}                      | x o más ocurrencias de lo que lo precede                       |\n\n| Símbolos y metacaracteres | Descripción                                           |\n|---------------------------|-------------------------------------------------------|\n| \\|                        | Une subexpresiones                                    |\n| .                         | Concuerda con cualquier carácter individual           |\n| ( )                       | Agrupa subexpresiones                                 |\n| 0-9 a-z A-Z               | Rangos de números, letras…                            |\n| \\\\                        | Marca el carácter siguiente como un carácter especial |\n| .                         | Representa un punto dentro del patrón                 |\n| s                         | Representa un espacio en blanco dentro del patrón     |\n| n                         | Representa un salto de línea dentro del patrón        |\n| d                         | Representa un dígito numérico dentro del patrón       |\n| w                         | Representa un carácter alfanumérico dentro del patrón |\n\n------------------------------------------------------------------------\n\nVeamos un ejemplo con un grupo de códigos CIE10 relacionados a la hepatitis B.\n\n```{r}\n#| echo: false\n\nhepb <- c(\"B16\",\"B160\", \"B161\", \"B162\", \"B169\", \"B170\", \"B178\", \"B180\", \"B181\", \"B189\")\n\ncodigos <- data.frame(hepb)\n```\n\nTenemos una pequeña tabla de datos con 10 códigos en la variable **hepb**\n\n```{r}\ncodigos\n```\n\nSupongamos que se encuentran insertos en una tabla de datos con otros códigos y necesitamos detectarlos para extraerlos o contarlos.\n\nSi las expresiones regulares no existiesen deberíamos hacer algo así:\n\n```{r}\ncodigos %>% \n  filter(hepb ==\"B16\" | hepb >= \"B160\" & hepb <= \"B162\" | hepb == \"B169\" | \n         hepb == \"B170\" | hepb ==\"B178\" | hepb ==\"B180\" | hepb ==\"B181\" | \n         hepb == \"B189\")\n\n```\n\nEs decir, concatenar una serie de operadores y conectores lógicos OR dentro de un filtro por ejemplo para lograr su extracción.\n\nCon las expresiones regulares tenemos una alternativa de hacer esta tarea dividiendo el trabajo en partes y aplicar la función `str_detect()` de **stringr**.\n\n```{r}\ncodigos %>% \n  filter(str_detect(hepb, \"^B16[0-2|9]?$\"))  #  selecciona el grupo B16x\n\ncodigos %>% \n  filter(str_detect(hepb, \"^B17[08]$\")) # selecciona el grupo B17x\n\ncodigos %>% \n  filter(str_detect(hepb, \"^B18[019]$\")) # selecciona el grupo B18x\n```\n\nY finalmente unirlo con conectores OR:\n\n```{r}\ncodigos %>% \n  filter(str_detect(hepb, \"^B16[0-2|9]?$|^B17[08]$|^B18[019]$\"))\n```\n\nO mejor construir una expresión regular más sintética aprovechando los metadatos adecuados.\n\n```{r}\ncodigos %>% \n  filter(str_detect(hepb, \"^B1[6-9][0-9]?$\"))\n```\n\nAdemás de la función de detección `str_detect()` el paquete aporta `str_extract()` para extraer y `str_replace()` para reemplazar directamente\n\n## Factores\n\n<center>\n\n![[Artwork por \\@allison_horst](https://allisonhorst.com/)](img/04/forcats.PNG){width=40%}\n\n</center>\n\nLos factores son simplemente el formato de datos que R reserva para las variables categóricas y estan compuesto por valores numéricos internos asociados a etiquetas que definen cada una de los niveles (categorías o niveles definidos).\n\nEl paquete **forcats** es parte del ecosistema tidyverse pensado para trabajar con este tipo de dato.\n\nEn función de que las herramientas del paquete son de aplicación práctica vamos a trabajar con un conjunto de datos ficticios creados con la finalidad de mostrar la potencialidad de **forcats**.\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n\ndatos <- read_excel(\"datos/Base_factores.xlsx\",sheet = 1, col_names = T)\n\n```\n\n```{r}\nglimpse(datos)\n```\n\nObservamos que el objeto llamado `datos` tiene 6 variables de tipo caracter y 19 observaciones.\n\nEstas variables de caracter tienen como característica representar variables cualitativas nominales y ordinales que para su mejor tratamiento dentro del R deberían ser convertidas a factores.\n\nComenzamos con la primer variable (*Enfermedad*). La función simple y de R base que conocemos para convertirla en factor es `factor()`.\n\n```{r}\ndatos <- datos |> \n  mutate(Enfermedad = factor(Enfermedad))\n\nlevels(datos$Enfermedad)\n```\n\nLa función del paquete **forcats** para realizar la misma tarea se llama `as_factor()`. No agrega ningun funcionalidad extra por lo que es indistinto utilizar una forma u otra.\n\nAquí la utilizamos para convertir la variable *Sexo*\n\n```{r}\ndatos <- datos |> \n  mutate(Sexo = as_factor(Sexo))\n```\n\nSi queremos visualizar los niveles del factor podemos usar `levels()` (función de R base):\n\n```{r}\nlevels(datos$Sexo)\n```\n\nEncontramos uno de los problemas habituales cuando trabajamos con datos reales cargados por diferentes usuarios o cuando unimos bases de diverso origen. Las categorías se encuentran etiquetadas de manera diferente aunque conceptualmente se refieran a lo mismo (ejemplo: \"Femenino\" - \"Mujer\")\n\nDebemos corregir este inconveniente y para esta tarea el paquete ofrece una función que recodifica los niveles. Se llama `fct_recode()` y la aplicamos así:\n\n```{r}\ndatos <- datos |> \n  mutate(Sexo = fct_recode(Sexo, \n                           Varon = \"Masculino\", \n                           Mujer = \"Femenino\"))\n\nlevels(datos$Sexo)\n\ndatos |> \n  reframe(fct_count(Sexo))\n```\n\nVemos en los argumentos que le indicamos que \"Masculino\" es igual a Varon y \"Femenino\" igual a Mujer. Esto provoca que en todos los casos donde aparezca \"Masculino\" sea reemplazado por Varon y cuando aparezcan \"Femenino\" se cambie por Mujer.\n\nFinalmente verificamos que los niveles sean los dos que necesitamos y además podemos producir un listado de frecuencias de los niveles del factor con `fct_count()` dentro de un `reframe()` que es la opción correcta al `summarise()` cuando el resultado es mayor a una fila a partir de la versión 1.1.0 de **dplyr**.\n\nHasta aquí tenemos las dos primeras variables convertidas y podrían ser utilizadas en un análisis posterior para construir una tabla de contingencia de Sexo vs Enfermedad.\n\n```{r}\n#| message: false\n#| warning: false\n\nlibrary(janitor)\n\ndatos |> \n  tabyl(Sexo, Enfermedad)\n```\n\nObservemos que en esta tabla el orden de los niveles de Enfermedad quizás no sea el más conveniente para tablas 2x2 y sus cálculos asociados (razones o diferencias de razones), donde se necesita que la tabla tenga una forma y orden específico para que los valores e las ecuaciones sean los correctos.\n\nEsta situación causa que muchas veces tengamos que reordenar las categorías de las variables cualitativas y los niveles de los factores son ideales para esto. La función encargada de esta tarea en **forcats** es `fct_relevel()` que no es muy diferente al `relevel()` del R base.\n\n```{r}\ndatos <- datos |> \n  mutate(Enfermedad = fct_relevel(Enfermedad, \"Si\"))\n\ndatos |> \n  tabyl(Sexo, Enfermedad)\n```\n\nAplicado sobre **Enfermedad** observamos, luego en la tabla 2x2, que la categoría **Si** aparece primera como necesitamos.\n\nLo mismo podríamos hacer con la variable **Sexo** si quisieramos que el nivel de referencia fuese Mujer en lugar de Varon.\n\n```{r}\ndatos <- datos |> \n  mutate(Sexo = fct_relevel(Sexo, \"Mujer\"))\n\ndatos |> \n  tabyl(Sexo, Enfermedad)\n```\n\nContinuamos con la siguiente variable y luego de transformarla pedimos sus niveles.\n\n```{r}\ndatos <- datos |> \n  mutate(Civil = factor(Civil))\n\nlevels(datos$Civil)\n```\n\nAparecen 4 niveles para la variable. Para ver la frecuencia de aparición hacemos:\n\n```{r}\ndatos |> \n  reframe(fct_count(Civil))\n```\n\nEn la frecuencia aparecen los 4 niveles más un valor faltante (NA). Estos valores habitualmente se omiten en muchas de las operaciones que realiza el lenguaje.\n\nPero supongamos que deseamos mostrar dentro de una tabla de frecuencia la cantidad de valores perdidos o desconocidos que tenemos de la variable **Estado Civil**. Deberíamos etiquetar ese `NA` para poder visualizarlo.\n\nLa función del paquete encargada de la tarea es `fct_na_value_to_level()`\n\n```{r}\ndatos <- datos |> \n  mutate(Civil = fct_na_value_to_level(Civil, \n                                       level = \"Desconocido\"))\n\ndatos |> \n  reframe(fct_count(Civil))\n\nlevels(datos$Civil)\n```\n\nPensando en poder graficar esta variable construimos un gráfico de barras sencillo.\n\n```{r, out.width=\"60%\", fig.align=\"center\"}\ndatos |> \n  ggplot(aes(x = Civil, fill = Civil)) + \n  geom_bar()\n```\n\nUna mejor presentación sería si las barras se encuentran ordenadas (de mayor a menor) por la frecuencia de cada categoría.\n\nPodríamos ordenar mediante `arrange()` (del paquete dplyr de tidyverse) pero este ordenamiento sirve solo como prosentación, es decir el nuevo orden no se guarda dentro de los niveles del factor.\n\nPara poder hacer usamos `fct_infreq()`:\n\n```{r}\ndatos <- datos |> \n  mutate(Civil = fct_infreq(Civil))\n\nlevels(datos$Civil)\n```\n\nAhora el gráfico nos saldría como queremos:\n\n```{r, out.width=\"60%\", fig.align=\"center\"}\ndatos |> \n  ggplot(aes(x = Civil, fill = Civil)) + \n  geom_bar()\n```\n\nSigamos con otra de las variables. En este caso **Esalud** que tiene el estado de salud autoreportado por las personas. Como representa una variable categórica ordinal tenemos que estar atentos al orden de las categorías que R siempre forzará a que cumpla con el alfabético.\n\nPodemos usar directamente `fct_relevel()` con los niveles completos en el orden correcto.\n\n```{r}\nclass(datos$Esalud)\n\ndatos <- datos |> \n  mutate(Esalud = fct_relevel(Esalud,\n                              \"Muy buena\",\n                              \"Buena\",\n                              \"Regular\",\n                              \"Mala\",\n                              \"Muy mala\"))\n         \nlevels(datos$Esalud)\n```\n\nObservemos que no hizo falta primero convertir en factor y luego aplicar la función de **forcats**. Todas las funciones comenzadas con **fct\\_** aplicadas a un tipo caracter convertiran a factor previamente a la operación que realicen.\n\nEn este caso además los niveles tienen un orden lógico que comienza en \"Muy buena\" salud y termina en \"Muy mala\". Quizás el orden necesario sea inverso y `fct_rev()` hace la tarea.\n\n```{r}\ndatos <- datos |> \n  mutate(Esalud = fct_rev(Esalud))\n\nlevels(datos$Esalud)\n```\n\nFinalmente conseguimos que el factor sea ordenado y que los niveles sigan el esquema de aumentar hacia la derecha.\n\nLa siguiente variable es *Ciudad*. Veamos su contenido:\n\n```{r}\ndatos |> \n  count(Ciudad)\n```\n\nPosee 4 etiquetas con nombres de ciudades. Su frecuencia es:\n\nVemos que mayoritariamente las observaciones pertenecen a Mar del Plata. Muchas veces cuando estamos frente a situaciones como esta, donde hay varias categorías con poca frecuencia, es mejor agruparlas en un \"Otras/os\". Eso mismo vamos a realizar con la función `fct_other()`.\n\n```{r}\ndatos <- datos |> \n  mutate(Ciudad = fct_other(Ciudad, \n                            keep = \"Mar del Plata\", \n                            other_level = \"Otras\"))\n\nlevels(datos$Ciudad)\n\ndatos |> \n  count(Ciudad)\n```\n\nLa última de las variables de la tabla de datos es *Comorbilidades*.\n\n```{r}\ndatos |> \n  count(Comorbilidades)\n```\n\nSus etiquetas son 7 y se trata de enfermedades que podemos vincular a distintos grupos, es decir, que nos va a servir de excusa para probar otra función de **forcats**.\n\nLa función es `fct_collapse()` y permite agrupar niveles a grupos que serían las nuevas etiquetas de nivel.\n\nLo vamos a hacer asignando a una nueva variable (*Comor_agrupadas*) y generando los niveles Respiratoria, Digestiva y Circulatorio, para enfermedades respiratorias, enfermedades del aparato digestivo y enfermedades del aparato circulatorio.\n\n```{r}\ndatos <- datos |> \n  mutate(Comor_agrupadas = fct_collapse(Comorbilidades,\n                                      Respiratoria = c(\"EPOC\",\n                                                       \"TBC\", \n                                                       \"Neumonia\"),\n                                      Digestiva = c(\"Hepatitis\",\n                                                    \"Gastritis\"),\n                                      Circulatorio  = c(\"aterosclerosis\",\n                                                        \"Hipertensión\")))\n\nlevels(datos$Comor_agrupadas)\n\ndatos |> \n  count(Comor_agrupadas)\n```\n\nNos quedan para ver tres funciones más del paquete presentado.\n\nLa primera es `fct_drop()` que elimina los niveles que no se utilizan. Veamosla en acción.\n\nTomamos el caso de una selección de la tabla original **datos** filtrado por las observaciones que pertenecen a Mar del Plata, guardado en otro dataframe al que llamaremos **datos_MdP**\n\n```{r}\ndatos_MdP <- datos  |>  \n  filter(Ciudad == \"Mar del Plata\")\n```\n\nSi vemos sus niveles confirmaremos que heredó los que tenía la variable en el tibble original. Pero una tabla nos mostraría que no hay datos para el nivel \"Otras\".\n\n```{r}\nlevels(datos_MdP$Ciudad)\n\ndatos_MdP |> \n  tabyl(Ciudad)\n```\n\nAquí entra en juego la función `fct_drop()` que aplicada a la variable *Ciudad* de **datos_MdP** produce:\n\n```{r}\ndatos_MdP <- datos_MdP |> \n  mutate(Ciudad = fct_drop(Ciudad))\n\nlevels(datos_MdP$Ciudad)\n\ndatos_MdP |> \n  tabyl(Ciudad)\n```\n\nA la inversa, la función `fct_expand()` incorpora niveles a la lista de niveles de un factor.\n\nVolvemos a trabajar con el dataframe **datos** y vamos a asignar nuevos niveles al factor de la variable *Ciudad*.\n\n```{r}\ndatos <- datos |> \n  mutate(Ciudad = fct_expand(Ciudad, \"La Plata\", \n                             \"Tandil\", \n                             \"CABA\"))\n\nlevels(datos$Ciudad)\n```\n\nEsto significa que tenemos tres categorías posibles más en el factor que están disponibles para nuevas observaciones, aunque en el conjunto de datos no esten siendo utilizadas por ahora.\n\nPor último, la función `fct_c()` concatena factores combinandos niveles. Para ejemplificar su uso vamos a construir dos factores tipo vector que finalmente uniremos.\n\nImaginemos que tenemos que unir dos variables pertenecientes a conjuntos de datos que queremos unificar. En la variable1 hay definidos dos niveles \"Corrientes\" y \"Posadas\" y en la variable2 tres niveles \"Corrientes\", \"Resistencia\" y \"Goya\".\n\n```{r}\nvar1 <- factor(c(\"Corrientes\",\"Corrientes\",\"Posadas\",\"Corrientes\",\n                 \"Posadas\"))\n\nvar2 <- factor(c(\"Resistencia\",\"Goya\",\"Goya\",\"Resistencia\",\"Resistencia\",\n                 \"Corrientes\",\"Goya\"))\n\nvar1\n\nvar2\n```\n\nA continuación concatenamos aplicando `fct_c()`:\n\n```{r}\nvar3 <- fct_c(var1, var2)\n\nvar3\n```\n\nObservamos que no solo une los datos de las variables sino que respeta los niveles definidos de cada uno fusionando las categorías.\n","srcMarkdownNoYaml":"\n\n![](img/04/types.png){fig-align=\"left\" width=30%}\n\n## Exploración de datos\n\nEl primer paso en la exploración de un conjunto de datos es conocer su estructura y tamaño.\n\nEl tamaño está definido por la cantidad de observaciones (filas) y la cantidad de variables (columnas).\n\nLlamamos estructura a la forma en se organizan sus variables, sus tipos de datos y sus categorías/valores.\n\n```{r, echo = F, message=FALSE, warning=FALSE}\nlibrary(tidyverse)\nlibrary(readxl)\n\ndatos <- read_excel(\"datos/datos_demo.xlsx\", \n                    col_types = c(\"numeric\", \"text\", \"numeric\", \"numeric\", \"numeric\", \"logical\", \"date\")) %>% \n  mutate(fecha = as.Date(fecha),\n         id = as.integer(id))\ndatos <- as.data.frame(datos)\n```\n\nVamos a utilizar un dataframe de ejemplo con variedad en sus tipos de datos. Para ver su estructura en R base tenemos la función `str()`\n\n```{r}\nstr(datos)\n```\n\nNos informa que la tabla tiene 74 observaciones y 7 variables con su tipo de dato al lado.\n\nEn R base los tipos de datos son:\n\n-   **int** (integer): números enteros\n-   **num** (numeric): números reales\n-   **chr** (character): caracteres (texto)\n-   **logi** (logical): valores lógicos\n-   **Date**: fechas\n-   **fct** (factor): factores\n\nEn tidyverse, la función que reemplaza a str() es `glimpse()`:\n\n```{r}\nglimpse(datos)\n```\n\nParece idéntica pero tiene una ventaja cuando la tabla de datos tiene muchas variables. La lista de respuesta de str() se trunca y no nos deja visualizar la totalidad de columnas, cosa que si hace glimpse().\n\nPor otra parte vamos a encontrar distintas definiciones para los tipos de datos, del modo tidyverse:\n\n-   num para a ser **dbl** (double): números reales\n-   logi para a ser **lgl** (logical): valores lógicos\n\nY se incluyen un tipo nuevo:\n\n-   **dttm** (date-time): fechas y horas\n\nEsta exploración inicial de la estructura generalmente viene acompañada por el \"diccionario de datos\" (codebook) asociado a la tabla de datos, ya sea que esta tabla provenga de un proyecto de investigación propio (fuente primaria), producto de una fuente secundaria o de un sistema de vigilancia epidemiológica.\n\n## Comprobación y coerción de tipos de datos\n\nLa mayoría de las funciones producen un error cuando el tipo de datos que esperan no coincide con los que pasamos como argumentos. En esta situación seguiremos el siguiente camino:\n\n-   Comprobar el tipo de datos utilizando las funciones `is.*()`, que nos responden con un valor lógico (TRUE si el tipo de dato coincide y FALSE si no lo hace). Si el tipo de dato coincide con el formato esperado por el argumento de la función, entonces podemos aplicarla, de lo contrario necesitaremos continuar:\n\n-   Forzar el tipo de datos deseado coercionando con funciones de la familia `as.*()`, que fuerzan el tipo de datos, siempre y cuando esto devuelva valores correctos. Por ejemplo, no podremos obtener valores correctos si intento coercionar caracteres a tipos numéricos.\n\n```{r}\n# Ejmeplo coercionando la variable sexo de caracter a factor\n\nas.factor(datos$sexo) # llamamos a la variable con el formato <dataframe>$<variable>\n\n# detecta que hay dos niveles o categorías posibles (F y M) \n\nis.factor(as.factor(datos$sexo))\n\n# nos confirma que los datos se coercionaron a factor\n```\n\n-   Transformar el tipo de dato a partir de aplicar funciones específicas incluidas en paquetes que gestionan datos especiales, como por ejemplo las fechas (el paquete *lubridate* del tidyverse, que conoceremos más adelante, se ocupa de esto)\n\nA continuación se muestra una lista con los tipos más importantes que se pueden comprobar o forzar a partir de funciones de R base:\n\n| Tipo      | Comprobación     | Coerción         |\n|-----------|------------------|------------------|\n| character | `is.character()` | `as.character()` |\n| numeric   | `is.numeric()`   | `as.numeric()`   |\n| integer   | `is.integer()`   | `as.integer()`   |\n| double    | `is.double()`    | `as.double()`    |\n| factor    | `is.factor()`    | `as.factor()`    |\n| logical   | `is.logical()`   | `as.logical()`   |\n| NA        | `is.na()`        | `as.na()`        |\n\n## Variables de tiempo\n\n<center>\n\n![[Artwork por \\@allison_horst](https://allisonhorst.com/)](img/04/lubridate.PNG){width=40%}\n\n</center>\n\nLos eventos epidemiológicos se presentan en algun momento del tiempo, por lo que las variables de tiempo son habituales componentes de las bases de datos con las que trabaja un epidemiólogo. Estas variables pueden presentarse en distintas unidades de medida, tales como horas, días, años, decadas, etc.\n\nA veces trabajar con datos tipo fecha y hora puede ser frustrante.Las fechas vienen en muchos formatos diferentes, que hace que reconocerlos y analizarlos sea un desafío.\n\nPrimero necesitamos que los datos sean reconocidos como formato fecha (*Date*) y luego debemos lidiar con operaciones específicas como extraer componentes de los horarios, como años, meses o segundos, o cambiar zonas horarias o hacer cálculos entres fechas.\n\nPara simplificar esta tarea tidyverse trae el paquete **lubridate** que proporciona herramientas para manipular variables fecha-hora.\n\nEspecíficamente, lubridate ayuda a los usuarios a:\n\n-   Identificar y analizar los datos de fecha y hora.\n-   Extrer y modificar componentes de una fecha y hora, como años, meses, días, horas, minutos y segundos.\n-   Realizar cálculos precisos con fecha y hora.\n-   Manejar zonas horarias y horario de verano.\n\n**lubridate** se instala y activa con tidyverse:\n\n```{r, warning=FALSE, echo=FALSE}\nlibrary(tidyverse)\n```\n\n### Lectura de fechas\n\nPodemos leer fechas en R usando la serie de funciones **ymd()** proporcionada por este paquete. Estas funciones analizan el contenido de cadenas de caracteres y las transforman a fechas.\n\nLas letras y, m y d corresponden al año, mes y día de una fecha. Para leer una fecha, seleccionamos el nombre de la función que coincide con el orden de los elementos contenidos en el objeto original. Por ejemplo, en la siguiente fecha el elemento mes viene primero, seguido por el día y luego el año, al estilo estadounidense. Entonces usaríamos la función `mdy()`:\n\n```{r, echo=TRUE}\nmdy(\"01-24-2024\")\n```\n\nEl formato de salida siempre año-mes-día, es decir se organiza del elemento más grande que anida a los otros.\n\nSi en cambio tuviese la forma en que usamos las fechas nosotros, usaríamos `dmy()`.\n\n```{r}\ndmy(\"24-01-2024\")\n```\n\nComo se observa el formato de los *caracteres de entrada* pueden utilizar distintos separadores, como guión medio (-), punto (.), barra inclinada (/), guión bajo (\\_) o incluso espacios.\n\nLa clase de los objetos convertidos es **Date**.\n\n```{r}\nx <- dmy(\"24/01/2024\")\n\nclass(x)\n```\n\n| Orden de los elementos                | Función   |\n|---------------------------------------|-----------|\n| año, mes y día                        | ymd()     |\n| año, día y mes                        | ydm()     |\n| mes, día y año                        | mdy()     |\n| día, mes y año                        | dmy()     |\n| hora y minuto                         | hm()      |\n| hora, minuto y segundo                | hms()     |\n| año, mes, día, hora, minuto y segundo | ymd_hms() |\n\nLas funciones que tienen componente de hora crean objetos POSIXct.\n\nCuando una función `dmy()` se aplica a un vector de fechas, **lubridate** supone que todas las fechas tienen el mismo orden y los mismos separadores.\n\n### Manipulando fechas\n\nCada estructura fecha-hora es una combinación de diferentes elementos, cada uno con su propio valor. Por ejemplo, la mayoría de las fechas incluyen un valor de año, un valor de mes, un valor de día, etc. Juntos estos elementos especifican el momento exacto al que se refiere la fecha y la hora.\n\nPodemos extraer fácilmente cada elemento de una fecha-hora con la función de acceso que tiene su nombre, como se muestra en la siguiente tabla.\n\n| Componente de fecha         | Función  |\n|-----------------------------|----------|\n| Año                         | year()   |\n| Mes                         | month()  |\n| Semana                      | week()   |\n| Día del año                 | yday()   |\n| Día del mes                 | mday()   |\n| Día de la semana            | wday()   |\n| Hora                        | hour()   |\n| Minuto                      | minute() |\n| Segundo                     | second() |\n| Zona horaria (huso horario) | tz()     |\n\nPor ejemplo, si almacenamos la fecha y hora actual del sistema en un objeto:\n\n```{r}\nfecha <- now()\n\nfecha\n```\n\npodemos extraer cada uno de sus elementos.\n\nTengamos en cuenta que la función `now()`, perteneciente al mismo paquete lubridate, devolverá una fecha diferente cada vez que se ejecute.\n\n```{r}\nyear(fecha)\n```\n\n```{r}\nmday(fecha)\n```\n\n```{r}\nhour(fecha)\n\nminute(fecha)\n```\n\nPara los elementos de mes y día de la semana (wday), también podemos especificar si queremos extraer el valor numérico del elemento, una abreviatura del nombre del mes o día de la semana, o el nombre completo.\n\nPor ejemplo:\n\n```{r}\nmonth(fecha)\n```\n\n```{r}\nmonth(fecha, label = TRUE)\n```\n\n```{r}\nmonth(fecha, label = TRUE, abbr = FALSE)\n```\n\n```{r}\nwday(fecha, label = TRUE, abbr = FALSE)\n```\n\nOtra buena noticia es que el paquete se adapta al formato regional del sistema operativo donde se encuentra funcionando, por lo que los nombres de los meses o los días de la semana, en este caso, figuran en español (si nuestro sistema operativo está instalado bajo ese idioma).\n\nPor otra parte, también podemos usar cualquiera de las funciones de acceso para establecer el valor de un elemento. Por ejemplo,\n\n```{r}\nfecha\n\nday(fecha) <- 5\n\nfecha\n```\n\ncambia nuestra fecha al quinto día del mes. También podemos configurar los elementos para más valores complicados, por ejemplo:\n\n```{r}\nfechas <- ymd_hms(\"2017-01-01 01:00:00\", \"2017-01-01 01:30:00\")\n\nminute(fechas) <- mean(minute(fechas))\n\nfechas # promedió los minutos en los dos casos\n```\n\nSi asignamos a un elemento un valor mayor de lo admitido, la diferencia se extenderá en el siguiente elemento superior (respetando la cantidad de días del mes de mayo adecuadamente en este caso.)\n\n```{r}\nfecha\n\nday(fecha) <- 35 \n\nfecha\n```\n\nFinalmente, también podemos cambiar las fechas agregando o restando unidades de tiempo.\n\n```{r}\nfecha\n\nfecha <- fecha + hours(3)\n\nfecha\n```\n\nObservemos que `hours()` (plural) no es la misma función que `hour()` (singular).\n\nPor último, algo muy útil para nuestro trabajo es poder extraer la semana epidemiologica, con la función `epiweek()`, en la que cae una fecha en particular o un conjunto de ellas dentro de una variable.\n\n```{r}\nepiweek(fecha)\n```\n\nJunto con la semana epidemiológica se puede obtener el año epidemiológico con la función `epiyear()`\n\nPor ejemplo, la fecha 01/01/2022 es el primer día de enero de 2022 pero pertenece a la semana epidemiológica 52 de año 2021. Veamos:\n\n```{r}\nfecha <- dmy(\"01-01-2022\")\n\nfecha\n\nepiweek(fecha)\n```\n\nSi uno obtiene el año al que pertenece, nos dice que 2022 pero si lo queremos asociar con su semana epidemiológica, nos quedaría que estamos en la semana 52 del año 2022, cosa que no es cierta.\n\n```{r}\nyear(fecha)\n```\n\nEn estas situaciones que no coinciden el año de la fecha con el año epidemiológico de la semana es que se aplica `epiyear()`.\n\n```{r}\nepiyear(fecha)\n```\n\n\n### Cálculos con fecha-horas\n\nLos cálculos con fechas y horas son más complicados que la aritmética con números, pero puede hacerse con precisión y facilidad mediante este paquete.\n\n¿Qué es lo que complica a la aritmética con datos de tiempo (fechas u horas)?\n\nEl tiempo que medimos en el reloj se calibra periódicamente para ajustar las condiciones astronómicas, por caso los años bisiestos o los horarios de verano que se utilizan en muchos países.\n\nEn diferentes momentos, la duración de meses, semanas, días, horas e incluso minutos puede variar. Por lo tanto, podemos considerar que son unidades relativas de tiempo; su longitud es relativa a cuando ocurren; por el contrario, los segundos siempre tienen una longitud constante (son unidades de tiempo exactas)\n\n**lubridate** permite cálculos con unidades relativas y exactas introduciendo cuatro nuevos elementos relacionados: instantes, intervalos, duraciones y períodos. Estos conceptos son tomados del proyecto **Joda Time** *(Colebourne y O'Neill 2010)*. Conceptos similares para instantes, períodos y duraciones también aparecen en la biblioteca C++ Boost - Date Time (Garland 2011).\n\n**lubridate** proporciona funciones auxiliares, clases de objetos y métodos para usar los cuatro conceptos en el lenguaje R.\n\n#### Instantes\n\nUn instante es un momento específico en el tiempo, como el 1 de enero de 2024. Creamos un instante cada vez que convertimos una fecha a formato Date de R.\n\n```{r}\nstart_2024 <- ymd_hms(\"2024-01-01 12:00:00\")\n```\n\n**lubridate** no crea una nueva clase de objetos instantes. En cambio, reconoce cualquier objeto de fecha y hora como un instante. Podemos probar si un objeto es un instante usando el identificador `is.instant()`. Por ejemplo:\n\n```{r}\nis.instant(start_2024)\n```\n\n#### Intervalos\n\nLos intervalos, duraciones y períodos son todas formas de registrar tiempos. De estos, los intervalos son los más simples. Un intervalo es un lapso de tiempo que ocurre entre dos instantes específicos.\n\nPodemos crear objetos de intervalo restando dos instantes, mediante **%--%** o usando la función `new_interval()`.\n\n```{r}\nstart_2023 <- ymd_hms(\"2023-01-01 12:00:00\")\nstart_2024 <- ymd_hms(\"2024-01-01 12:00:00\")\nintervalo <- start_2023 %--% start_2024\nintervalo\n```\n\nPodemos acceder a las fechas de inicio y finalización de un objeto de intervalo con `int_start()` e `int_end()`.\n\nLos intervalos siempre comienzan en la fecha y hora que ocurre primero y finaliza en la fecha y hora que ocurre último. Por lo tanto, los intervalos siempre tienen una longitud positiva.\n\n```{r}\nint_start(intervalo)\n```\n\n```{r}\nint_end(intervalo)\n```\n\nDesafortunadamente, dado que los intervalos están anclados a sus fechas de inicio y finalización, no son muy útiles para cálculos de fecha y hora.\n\n#### Duraciones\n\nSi eliminamos las fechas de inicio y finalización de un intervalo, tendremos un intervalo de tiempo genérico que podemos agregar a cualquier fecha. Pero, en que unidad es conveniente medir este período de tiempo? Como vimos anteriormente, si lo almacenamos en segundos, tendrá una longitud exacta ya que los segundos siempre tienen la misma longitud.\n\nLlamamos duraciones de estos lapsos de tiempo. Alternativamente, podemos registrar el lapso de tiempo en unidades más grandes, como minutos o años.\n\nDado que la longitud de estas unidades varía con el tiempo, la longitud exacta de el lapso de tiempo dependerá de cuándo comience. Estos períodos de tiempo no exactos se llaman períodos y será discutido en la siguiente sección.\n\nLa duración de una duración es invariable para saltar años, segundos intercalares y horario de verano porque las duraciones se miden en segundos.\n\nPor lo tanto, las duraciones tienen longitudes consistentes y se puede comparar fácilmente con otras duraciones. Las duraciones son el objeto apropiado para usar cuando se comparan atributos basados en tiempo, como velocidades, tasas y tiempos de vida.\n\nEl paquete base de R tiene definido a objetos de tipo duración en la clase **difftime**.\n\n**lubridate** incorpora un segundo tipo: objetos clase **duration**\n\nEstos objetos se pueden usar con otros objetos de fecha y hora sin preocuparse sobre en qué unidades se muestran. Se puede crear un objeto de duración con la función **duration()**:\n\n```{r}\nduration(60)\n```\n\nPara duraciones grandes, resulta inconveniente describir la longitud en segundos. Por ejemplo, no muchas personas reconocerían que 31557600 segundos es la duración de un año estándar. Por esta razón, los objetos de gran duración son seguidos entre paréntesis por una longitud estimada. Un minuto son 60 segundos, una hora 3600 segundos, un día 86400, una semana 604800 y un año 31557600 (365.25 días).\n\nLos objetos de clase **duration** se pueden crear fácilmente con las funciones auxiliares `dyears()`, `dweeks()`, `ddays()`, `dhours()`, `dminutes()` y `dseconds()`. La **d** en el nombre representa duración.\n\nCada objeto se crea tomando como unidad los segundos usando las relaciones estimadas descriptas arriba. El argumento de cada función es el número de unidades estimadas que deseamos incluir en la duración.\n\n```{r}\ndminutes(1)\n```\n\n```{r}\ndseconds(60)\n```\n\n```{r}\ndminutes(2)\n```\n\n```{r}\n1:3 * dhours(1)\n```\n\nLas duraciones se pueden agregar o restar a cualquier objeto instante.\n\n```{r}\nstart_2024\n\nstart_2024 + ddays(10)\n```\n\nLas duraciones también se pueden agregar o restar de intervalos y otras duraciones. Por ejemplo:\n\n```{r}\ndweeks(1) + ddays(6) + dhours(2) + dminutes(1.5) + dseconds(3)\n```\n\nTambién podemos crear duraciones a partir de objetos intervalo y períodos usando `as.duration()`.\n\n```{r}\nas.duration(intervalo)\n```\n\n#### Períodos\n\nLos períodos registran un intervalo de tiempo en unidades mayores que segundos, como años, meses, semanas, días, horas y minutos. Para mayor comodidad, también podemos crear un período que solo use segundos, pero dicho período tendría las mismas propiedades que una duración. **lubridate** introduce la clase **period** para modelar períodos. Construimos objetos de período con las funciones auxiliares `years()`, `months()`, `weeks()`, `days()`, `hours()`, `minutes()` y `seconds()`.\n\n```{r}\nmonths(3)\n```\n\n```{r}\nmonths(3) + days(2)\n```\n\nEstas funciones no contienen una **d** en su nombre, porque no crean duraciones; ya no tienen longitudes consistentes (medidas en segundos). Por ejemplo, meses (2) siempre tiene una duración de dos meses, aunque la duración de dos meses cambiará según cuando comienza el período (podrán ser meses de 30, 31 0 28 días).\n\nPor esta razón, no podemos calcular exactamente cuánto tiempo será un período en segundos hasta que sepamos cuándo ocurre. Sin embargo, aún podemos realizar cálculos de fecha y hora con períodos. Cuando agregamos o restamos un período a un instante, el período queda asociado al instante. El instante nos dice cuándo ocurre el período, lo que nos permite calcular su longitud exacta en segundos.\n\nPor ejemplo para un año bisiesto, primero sumamos un año con `years()`:\n\n```{r}\nstart_2024 + years(1)\n```\n\nvs. sumar un año como duración con `dyears()`\n\n```{r}\nstart_2024 + dyears(1)\n```\n\nTambién podemos convertir otros objetos intervalo en períodos con la función `as.period()`.\n\n```{r}\nas.period(intervalo)\n```\n\nLos períodos se pueden agregar a instantes, intervalos y otros períodos, pero no a duraciones.\n\n### División con intervalos de tiempo\n\nA veces necesitamos responder preguntas que implican dividir un intervalo de tiempo por otro. Por ejemplo, ¿Cuántos años tiene una persona nacida el 26 de junio de 1976?\n\nObjetos de clase interval, duration y period pueden dividirse por otros objetos de las mismas clases. Los resultados de estas divisiones varían dependiendo de la naturaleza de los intervalos de tiempo involucrados. La división modular (%/%) también funciona con estas clases.\n\nPara ilustrar esto, hacemos un intervalo entre la fecha de nacimiento y la fecha actual.\n\n```{r}\nnacimiento <- ymd(\"1976-06-26\")\n\nhoy <- now()\n\nintervalo <- interval(nacimiento, hoy)\n\nintervalo\n```\n\nComo las duraciones son una medida exacta de un intervalo de tiempo, podemos dividir este intervalo por una duración para obtener una respuesta exacta.\n\n```{r}\nintervalo / dyears(1)\n```\n\nPodríamos utilizar un período en lugar de duración\n\n```{r}\nintervalo / years()\n```\n\nPero lo más útil es la división modular para redondear y quedarnos solo con los años:\n\n```{r}\nintervalo %/% dyears()\n```\n\nEn resumen, la aritmética con tipos fecha-hora puede involucrar cuatro tipos de objetos: instantes, intervalos, duraciones y períodos.\n\n**lubridate** crea nuevas clases de objetos: *interval*, *duration* y *period*. Reconoce que las clases de fecha y hora más comunes, como **POSIXt** y **Date**, se refieren a instantes. La siguiente tabla describe qué objetos se pueden combinar con otro y qué tipo de objeto resultará.\n\n|          | instante | interval   | duration | period   |\n|----------|----------|------------|----------|----------|\n| instante | NA       | instante   | instante | instante |\n| interval | instante | interval\\* | interval | interval |\n| duration | instante | interval   | duration | period   |\n| period   | instante | interval   | period   | period   |\n\n\\*= clase duration si los intervalos no se alinean.\n\n### Redondeando fechas\n\nAl igual que los números, las fechas se ordenan en forma creciente. Esto permite redondear los tipos de datos fecha-hora.\n\n**lubridate** proporciona tres métodos que ayudan a realizar este redondeo: `round_date()`, `floor_date()`, y `ceiling_date()`.\n\nEl primer argumento de cada función es la fecha-hora a ser redondeada. El segundo argumento es la unidad tomada para redondear.\n\nPor ejemplo, podríamos redondear la siguiente fecha-hora a la unidad día:\n\n```{r}\nnov23 <- ymd_hms(\"2023-11-23 09:38:29\")\n\nnov23\n\nround_date(nov23, \"day\")\n```\n\nPero también podríamos desear redondear al comienzo de mes más próximo, asi:\n\n```{r}\nround_date(nov23, \"month\")\n```\n\nTenga en cuenta que al redondear un dato fecha-hora a una unidad determinada, se establece la fecha al inicio de esa unidad (al definir día, por ejemplo se establece la información de horas, minutos y segundos en 00).\n\nLas otras dos funciones de redondeo lo hacen al comienzo del mes menor (floor) o mayor (ceiling).\n\nPor ejemplo, con `ceiling_date()`, podemos hallar el último día de cada mes, sin importar la fecha que tengamos almacenada. Luego de ubicar el inicio del próximo mes, restamos un día.\n\n```{r}\nceiling_date(nov23, \"month\") - days(1)\n```\n\n```{r}\noct02 <- ymd_hms(\"2023-10-02 00:00:00\")\n\nceiling_date(oct02, \"month\") - days(1)\n```\n\n### Zonas horarias\n\nLas zonas horarias complejizan a los datos fecha-hora, pero algunas veces nos encontramos con bases de datos o situaciones en que debemos lidiar con ellas. Cuando creamos instantes en R, la zona horaria estándar es la universal (UTC).\n\n**lubridate** ofrece dos formas de trabajar con zonas horarias.\n\nPodemos cambiar la zona horaria en la que se muestra un instante utilizando la función `with_tz()`. Esto cambia la forma en que se muestra el instante, pero continúa siendo el mismo. Por ejemplo, el objeto fecha tiene cargada una fecha-hora creada a partir de la función `now()` y al ejecutarse en un equipo con configuración regional de Argentina toma el uso horario de Buenos Aires (aparece -03 al final del día y horario)\n\n```{r}\nfecha\n```\n\nAl llevarlo a la zona horaria universal, le agrega 3 horas más, aunque sigue siendo el mismo instante.\n\n```{r}\nwith_tz(fecha, \"UTC\")\n```\n\n`force_tz()` hace lo contrario de `with_tz()`: cambia el instante real de tiempo guardado en el objeto. Por ejemplo, el siguiente código nos mueve a un nuevo instante que ocurre 3 horas más temprano.\n\n```{r}\nforce_tz(fecha, \"UTC\")\n```\n\nEn este caso, un instante horario 11:32:01 UTC correponde al instante 08:32:01 -3\n\n`with_tz()` y `force_tz()` solo funcionan con zonas horarias reconocidas por el sistema operativo de la computadora que aloja R. Esta lista de zonas horarias variará de una computadora a otra. Para más información ver la página de ayuda de R para `Sys.timezone()`.\n\nEl código de nuestra zona horaria (es conocida como UTC-03:00 - Ciudad de Buenos Aires) para incorporar al argumento es **America/Buenos_Aires**\n\n## Cadena de caracteres\n\n<center>\n\n![[Artwork por \\@allison_horst](https://allisonhorst.com/)](img/04/stringr2.PNG){width=40%}\n\n</center>\n\nEl paquete encargado de trabajar con cadenas de caracteres dentro de tidyverse es **stringr**.\n\nTodas las funciones del paquete comienzan con **str\\_** y trabajan sobre un vector de caracteres como primer argumento.\n\nHay tres grandes familias útiles de funciones en **string**:\n\n**Funciones de manipulación de caracteres**: estas funciones permiten manipular caracteres dentro de cadenas\n\n**Herramientas para tratamiento de espacios en blanco**: para agregar, eliminar y manipular espacios en blanco.\n\n**Funciones de coincidencia de patrones**: trabaja con motores de descripción de patrones, para funciones de busqueda, extracción, reemplazo, etc. Trabajan con expresiones regulares.\n\n**stringr** también se instala y activa junto a tidyverse.\n\n### Manipulación de caracteres\n\nPodemos obtener la longitud de la cadena con `str_lenght()`\n\n```{r}\nstr_length(\"abc\")\n```\n\nEsta función es equivalente a la función de R base *nchar()*.\n\nPara acceder a un carácter individual se utiliza `sub_str()`.\n\nSe necesitan tres argumentos: un vector de caracteres, una posición inicial y una posición final. Cualquiera de las posiciones puede ser un entero positivo, que cuenta a partir de la longitud, o un entero negativo que cuenta desde la derecha. Las posiciones son inclusivas, y si es más larga que la cadena, se truncarán silenciosamente.\n\n```{r}\nx <- c(\"abcdef\", \"ghifjk\")\n```\n\nla tercer letra de cada cadena\n\n```{r}\nstr_sub(x, 3, 3)\n```\n\ndesde la segunda letra hasta la anteúltima\n\n```{r}\nstr_sub(x, 2, -2)\n```\n\nTambién puede utilizar `str_sub()` para modificar cadenas de caracteres\n\n```{r}\nstr_sub(x, 3, 3) <- \"X\"\n\nx\n```\n\nEl paquete **stringr** trae incorporado algunas funciones para manipulación de mayúsculas y minúsculas, similares a `tolower()` y `toupper()`\n\n```{r}\nx <- \"Curso de lenguaje R\"\n```\n\nconvierte a mayúsculas\n\n```{r}\nstr_to_upper(x)\n```\n\nconvierte a minúsculas\n\n```{r}\nstr_to_lower(x)\n```\n\nconvierte a tipo título (la primer letra de cada palabra en mayúsculas)\n\n```{r}\nstr_to_title(x)\n```\n\nTambién existen funciones para ordenar secuencias de caracteres\n\n```{r}\nx <- c(\"y\", \"i\", \"k\")\n\nstr_order(x)\n```\n\ndevuelve el orden alfabético del índice de los elementos\n\n```{r}\nstr_sort(x)\n```\n\ndevuelve los caracteres en orden alfabético\n\n```{r}\nstr_sort(x, decreasing = T)\n```\n\nigual al anterior pero en orden decreciente\n\n### Espacios en blanco\n\nHay tres funciones que añaden, eliminan o modifican espacios en blanco\n\n`str_pad()` agrega espacio en blanco extra a una cadena a una longitud fija puede ser a izquierda, derecha o ambos lados.\n\n```{r}\nx <- c (\"abc\", \"defghi\")\n```\n\n```{r}\nstr_pad(x, 10)\n```\n\nrellena con espacios en blanco hasta alcanzar la cantidad de 10 caracteres por cadena sin definir el argumento side= lo hace a la izquierda\n\n```{r}\nstr_pad(x, 10, side = \"both\")\n```\n\naquí lo hacemos rellenando los espacios en blanco a ambos lados\n\nLo opuesto a rellenar de espacios en blanco es eliminarlos y esta tarea la realiza la función `str_trim()`\n\n```{r}\nx <- c(\"  a   \", \"b   \",  \"   c\")\n\nstr_trim(x)\n```\n\nelimina todos los espacios en blanco a ambos lados de la cadena\n\n```{r}\nstr_trim(x, side=\"left\")\n```\n\ncon el argumento *side=* le podemos indicar de que lado queremos eliminarlos\n\n### Patrones\n\n<center>\n\n![[Artwork por \\@allison_horst](https://allisonhorst.com/)](img/04/stringr.PNG){width=40%}\n\n</center>\n\nLa mayoría de las funciones de **stringr** para trabajo con patrones de caracteres funcionan con [expresiones regulares](https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular) (un lenguaje conciso para describir patrones de texto).\n\nBásicamente una expresión regular es una cadena de texto especial para describir un patrón de búsqueda que se puede utilizar para:\n\n-   localizar cadenas de caracteres (ubicar - filtrar)\n\n-   extraer una porción de los datos (extraer)\n\n-   modificar los datos localizados (reemplazar)\n\nHabitualmente se construyen concatenando la especificación de caracteres secuenciados junto a otros metacaracteres.\n\nSon muy útiles cuando tenemos variables de alfanuméricas regulares, es decir con una estructura que se repite. Por ejemplo, los códigos internacionales de enfermedad, conocidos como CIE (actualmente en la versión CIE10/CIE11)\n\nAlgunos de los metacaracteres para construir expresiones regulares son:\n\n| Símbolos y metacaracteres | Descripción                                                    |\n|-----------------------------|-------------------------------------------|\n| \\^                        | Inicio de la cadena                                            |\n| \\$                        | Final de la cadena                                             |\n| \\[ \\]                     | Cualquier carácter del conjunto entre paréntesis               |\n| \\[\\^\\]                    | Cualquier carácter no incluido en el conjunto                  |\n| ?                         | Cero o una ocurrencia de lo que precede al símbolo             |\n| \\+                        | El caracter que le precede debe aparecer al menos una vez      |\n| \\*                        | El caracter que le precede debe aparecer cero, una o más veces |\n| {x}                       | x ocurrencias del caracter que lo precede                      |\n| {x,z}                     | Entre x y z ocurrencias del caracter que lo precede            |\n| {x,}                      | x o más ocurrencias de lo que lo precede                       |\n\n| Símbolos y metacaracteres | Descripción                                           |\n|---------------------------|-------------------------------------------------------|\n| \\|                        | Une subexpresiones                                    |\n| .                         | Concuerda con cualquier carácter individual           |\n| ( )                       | Agrupa subexpresiones                                 |\n| 0-9 a-z A-Z               | Rangos de números, letras…                            |\n| \\\\                        | Marca el carácter siguiente como un carácter especial |\n| .                         | Representa un punto dentro del patrón                 |\n| s                         | Representa un espacio en blanco dentro del patrón     |\n| n                         | Representa un salto de línea dentro del patrón        |\n| d                         | Representa un dígito numérico dentro del patrón       |\n| w                         | Representa un carácter alfanumérico dentro del patrón |\n\n------------------------------------------------------------------------\n\nVeamos un ejemplo con un grupo de códigos CIE10 relacionados a la hepatitis B.\n\n```{r}\n#| echo: false\n\nhepb <- c(\"B16\",\"B160\", \"B161\", \"B162\", \"B169\", \"B170\", \"B178\", \"B180\", \"B181\", \"B189\")\n\ncodigos <- data.frame(hepb)\n```\n\nTenemos una pequeña tabla de datos con 10 códigos en la variable **hepb**\n\n```{r}\ncodigos\n```\n\nSupongamos que se encuentran insertos en una tabla de datos con otros códigos y necesitamos detectarlos para extraerlos o contarlos.\n\nSi las expresiones regulares no existiesen deberíamos hacer algo así:\n\n```{r}\ncodigos %>% \n  filter(hepb ==\"B16\" | hepb >= \"B160\" & hepb <= \"B162\" | hepb == \"B169\" | \n         hepb == \"B170\" | hepb ==\"B178\" | hepb ==\"B180\" | hepb ==\"B181\" | \n         hepb == \"B189\")\n\n```\n\nEs decir, concatenar una serie de operadores y conectores lógicos OR dentro de un filtro por ejemplo para lograr su extracción.\n\nCon las expresiones regulares tenemos una alternativa de hacer esta tarea dividiendo el trabajo en partes y aplicar la función `str_detect()` de **stringr**.\n\n```{r}\ncodigos %>% \n  filter(str_detect(hepb, \"^B16[0-2|9]?$\"))  #  selecciona el grupo B16x\n\ncodigos %>% \n  filter(str_detect(hepb, \"^B17[08]$\")) # selecciona el grupo B17x\n\ncodigos %>% \n  filter(str_detect(hepb, \"^B18[019]$\")) # selecciona el grupo B18x\n```\n\nY finalmente unirlo con conectores OR:\n\n```{r}\ncodigos %>% \n  filter(str_detect(hepb, \"^B16[0-2|9]?$|^B17[08]$|^B18[019]$\"))\n```\n\nO mejor construir una expresión regular más sintética aprovechando los metadatos adecuados.\n\n```{r}\ncodigos %>% \n  filter(str_detect(hepb, \"^B1[6-9][0-9]?$\"))\n```\n\nAdemás de la función de detección `str_detect()` el paquete aporta `str_extract()` para extraer y `str_replace()` para reemplazar directamente\n\n## Factores\n\n<center>\n\n![[Artwork por \\@allison_horst](https://allisonhorst.com/)](img/04/forcats.PNG){width=40%}\n\n</center>\n\nLos factores son simplemente el formato de datos que R reserva para las variables categóricas y estan compuesto por valores numéricos internos asociados a etiquetas que definen cada una de los niveles (categorías o niveles definidos).\n\nEl paquete **forcats** es parte del ecosistema tidyverse pensado para trabajar con este tipo de dato.\n\nEn función de que las herramientas del paquete son de aplicación práctica vamos a trabajar con un conjunto de datos ficticios creados con la finalidad de mostrar la potencialidad de **forcats**.\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n\ndatos <- read_excel(\"datos/Base_factores.xlsx\",sheet = 1, col_names = T)\n\n```\n\n```{r}\nglimpse(datos)\n```\n\nObservamos que el objeto llamado `datos` tiene 6 variables de tipo caracter y 19 observaciones.\n\nEstas variables de caracter tienen como característica representar variables cualitativas nominales y ordinales que para su mejor tratamiento dentro del R deberían ser convertidas a factores.\n\nComenzamos con la primer variable (*Enfermedad*). La función simple y de R base que conocemos para convertirla en factor es `factor()`.\n\n```{r}\ndatos <- datos |> \n  mutate(Enfermedad = factor(Enfermedad))\n\nlevels(datos$Enfermedad)\n```\n\nLa función del paquete **forcats** para realizar la misma tarea se llama `as_factor()`. No agrega ningun funcionalidad extra por lo que es indistinto utilizar una forma u otra.\n\nAquí la utilizamos para convertir la variable *Sexo*\n\n```{r}\ndatos <- datos |> \n  mutate(Sexo = as_factor(Sexo))\n```\n\nSi queremos visualizar los niveles del factor podemos usar `levels()` (función de R base):\n\n```{r}\nlevels(datos$Sexo)\n```\n\nEncontramos uno de los problemas habituales cuando trabajamos con datos reales cargados por diferentes usuarios o cuando unimos bases de diverso origen. Las categorías se encuentran etiquetadas de manera diferente aunque conceptualmente se refieran a lo mismo (ejemplo: \"Femenino\" - \"Mujer\")\n\nDebemos corregir este inconveniente y para esta tarea el paquete ofrece una función que recodifica los niveles. Se llama `fct_recode()` y la aplicamos así:\n\n```{r}\ndatos <- datos |> \n  mutate(Sexo = fct_recode(Sexo, \n                           Varon = \"Masculino\", \n                           Mujer = \"Femenino\"))\n\nlevels(datos$Sexo)\n\ndatos |> \n  reframe(fct_count(Sexo))\n```\n\nVemos en los argumentos que le indicamos que \"Masculino\" es igual a Varon y \"Femenino\" igual a Mujer. Esto provoca que en todos los casos donde aparezca \"Masculino\" sea reemplazado por Varon y cuando aparezcan \"Femenino\" se cambie por Mujer.\n\nFinalmente verificamos que los niveles sean los dos que necesitamos y además podemos producir un listado de frecuencias de los niveles del factor con `fct_count()` dentro de un `reframe()` que es la opción correcta al `summarise()` cuando el resultado es mayor a una fila a partir de la versión 1.1.0 de **dplyr**.\n\nHasta aquí tenemos las dos primeras variables convertidas y podrían ser utilizadas en un análisis posterior para construir una tabla de contingencia de Sexo vs Enfermedad.\n\n```{r}\n#| message: false\n#| warning: false\n\nlibrary(janitor)\n\ndatos |> \n  tabyl(Sexo, Enfermedad)\n```\n\nObservemos que en esta tabla el orden de los niveles de Enfermedad quizás no sea el más conveniente para tablas 2x2 y sus cálculos asociados (razones o diferencias de razones), donde se necesita que la tabla tenga una forma y orden específico para que los valores e las ecuaciones sean los correctos.\n\nEsta situación causa que muchas veces tengamos que reordenar las categorías de las variables cualitativas y los niveles de los factores son ideales para esto. La función encargada de esta tarea en **forcats** es `fct_relevel()` que no es muy diferente al `relevel()` del R base.\n\n```{r}\ndatos <- datos |> \n  mutate(Enfermedad = fct_relevel(Enfermedad, \"Si\"))\n\ndatos |> \n  tabyl(Sexo, Enfermedad)\n```\n\nAplicado sobre **Enfermedad** observamos, luego en la tabla 2x2, que la categoría **Si** aparece primera como necesitamos.\n\nLo mismo podríamos hacer con la variable **Sexo** si quisieramos que el nivel de referencia fuese Mujer en lugar de Varon.\n\n```{r}\ndatos <- datos |> \n  mutate(Sexo = fct_relevel(Sexo, \"Mujer\"))\n\ndatos |> \n  tabyl(Sexo, Enfermedad)\n```\n\nContinuamos con la siguiente variable y luego de transformarla pedimos sus niveles.\n\n```{r}\ndatos <- datos |> \n  mutate(Civil = factor(Civil))\n\nlevels(datos$Civil)\n```\n\nAparecen 4 niveles para la variable. Para ver la frecuencia de aparición hacemos:\n\n```{r}\ndatos |> \n  reframe(fct_count(Civil))\n```\n\nEn la frecuencia aparecen los 4 niveles más un valor faltante (NA). Estos valores habitualmente se omiten en muchas de las operaciones que realiza el lenguaje.\n\nPero supongamos que deseamos mostrar dentro de una tabla de frecuencia la cantidad de valores perdidos o desconocidos que tenemos de la variable **Estado Civil**. Deberíamos etiquetar ese `NA` para poder visualizarlo.\n\nLa función del paquete encargada de la tarea es `fct_na_value_to_level()`\n\n```{r}\ndatos <- datos |> \n  mutate(Civil = fct_na_value_to_level(Civil, \n                                       level = \"Desconocido\"))\n\ndatos |> \n  reframe(fct_count(Civil))\n\nlevels(datos$Civil)\n```\n\nPensando en poder graficar esta variable construimos un gráfico de barras sencillo.\n\n```{r, out.width=\"60%\", fig.align=\"center\"}\ndatos |> \n  ggplot(aes(x = Civil, fill = Civil)) + \n  geom_bar()\n```\n\nUna mejor presentación sería si las barras se encuentran ordenadas (de mayor a menor) por la frecuencia de cada categoría.\n\nPodríamos ordenar mediante `arrange()` (del paquete dplyr de tidyverse) pero este ordenamiento sirve solo como prosentación, es decir el nuevo orden no se guarda dentro de los niveles del factor.\n\nPara poder hacer usamos `fct_infreq()`:\n\n```{r}\ndatos <- datos |> \n  mutate(Civil = fct_infreq(Civil))\n\nlevels(datos$Civil)\n```\n\nAhora el gráfico nos saldría como queremos:\n\n```{r, out.width=\"60%\", fig.align=\"center\"}\ndatos |> \n  ggplot(aes(x = Civil, fill = Civil)) + \n  geom_bar()\n```\n\nSigamos con otra de las variables. En este caso **Esalud** que tiene el estado de salud autoreportado por las personas. Como representa una variable categórica ordinal tenemos que estar atentos al orden de las categorías que R siempre forzará a que cumpla con el alfabético.\n\nPodemos usar directamente `fct_relevel()` con los niveles completos en el orden correcto.\n\n```{r}\nclass(datos$Esalud)\n\ndatos <- datos |> \n  mutate(Esalud = fct_relevel(Esalud,\n                              \"Muy buena\",\n                              \"Buena\",\n                              \"Regular\",\n                              \"Mala\",\n                              \"Muy mala\"))\n         \nlevels(datos$Esalud)\n```\n\nObservemos que no hizo falta primero convertir en factor y luego aplicar la función de **forcats**. Todas las funciones comenzadas con **fct\\_** aplicadas a un tipo caracter convertiran a factor previamente a la operación que realicen.\n\nEn este caso además los niveles tienen un orden lógico que comienza en \"Muy buena\" salud y termina en \"Muy mala\". Quizás el orden necesario sea inverso y `fct_rev()` hace la tarea.\n\n```{r}\ndatos <- datos |> \n  mutate(Esalud = fct_rev(Esalud))\n\nlevels(datos$Esalud)\n```\n\nFinalmente conseguimos que el factor sea ordenado y que los niveles sigan el esquema de aumentar hacia la derecha.\n\nLa siguiente variable es *Ciudad*. Veamos su contenido:\n\n```{r}\ndatos |> \n  count(Ciudad)\n```\n\nPosee 4 etiquetas con nombres de ciudades. Su frecuencia es:\n\nVemos que mayoritariamente las observaciones pertenecen a Mar del Plata. Muchas veces cuando estamos frente a situaciones como esta, donde hay varias categorías con poca frecuencia, es mejor agruparlas en un \"Otras/os\". Eso mismo vamos a realizar con la función `fct_other()`.\n\n```{r}\ndatos <- datos |> \n  mutate(Ciudad = fct_other(Ciudad, \n                            keep = \"Mar del Plata\", \n                            other_level = \"Otras\"))\n\nlevels(datos$Ciudad)\n\ndatos |> \n  count(Ciudad)\n```\n\nLa última de las variables de la tabla de datos es *Comorbilidades*.\n\n```{r}\ndatos |> \n  count(Comorbilidades)\n```\n\nSus etiquetas son 7 y se trata de enfermedades que podemos vincular a distintos grupos, es decir, que nos va a servir de excusa para probar otra función de **forcats**.\n\nLa función es `fct_collapse()` y permite agrupar niveles a grupos que serían las nuevas etiquetas de nivel.\n\nLo vamos a hacer asignando a una nueva variable (*Comor_agrupadas*) y generando los niveles Respiratoria, Digestiva y Circulatorio, para enfermedades respiratorias, enfermedades del aparato digestivo y enfermedades del aparato circulatorio.\n\n```{r}\ndatos <- datos |> \n  mutate(Comor_agrupadas = fct_collapse(Comorbilidades,\n                                      Respiratoria = c(\"EPOC\",\n                                                       \"TBC\", \n                                                       \"Neumonia\"),\n                                      Digestiva = c(\"Hepatitis\",\n                                                    \"Gastritis\"),\n                                      Circulatorio  = c(\"aterosclerosis\",\n                                                        \"Hipertensión\")))\n\nlevels(datos$Comor_agrupadas)\n\ndatos |> \n  count(Comor_agrupadas)\n```\n\nNos quedan para ver tres funciones más del paquete presentado.\n\nLa primera es `fct_drop()` que elimina los niveles que no se utilizan. Veamosla en acción.\n\nTomamos el caso de una selección de la tabla original **datos** filtrado por las observaciones que pertenecen a Mar del Plata, guardado en otro dataframe al que llamaremos **datos_MdP**\n\n```{r}\ndatos_MdP <- datos  |>  \n  filter(Ciudad == \"Mar del Plata\")\n```\n\nSi vemos sus niveles confirmaremos que heredó los que tenía la variable en el tibble original. Pero una tabla nos mostraría que no hay datos para el nivel \"Otras\".\n\n```{r}\nlevels(datos_MdP$Ciudad)\n\ndatos_MdP |> \n  tabyl(Ciudad)\n```\n\nAquí entra en juego la función `fct_drop()` que aplicada a la variable *Ciudad* de **datos_MdP** produce:\n\n```{r}\ndatos_MdP <- datos_MdP |> \n  mutate(Ciudad = fct_drop(Ciudad))\n\nlevels(datos_MdP$Ciudad)\n\ndatos_MdP |> \n  tabyl(Ciudad)\n```\n\nA la inversa, la función `fct_expand()` incorpora niveles a la lista de niveles de un factor.\n\nVolvemos a trabajar con el dataframe **datos** y vamos a asignar nuevos niveles al factor de la variable *Ciudad*.\n\n```{r}\ndatos <- datos |> \n  mutate(Ciudad = fct_expand(Ciudad, \"La Plata\", \n                             \"Tandil\", \n                             \"CABA\"))\n\nlevels(datos$Ciudad)\n```\n\nEsto significa que tenemos tres categorías posibles más en el factor que están disponibles para nuevas observaciones, aunque en el conjunto de datos no esten siendo utilizadas por ahora.\n\nPor último, la función `fct_c()` concatena factores combinandos niveles. Para ejemplificar su uso vamos a construir dos factores tipo vector que finalmente uniremos.\n\nImaginemos que tenemos que unir dos variables pertenecientes a conjuntos de datos que queremos unificar. En la variable1 hay definidos dos niveles \"Corrientes\" y \"Posadas\" y en la variable2 tres niveles \"Corrientes\", \"Resistencia\" y \"Goya\".\n\n```{r}\nvar1 <- factor(c(\"Corrientes\",\"Corrientes\",\"Posadas\",\"Corrientes\",\n                 \"Posadas\"))\n\nvar2 <- factor(c(\"Resistencia\",\"Goya\",\"Goya\",\"Resistencia\",\"Resistencia\",\n                 \"Corrientes\",\"Goya\"))\n\nvar1\n\nvar2\n```\n\nA continuación concatenamos aplicando `fct_c()`:\n\n```{r}\nvar3 <- fct_c(var1, var2)\n\nvar3\n```\n\nObservamos que no solo une los datos de las variables sino que respeta los niveles definidos de cada uno fusionando las categorías.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"link-external-filter":"^https:\\/\\/(www\\.)?(linkedin|twitter|github)\\.*"},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","include-in-header":[{"text":"<link rel=\"icon\" type=\"image/x-icon\" href=\"img/favicon.ico\">\n"},{"text":"<link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n"}],"toc":true,"output-file":"04-tipos.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"Contenido","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.54","theme":{"light":["pulse","../../custom.scss"],"dark":"darkly"},"code-copy":true,"anchor-sections":false,"bibliography":["../../references.bib"],"title":"**Gestión de tipos de datos**","number_sections":true,"anchor_sections":true,"page-layout":"full","toc-title":"Contenidos","toc-location":"left","toc_float":true,"toc_collapsed":false,"toc_depth":4},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}