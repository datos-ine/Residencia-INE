{"title":"**Tidyverse**","markdown":{"yaml":{"title":"**Tidyverse**","format":{"html":{"page-layout":"full","include-in-header":[{"text":"<link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n"}],"toc":true,"toc-title":"Contenidos","toc-location":"left","toc_float":true,"toc_collapsed":false,"toc_depth":4}},"number_sections":true,"anchor_sections":true},"headingText":"Introducción","containsRefs":false,"markdown":"\n\n```{r, message=FALSE, echo=F}\nknitr::opts_chunk$set(comment=NA, dpi = 300)\n```\n\n![](img/03/tidyverse.gif){width=10% fig-align=\"center\"}\n\n```{r, echo=F, message=F, warning=F}\nlibrary(dlookr)\n```\n\n\nTidyverse es el nombre que se ha dado al conjunto de paquetes desarrollados a partir de la inciativa de [Hadley Wickham](https://en.wikipedia.org/wiki/Hadley_Wickham) (jefe científico de Posit -antes RStudio-) y su equipo, para ciencia de datos con R.\n\nEstos paquetes están diseñados para funcionar juntos y comparten una misma filosofía, que se puede consultar en [The tidy tools manifesto](https://cran.r-project.org/web/packages/tidyverse/vignettes/manifesto.html).\n\nLos cuatro principios básicos en los que se basa son:\n\n-   Reutilizar las estructuras de datos\n-   Resolver problemas complejos combinando varias piezas sencillas\n-   Utilizar programación funcional\n-   Diseñado para humanos\n\nLos paquetes incluidos en el tidyverse tienen como objetivo cubrir todas las fases del análisis de datos dentro de R: importar datos, ponerlos en formato ordenado (tidy data), buscar relaciones entre ellos (mediante su transformación, visualización y creación de modelos) y comunicar los resultados.\n\nLa palabra \"tidy\" se puede traducir como \"ordenado\" y refiere a que los datos deben cumplir con una estructura determinada donde:\n\n-   Cada ***variable*** es una *columna* de la tabla de datos.\n-   Cada ***observación*** es una *fila* de la tabla de datos.\n-   Cada ***tabla*** responde a una *unidad de observación o análisis*.\n\n```{r,echo=F,  fig.align='center', out.width = \"60%\"}\nknitr::include_graphics(\"img/03/tidy.PNG\")\n```\n\nAdemás de los paquetes principales que realizan estas funciones, al instalar el tidyverse también se proporcionan otros que ayudan a trabajar con fechas, cadenas de caracteres o factores siguiendo los mismos principios.\n\nUna de las interesantes incorporaciones transversales en el ambiente tidyverse es el uso de tuberías (pipe en inglés).\n\nUna tubería conecta un trozo de código con otro mediante el conector `%>%` que surge del paquete **magrittr** que permite transformar llamadas de funciones anidadas (con muchos paréntesis) en una simple serie de operaciones que son más fáciles de escribir y comprender. Este aporte fue tan importante que el equipo de desarrolladores que mantiene el lenguaje R incorporó la idea a partir de la versión 4.1.0 de 2021, agregando la funcionalidad nativa con el operador `|>`.\n\n**Nota:** *durante el curso pueden llegar a coexistir ambas tuberías, dado que funcionan igual. De todas maneras, al utilizar versiones actualizadas del lenguaje preferimos utilizar la tubería nativa que es más eficiente que la propia del tidyverse.*\n\nLa idea de tubería responde al principio donde cada función es un paso y la forma de trabajar se puede ver en el siguiente esquema general:\n\n```{r,echo=F,  fig.align='center', out.width = \"40%\"}\nknitr::include_graphics(\"img/03/pipe.png\")\n```\n\n**Base gramatical**\n\nLa intención de los desarrolladores para este conjunto de paquetes es lograr incorporar una gramática a la sintaxis de las funciones y sus argumentos buscando un entendimiento semántico más claro.\n\nUna prueba de ello, es que la mayoría de las funciones son verbos que se entrelazan con objetos y argumentos que permiten construir *\"frases\"*.\n\n## El paquete de paquetes\n\nEl paquete tidyverse nucleo actual (versión 2.0.0) se puede descargar del repositorio oficial CRAN mediante menú **Packages** de **RStudio** o ejecutando en consola:\n\n```{r, eval=F}\ninstall.packages(\"tidyverse\")\n```\n\nSe activa, como cualquier otro paquete, mediante:\n\n```{r, warning=FALSE}\nlibrary(tidyverse)\n```\n\nObservamos que nos informa sobre la versión del paquete, el listado de paquetes que acabamos de activar sólo llamando a tidyverse y una serie de conflictos de nombres de funciones.\n\nEsto es muy habitual cuando activamos varios paquetes, dado que las funciones que se encuentran dentro de ellos pueden llamarse iguales.\n\nPor ejemplo, existe en el paquete base stats y en el paquete dplyr (que es parte de tidyverse) una función llamada `filter()`, por lo tanto al activar tidyverse nos informa de esta manera: **dplyr::filter() masks stats::filter()**\n\nEn este caso, cuando necesitemos asegurarnos que la función que deseamos ejecutar pertenece a determinado paquete, es recomendable escribirla de la siguiente forma:\n\n> nombre_paquete::nombre_función\n\n**stats::filter()** para la función **filter()** del paquete **stats**\n\n**dplyr::filter()** para la función **filter()** del paquete **dplyr**\n\nLos paquetes incluidos que se instalan en esta versión son 31:\n\n```{r}\ntidyverse_packages()\n```\n\nExisten otros paquetes (la cantidad crece con el tiempo) que son creados bajo la misma filosofía pero no están incluidos. En esos casos hay que instalarlos y activarlos individualmente.\n\nPara profundizar sobre **tidyverse** se puede visitar el sitio <https://www.tidyverse.org/> y la primera versión del libro traducido al español [r4ds](https://es.r4ds.hadley.nz/index.html). La segunda versión está disponible en inglés en [r4ds(2e)](https://r4ds.hadley.nz/)\n\n## Lectura y escritura de datos\n\n### Paquete **readr**\n\n**readr** contiene funciones similares a las de la familia **read.table()** de **R base** pero desarrollados bajo el ecosistema **tidyverse**.\n\nLos archivos de texto plano (**ASCII y otras codificaciones**) son universalmente utilizados por la mayoría de los gestores de bases de datos y/o planillas de cálculo. Generalmente encontrados con extensiones **.txt** o **.csv** (por comma-separated values) son el tipo de archivo de datos más habitual dentro del lenguaje R.\n\nEstos datos planos tienen dos peculiaridades:\n\n-   La cabecera (en inglés **header**)\n-   El caracter o símbolo **separador** que indica la separación de columnas: pueden estar separadas por comas, puntos y comas, por tabulación, etc…\n\nLa cabecera puede existir o no, y de existir puede ser simple o compleja. La inclusión o no de la cabecera se maneja desde los argumentos `col_names` y `skip`.\n\nCon `col_names = TRUE` incluimos la primer fila como cabecera (nombre de las columnas) y en FALSE la salteamos.\n\nCon `skip = 0` la lectura de produce desde la primer fila (se puede omitir), pero si la cabecera fuese compleja con varias filas entre títulos y subtítulos, debemos indicar cuantas filas iniciales se \"saltea\". Por ejemplo con `skip = 5` se saltea las primeras 5 filas del archivo.\n\nEl otro elemento a tener en cuenta es el caracter separador que utiliza el archivo para indicar cuando comienza una nueva columna (variable).\n\nGeneralmente los separadores más comunes son: la coma (,), el punto y coma (;), el tabulador (TAB), el espacio ( ), el caracter pipe (\\|), entre otros posibles.\n\nAlgunas de las funciones del paquete asumen un separador particular. Por caso `read_csv()` lee separados por coma y `read_tsv()` separado por tabulaciones, pero la función `read_delim()` permite que definamos el separador a través del argumento `delim =`.\n\nEn forma detallada el paquete **readr** soporta siete formatos de archivo a partir de siete funciones:\n\n-   **read_csv()**: archivos separados por comas (CSV)\n-   **read_tsv()**: archivos separados por tabulaciones\n-   **read_delim()**: archivos separados con delimitadores generales\n-   **read_fwf()**: archivos con columnas de ancho fijo\n-   **read_table()**: archivos formato tabla con columnas separadas por espacios\n-   **read_log()**: archivos log web\n\nEn comparación con las funciones base de R, las funciones de **readr**:\n\n-   Usan un esquema de nombres consistente de parámetros\n-   Son más rápida.\n-   Analizan eficientemente los formatos de datos comunes, incluyendo fecha/hora.\n-   Muestran una barra de progreso si la carga va a llevar un tiempo. (para archivos grandes)\n\nViene incluida dentro de la instalación de tidyverse y se activa con él, pero también permite activarse solo:\n\n```{r, message=F}\nlibrary(readr)\n```\n\nAlgunos ejemplos de sintaxis:\n\n-   Leemos un archivo sin cabecera separado por comas\n\n```{r, message=F, warning=F}\nread_csv(\"datos/ejemplo-datos.csv\", col_names = F)\n```\n\n-   Leemos el mismo archivo con cabecera y separado por punto y comas\n\n```{r, message=F, warning=F}\nread_csv2(\"datos/ejemplo-datos-header.csv\", col_names = T)\n```\n\n-   Leemos el archivo con cabecera separado por tabulaciones\n\n```{r}\nread_tsv(\"datos/ejemplo-datos-header2.csv\", col_names = T)\n```\n\nObservemos que cada vez que hacemos una lectura la función se encarga de analizar (*parse*) el tipo de dato que hay en cada columna. En esta última ocasión además, devuelve un listado con el resultado del análisis antes de mostrar la tabla importada.\n\nLos posibles tipos de datos son los atómicos del lenguaje más algún agregado: character, integer, numeric, double, logical y date/time.\n\nPor ejemplo, en la tabla leída anteriormente las columnas donde hay números enteros fueron reconocidos como double (**\\<dbl\\>**), los que tienen algún caracter como character (**\\<chr\\>**) y las fechas como date (**\\<date\\>**).\n\nAhora escribimos la sintaxis para leer un archivo con cabecera compleja (la tabla comienza en la fila 9) separado por |.\n\n```{r, message=F, warning=F}\nread_delim(\"datos/ejemplo-datos-header-skip.txt\", \n           col_names = T, \n           skip = 8,      # salteamos las primeras 8 filas\n           delim = \"|\")\n```\n\n> En estos ejemplos visualizamos el contenido de los archivos leídos en consola con el propósito de mostrar como trabajan las funciones, pero en la práctica cada vez que importemos datos de un archivo debemos **asignar** su salida a un nombre, que será el nombre del dataframe que reciba los datos dentro de nuestra sesión de trabajo. (`<-`)\n\n#### Funciones de escritura\n\nDentro del paquete coexisten funciones espejo de escritura para las posibilidades de lectura más relevantes. Así encontramos estos cuatro:\n\n-   **write_csv()**: escribe archivos separados por comas (csv)\n-   **write_csv2()**: escribe archivos separados por punto y comas (csv)\n-   **write_tsv()**: escribe archivos separados por tabulaciones\n-   **write_delim()**: escribe archivos separados con delimitadores definidos por el usuario\n\nLos argumentos son generales y para el caso del último más extensos, dado que hay que definir cual es el separador que deseamos en el archivo.\n\n```{r}\nargs(write_delim)\n```\n\nPor ejemplo para exportar un conjunto de datos en texto plano al que denominaremos **ejemplo.csv** con separador **punto y coma** y **cabecera incluida** podemos hacer:\n\n```{r, eval=F}\nwrite_delim(x = datos, file = \"ejemplo.csv\", delim = \";\")\n```\n\no más sencillo:\n\n```{r, eval=F}\nwrite_csv2(datos, \"ejemplo.csv\")\n```\n\n### Paquete **readxl**\n\nUno de los formatos de documentos más comunes en los que se almacenan datos son las hojas de cálculo, en particular, las creadas con el programa **Excel** de Microsoft Office.\n\nEl paquete `readxl` es parte del ecosistema tidyverse y permite leer este tipo de archivos.\n\nPosee compatibilidad con hojas de cálculo de Excel 97-03, de extensión **.xls**, y con hojas de cálculo de las versiones más recientes de Excel, de extensión, **.xlsx**\n\nLa primera función interesante es `excel_sheets()`, útil para conocer y listar los nombre de las hojas contenidas dentro de un archivo (libro) Excel.\n\nPor ejemplo, supongamos que tenemos un archivo denominado **datos.xlsx** y queremos saber por cuantas hojas está compuesto y que nombre tienen.\n\n```{r}\nlibrary(readxl) # hay que activarlo independientemente de tidyverse\n\nexcel_sheets(\"datos/datos.xlsx\")\n```\n\nObtenemos de esta manera información sobre el archivo. Hay tres hojas llamadas diabetes, vigilancia y mortalidad.\n\nPara poder leer cada una de estas hojas de datos debemos usar la función `read_excel()`, que tiene los siguientes argumentos:\n\n```{r}\nargs(read_excel)\n```\n\nDonde los más relevantes son:\n\n**path**: nombre del archivo y la ubicación (si fuese necesaria) entre comillas\n\n**sheet**: nombre de la hoja o número de ubicación\n\n**col_names**: si se activa toma la primer fila como nombres de columnas (variables)\n\n**skip**: permite saltear una cantidad determinada de filas antes de comenzar la lectura\n\nEn primer lugar, cuando ejecutamos esta función, llama a otra denominada `excel_format()` que determina frente a que formato de archivo estamos. Si es un Excel tipo .xsl o tipo .xlsx. En relación a esta respuesta, luego aplica la función específica para cada caso - `read_xls()` o `readxlsx()`.\n\nTodas estas funciones mencionadas en el procedimiento que sigue `read_excel()` se pueden utilizar en forma específica.\n\nContinuemos con el archivo **datos.xlsx** y procedamos a leer los datos de su primer hoja, llamada *diabetes*.\n\n```{r}\ndiabetes <- read_excel(path = \"datos/datos.xlsx\", \n                       sheet = \"diabetes\",\n                       col_names = T)\n\nhead(diabetes) # mostramos las 6 primeras observaciones\n```\n\nObservemos que en los argumentos escribimos el nombre del archivo que se encuentra en nuestro proyecto y por lo tanto en nuestra carpeta activa, el nombre de la hoja y nos aseguramos que la primer fila representa a la cabecera de la tabla (sus nombres de variables).\n\nComo el paquete `readxl` se inscribe dentro del universo tidyverse el formato de salida es un dataframe/tibble. En este caso de 23 observaciones por 8 variables.\n\nAhora leamos la segunda hoja de nombre *vigilancia*.\n\n```{r, message=F}\nvigilancia <- read_excel(path = \"datos/datos.xlsx\", \n                         sheet = 2, \n                         col_names = F)\n\nhead(vigilancia) # mostramos las 6 primeras observaciones\n```\n\nCentremos nuestra mirada en los argumentos anteriores: en lugar del nombre de la hoja usamos un **2** que es su ubicación (la segunda hoja del archivo Excel) y configuramos a **col_names** con **F** (false) porque el conjunto de datos no tiene cabecera.\n\nCuando ocurre esta situación donde la tabla no tiene nombre de columnas readxl le asigna nombres del tipo `...1`, `...2`, `...x`\n\nFinalmente leemos la última hoja disponible del archivo.\n\n```{r}\nmortalidad <- read_excel(path = \"datos/datos.xlsx\", \n                         sheet = \"mortalidad\",\n                         col_names = T, \n                         skip = 1)\n\nhead(mortalidad) # mostramos las 6 primeras observaciones\n```\n\nLo novedoso de esta lectura es el argumento `skip = 1` que debimos incorporar dado que, en este caso, la hoja de Excel comienza con una línea de título que no pertenece al conjunto de datos. También que el argumento sheet permite el nombre de la hoja elegida entre comillas.\n\nRetomando los argumentos generales de la función podemos mencionar estos otros:\n\n**n_max**: número máximo de filas leídas\n\n**range**: rango de celdas a leer (definidas como se suele usar en Excel, por ej: B3:D87)\n\n**col_types**: especificación del tipo de dato para cada columna leída. Se pueden utilizar los tipos habituales \"numeric\", \"logical\", \"text\", \"date\", etc. Existen dos tipos específicos más: \"skip\" que saltea la lectura de la columna y \"guess\" que permite que la función decida cual es el formato adecuado de importación. Este último es el modo predeterminado cuando no especificamos el argumento.\n\n**na**: caracter o vector que deseamos se interprete como valor perdido (missing). Por defecto las celdas vacías se interpretan de esta forma y se le asigna `NA`\n\n## Gestión de datos con el Paquete **dplyr**\n\nEl paquete **dplyr** es parte del universo tidyverse que fue desarrollado por *Hadley Wickham* a partir de optimizar una versión del paquete plyr.\n\nLa contribución significativa del paquete es proporcionar una \"gramática\" (funciones-verbos) para la manipulación y operaciones de datos que lo hace más fácil de entender.\n\nLas funciones clave del paquete, responden a las siguientes acciones (verbos):\n\n-   `select()`: devuelve un conjunto de columnas (variables)\n-   `rename()`: renombra variables en una conjunto de datos\n-   `filter()`: devuelve un conjunto de filas (observaciones) según una o varias condiciones lógicas\n-   `arrange()`: reordena filas de un conjunto de datos\n-   `mutate()`: añade nuevas variables/columnas o transforma variables existentes\n-   `summarise()`/`summarize()`: genera resúmenes estadísticos de diferentes variables en el conjunto de datos.\n-   `group_by()`: agrupa un conjunto de filas seleccionado, en un conjunto de filas de resumen de acuerdo con los valores de una o más columnas o expresiones.\n-   `count()`: contabiliza valores que se repiten, es decir genera tabla de frecuencias.\n\n### Argumentos comúnes en las funciones dplyr\n\nTodas las funciones, básicamente, tienen en común una serie de argumentos.\n\n1. El primer argumento es el nombre del conjunto de datos (objeto donde esta nuestra tabla de datos) \n\n2. Los otros argumentos describen que hacer con el conjunto de datos especificado en el primer argumento, podemos referirnos a las columnas en el objeto directamente sin utilizar el operador $, es decir sólo con el nombre de la columna/variable. \n\n3. El valor de retorno es un nuevo conjunto de datos. \n\n4. Los conjunto de datos deben estar bien organizados/estructurados, es decir debe existir una observación por columna y, cada columna representar una variable, medida o característica de esa observación. Es decir, debe cumplir con *tidy data*.\n\n### Activación del paquete\n\n**dplyr** está incluído en el paquete **tidyverse**, por lo que se encuentra disponible si tenemos activado a este último.\n\nTambién se puede activar en forma independiente, aunque no es necesario si ya activamos tidyverse:\n\n```{r, message=F, warning=F}\nlibrary(dplyr)\n```\n\n### Conjunto de datos para ejemplo\n\nVisualizar y entender el funcionamiento de estos \"verbos\" de manipulación es posible si ejemplificamos su aplicación. Por este motivo vamos a leer un conjunto de datos que servirá para ejercitar las funciones del paquete.\n\n```{r}\ndatos <- read_csv(\"datos/noti-vih.csv\") # asignamos la lectura a datos\n\nhead(datos) # mostramos las 6 primeras observaciones\n```\n\nLa tabla de datos \"noti-vih.csv\" contiene datos de notificación de vih por jurisdicción de Argentina para los años 2015 y 2016.\n\n### Función **select()**\n\nEsta función selecciona las variables que especificamos devolviendo un conjunto de datos \"recortado por columna\".\n\n`select()` utiliza un minilenguaje conciso que facilita hacer referencia a las variables según su nombre, ubicación, condición o tipo.\n\nAlguno de sus operadores son:\n\n- `:` para seleccionar un rango de variables consecutivas.\n\n- `-` para evitar seleccionar la variable que sigue al signo\n\n- `!` para tomar el complemento de un conjunto de variables.\n\nVeamos algunas aplicaciones de estas \"ayudas\" para hacer selecciones.\n\nTodas las variables menos *pob*\n\n```{r}\ndatos |>  \n  select(-pob)\n```\n\nOtra forma para el mismo resultado anterior (mediante el operador rango :)\n\n```{r}\ndatos |>  \n  select(jurisdiccion:casos)\n```\n\nLas variables *jurisdiccion* y *casos*\n\n```{r}\ndatos |>  \n  select(jurisdiccion, casos)\n```\n\nOtra forma para el mismo resultado anterior (mediante números de columna):\n\n```{r}\ndatos |>  \n  select(1, 3)\n```\n\nTodas las variables pasando *año* a la primera columna\n\n```{r}\ndatos |>  \n  select(\"año\", everything())\n```\n\nEsta última función `everything()`, pasada como argumento, es una de las  posibles funciones llamadas **\"ayudantes de selección\"**, entre las cuales se encuentra:\n\n-   `starts_with()`: selecciona todas las columnas que comiencen con el patrón indicado.\n\n-   `ends_with()`: selecciona todas las columnas que terminen con el patrón indicado.\n\n-   `contains()`: selecciona las columnas que posean el patrón indicado.\n\n-   `matches()`: similar a `contains()`, pero permite poner una expresión regular.\n\n-   `all_of()`: selecciona las variables pasadas en un vector (todos los nombres deben estar presentes o devuelve un error)\n\n-   `any_of()`: idem anterior excepto que no se genera ningún error para los nombres que no existen.\n\n-   `num_range()`: selecciona variables con nombre combinados con caracteres y números (ejemplo: num_range(\"x\", 1:3) selecciona las variables x1, x2 y x3.\n\n-   `where()`: aplica una función a todas las variables y selecciona aquellas para las cuales la función regresa TRUE (por ejemplo: `is.numeric()` para seleccionar todas las variables numéricas)\n\n- `group_cols()`: selecciona todas las columnas de agrupación.\n\nTodas estas funciones son muy útiles a la hora de seleccionar el conjunto de variables necesarias no solo para un `select()` básico sino también cuando necesitemos aplicar operaciones simultáneas y/o pivotear tablas de datos que necesiten garantizar formato ordenado (tidy-data).\n\n### Función **rename()**\n\nEsta función es una extensión de `select()`, dado que esta última permite cambiar el nombre de variables pero no es muy útil porque descarta todas las variables que no se mencionan explícitamente. En cambio `rename()` renombra variables mientras que mantiene las demás no mencionadas.\n\nPor ejemplo, cambiamos el nombre de la variable *pob* por *población*.\n\n```{r}\ndatos |> \n  rename(\"población\" = pob)\n```\n\n### Función **filter()**\n\nAsí como la función `select()` es utilizada para seleccionar columnas, la función `filter()` hace lo propio con las filas del conjunto de datos, produciendo un subconjunto de observaciones.\n\nVeamos un ejemplo sencillo sobre nuestros datos:\n\n```{r}\ndatos |> \n  filter(jurisdiccion == \"Tucuman\")\n```\n\nUtiliza los mismos operadores de comparación propios del lenguaje R\n\n| Comparación |                 |\n|:-----------:|-----------------|\n|     \\<      | menor a         |\n|     \\>      | mayor a         |\n|     ==      | igual a         |\n|     \\<=     | menor o igual a |\n|     \\>=     | mayor o igual a |\n|     !=      | no igual a      |\n|    %in%     | es parte de     |\n|    is.na    | es NA           |\n|   !is.na    | no es NA        |\n\nLo mismo con los operadores lógicos que se utilizan como conectores entre las expresiones.\n\n| Lógicos |                |\n|:-------:|----------------|\n|    &    | AND booleano   |\n|   \\|    | OR booleano    |\n|   xor   | OR exclusivo   |\n|    !    | NOT            |\n|   any   | cualquier TRUE |\n|   all   | todos TRUE     |\n\nCuando usamos múltiples argumentos separados por coma dentro de `filter()` se combinan con un conector **AND**, es decir cada expresión debe ser verdadera para que una fila sea incluida en la salida.\n\nPor ejemplo:\n\nFiltramos a las observaciones que cumplan con la condición que casos sea mayor a 100 y población sea menor a 1000000\n\n```{r}\ndatos |> \n  filter(casos > 100, pob < 1000000)\n```\n\nPara combinaciones dentro de una misma variable debemos utilizar el conector OR (`|`) o más útil el operador `%in%`.\n\nFiltramos a las jurisdicciones \"Buenos Aires\" y \"La Pampa\"\n\n```{r}\ndatos |> \n  filter(jurisdiccion == \"Buenos Aires\" | jurisdiccion == \"La Pampa\")\n```\n\n```{r}\ndatos |> \n  filter(jurisdiccion %in% c(\"Buenos Aires\", \"La Pampa\"))\n```\n\nFiltramos las observaciones de 2016 con casos mayores a 200 utilizando el conector AND (`&`). Es el mismo resultado que si utilizamos una coma.\n\n```{r}\ndatos |> \n  filter(año == \"2016\" & casos > 200)\n```\n\nFiltramos las observaciones inversas a la anterior mediante xor(), que selecciona los valores de año y casos exclusivos (es decir que no se den ambos en TRUE).\n\n```{r}\ndatos |> \n  filter(xor(año == \"2016\", casos > 200))\n```\n\n### Función **arrange()**\n\nLa función `arrange()` se utiliza para ordenar las filas de un conjunto de datos de acuerdo a una o varias columnas/variables. Por defecto, el ordenamiento es ascendente alfanumérico.\n\nOrdenamos la tabla **datos** por la variable *pob* (forma ascendente predeterminada):\n\n```{r}\ndatos |> \n  arrange(pob)\n```\n\nPara ordenar en forma descendente podemos utilizar `desc()` dentro de los argumentos de `arrange()`:\n\n```{r}\ndatos |> \n  arrange(desc(pob))\n```\n\nPodemos combinar ordenamientos. Por ejemplo, en forma alfabética ascendente para *jusrisdiccion* y luego numérica descendente para *casos*.\n\n```{r}\ndatos |> \n  arrange(jurisdiccion, desc(casos))\n```\n\n### Función **mutate()**\n\nEsta función nos proporciona computar tranformaciones de variables en un conjunto de datos. A menudo, tendremos la necesidad de modificar variables existentes o crear nuevas variables que se calculan a partir de las que tenemos, `mutate()` nos ofrece una interface clara para realizar este tipo de operaciones.\n\nPor ejemplo, nos puede interesar calcular tasas crudas para cada jurisdicción y año, en función de los casos y el total de población.\n\n```{r}\ndatos |> \n  mutate(tasa = casos/pob*100000)\n```\n\nObservemos que la función realiza el cálculo (en este caso tasas crudas por 100000 habitantes) e incorpora una nueva variable por cada observación con el resultado.\n\nTambién se pueden construir múltiples variables en la misma expresión, solamente separadas por comas.\n\n```{r}\ndatos |> \n  mutate(tasaxcien_mil = casos/pob*100000, \n         tasaxdiez_mil = casos/pob*10000)\n```\n\nSi necesitemos que estas dos nuevas variables queden dentro de la tabla de datos y no solo mostrarla en consola como hasta ahora, debemos utilizar el operador de asignación:\n\n```{r, eval=F}\ndatos <- datos |> \n  mutate(tasaxcien_mil = casos/pob*100000, \n         tasaxdiez_mil = casos/pob*10000)\n```\n\nLa propiedad imprescindible es que la función debe poder vectorizar: debe tomar un vector de valores como entrada, y devolver un vector con el mismo número de valores que la salida.\n\nNo hay forma de enumerar todas las funciones posibles que se podría usar, pero mencionaremos algunas que pueden ser útiles:\n\n-   Operadores aritméticos: +, -, \\*, /, \\^.\n\n-   Aritmética modular: %/% (división entera) y %% (resto), donde $x == y * (x \\ \\%/\\% \\ y) + (x\\ \\%\\% \\ y)$. La aritmética modular es una herramienta útil porque te permite dividir números enteros en porciones.\n\n-   Funciones matemáticas: `log()`, `log2()`, `log10()`, `exp()`, `sqrt()`, `abs()`, etc\n\n-   Valores acumulados: R proporciona funciones para ejecutar sumas, productos, mínimos y máximos acumulados: `cumsum()`, `cumprod()`, `cummin()`, `cummax()`; y **dplyr** proporciona `cummean()` para promedios acumulados.\n\n-   Clasificaciones (ranking): hay una serie de funciones de clasificación, por ejemplo `min_rank()`. Genera el tipo de clasificación habitual (1º, 2º, etc). El valor predeterminado relaciona los valores más pequeños a rangos pequeños; podemos usar `desc(x)` para invertir la relación (valores más grandes a rangos más pequeños)\n\nSi utilizamos el mismo nombre de una variable incluída dentro de la tabla de datos, estaremos sobrescribiendola (se usa cuando transformamos una variable, por ejemplo: le cambiamos su tipo de `character` a `factor`). Para que la variable sea nueva debe nombrarse con un nombre que no exista previamente dentro de la tabla de datos.\n\n### Funciones condicionales\n\nDentro un `mutate()`, algunas veces vamos a necesitar agrupar, agregar o discretizar variables continuas donde generemos variables dicotómicas o politómicas.\n\nEstas funciones que llamaremos \"condicionales\", dado que utilizan condiciones para decidir que valor tomar, no se limitan a la tarea de construir agrupamientos de variables cuantitativas sino que sirven para cualquier situación donde a partir de una o más condiciones se produzcan una o más valores como respuesta.\n\n#### Condicional simple - función **if_else()**\n\nPara salidas dicotómicas tenemos la función condicional `if_else()` derivada de la simplificación del **IF condicional** que existe en todos los lenguajes de programación.\n\nSupongamos que creamos una nueva variable dentro del dataframe **datos** que se llama **_variable_nueva_** de tipo cualitativa y queremos que la misma tome valores a partir del cumplimiento de una condición de una variable cuantitativa existente denominada **var1**. \n\nSi los valores de **var1** son mayores a 10, entonces **variable_nueva**, tomará el valor \"mayor a 10\", en caso contrario, tomará el valor \"menor o igual a 10\"\n\n```{r, eval=F}\ndatos <- datos |> \n  mutate(variable_nueva = if_else(condition = var1 > 10, \n                                  true = \"mayor a 10\", \n                                  false = \"menor o igual a 10\"))\n```\n\n`if_else()` tiene tres argumentos obligatorios, el primero siempre es una condición, el segundo y el tercero son los valores que tomará la nueva variable si esa condición se cumple o no se cumple. \n\nHabitualmente decimos que en este proceso dicotomizamos una variable, dado que el resultado posible consta siempre de 2 valores.\n\nLos valores de salida de esta función pueden ser de variado tipo (caracter, numerico o logico) aunque si estamos discretizando una variable cuantitativa generalmente construimos una variable resultado cualitativa ordinal. Es común que esta variable salida sea tipo `character` (observar que las nuevas categorías van encerradas entre comillas).\n\nAhora bien, al ser ordinal estas categorías de la variable_nueva deben \"ordenarse\" en la forma de los valores de la variable, pero el lenguaje R no sabe con que estamos trabajando y respeta siempre el ordenamiento alfanumérico. Por lo tanto, en este ejemplo las categorías se van a estar ordenando al reves del orden numérico natural (de menor a mayor).\n\n*\"mayor a 10\"* se ordena alfabéticamente antes de *\"menor o igual a 10\"*, porque luego del empate de las letras `m`, le siguen la `a` en el primer caso y la `e` en el segundo.\n\nPara ordenar estas categorías debemos transformar la variable de caracter a factor. Esto se puede hacer en un solo paso dentro del mutate:\n\n```{r, eval=F}\ndatos <- datos |> \n  mutate(variable_nueva = if_else(condition = var1 > 10, \n                                  true = \"mayor a 10\", \n                                   false = \"menor o igual a 10\"),\n         variable_nueva = factor(variable_nueva, \n                                 levels = c(\"menor o igual a 10\",\n                                            \"mayor a 10\")))\n```\n\nOtra forma más artesanal, igualmente válido, es \"forzar\" el ordenamiento con las categorías así:\n\n```{r, eval=F}\ndatos <- datos |> \n  mutate(variable_nueva = if_else(condition = var1 > 10, \n                                  true = \"2.mayor a 10\", \n                                  false = \"1.menor o igual a 10\"))\n```\n\nAquí agregamos números iniciales a las etiquetas de las categorías para darle el orden que deseamos, sin necesidad de convertir a factor.\n\n#### Condicional multiple \n\nEn salidas politómicas a partir de variables cuantitativas tenemos varias opciones dependiendo de si los intervalos de clase a construir son regulares o irregulares.\n\n#### Función **cut_interval()**\n\n**tidyverse** ofrece la función `cut_interval()` para la creación de intervalos regulares.\n\nEs una adptación de la función `cut()` de R base para tidy data y sus argumentos son similares.\n\n```{r, eval=F}\ndatos <- datos |> \n  mutate(grupo_var = cut_interval(x = var1, \n                                  length = 10,\n                                  right = T,\n                                  labels = T,\n                                  ordered_result = F))\n```\n\nLos argumentos obligatorios y opcionales de la función `cut()` son:\n\n- **x**: [obligatorio] El conjunto de datos numéricos de entrada (variable cuantitativa continua)\n\n- **length**: [obligatorio] la longitud de cada intervalo regular\n\n- **right**: [opcional] Indica si los intervalos son cerrados a la derecha o viceversa. Por defecto vale TRUE (cerrados a derecha)\n\n- **labels**: [opcional] Etiquetas de los intervalos automáticas o numéricas. Valor predeterminado TRUE (intervalos matemáticos)\n\n- **ordered_result**: [opcional] - determina si el resultado es un factor ordenado. Por defecto vale FALSE (la salida es tipo caracter)\n\nLos argumentos opcionales no son necesarios definirlos siempre y cuando los valores por defecto son los que sirven para la tarea.\n\n\n#### Función **case_when()**\n\nCuando las condiciones no son simples, es decir, el resultado no es dicotómico y además los intervalos son irregulares, utilizamos la función `case_when()` que es una vectorización de la función `if_else()`.\n\nSupongamos que no queremos agrupar la variable en dos valores, sino en 3 grupos irregulares.\n\nEsquema básico de funcionamiento:\n\n```{r, eval=F}\n# var1 es una variable cuantitativa de números enteros \n\ndatos <- datos |> \n  mutate(grupo_var = case_when( \n    var1 >= 0 & var1 < 25  ~  \"Grupo1\", \n    var1 > 24 & var1 < 65  ~ \t\"Grupo 2\", \n    var1 >= 65             ~ \t\"Grupo 3\"))\n```\n\nExiste una condición por cada grupo creado, como si fuese un `if_else()` donde el valor declarado siempre es el verdadero. Se utilizan operadores de comparación como mayor ( > ), menor ( < ) y/o igual ( = ) y conectores lógicos como & ( AND ). En cada línea va una virgulilla similar a la usada en la sintaxis formula ( ~ ) y luego la etiqueta que tomarán las observaciones que cumplan con esa condición en la nueva variable (grupo_var).\n\nEsta evaluación es secuencial y su funcionamiento provoca que el usuario del lenguaje tenga el control de lo que esta sucediendo, por lo que cualquier mala definición de las condiciones puede provocar resultados incorrectos.\n\nSi incorporamos el argumento **.default** podemos indicar que valor toma si no se cumple ninguna de las condiciones anteriores.\n\nPor ejemplo, podríamos tener algun valor perdido (NA) en `var1` y queremos que la variable `grupo_var` etiquete esos valores perdidos como \"Sin dato\":\n\n```{r, eval=F}\n# var1 es una variable cuantitativa de números enteros con algun valor NA\n\ndatos <- datos |> \n  mutate(grupo_var = case_when( \n\t\tvar1 >= 0 & var1 < 25  ~  \"Grupo1\", \n\t\tvar1 > 24 & var1 < 65  ~ \t\"Grupo 2\", \n\t\tvar1 >= 65             ~ \t\"Grupo 3\",\n\t\t.default = \"Sin dato\"))\n```\n\nLas salidas son de tipo **_carácter_** (chr) y debemos manejar el ordenamiento de las etiquetas como vimos anteriormente, por medio de factores o comenzando con caracteres ordenados alfabeticamente.\n\nPara simplificar el trabajo de estos intervalos de clase irregulares y no provocar errores en la confección de las condiciones, tidyverse tiene a la función `between()`.\n\n#### Intervalos - función **between()**\n\nBáicamente opera como un atajo para condiciones de intervalos. Define dentro de los argumentos los límites inferior y superior de un intervalo y se utiliza dentro de una función de condición tipo `if_else()` o `case_when()`. \n\nAplicado sobre el ejemplo anterior se vería así:\n\n```{r, eval=F}\n# var1 es una variable cuantitativa de números enteros con algun valor NA\n\ndatos <- datos |> \n  mutate(grupo_var = case_when( \n    between(var1, 0, 24)   ~  \"Grupo1\", \n\t\tbetween(var1, 25, 64)  ~ \t\"Grupo 2\", \n\t\tbetween(var1, 65, Inf) ~ \t\"Grupo 3\",\n\t\t.default = \"Sin dato\"))\n```\n\nLos valores declarados como límites quedan incluídos siempre dentro del intervalo (son cerrados ambos). También podemos utilizar valores reservados como `Inf` o `-Inf` cuando desconocemos con que valor máximo o mínimo nos vamos a encontrar en la variable cuantitativa original.\n\n#### Ejemplos con variable edad\n\nTomemos un caso clásico como la variable edad medida en años, variable que generalmente tenemos en toda tabla de datos vinculada a personas. En este ejemplo la variable tiene 106 observaciones.\n\n```{r, echo=F, message=F, warning=F}\ndatos <- read_csv2(\"datos/edad.txt\", locale = locale(encoding = \"ISO-8859-1\"))\n\ndatos <- datos |> mutate(fecha_nacimiento = dmy(fecha_nacimiento),\n                fecha_test = dmy(fecha_test),\n                edad = round(as.duration(fecha_test - fecha_nacimiento) / dyears(1))) |> select(edad)\n\n```\n\nUna posibilidad es dicotomizarla usando el valor de la mediana que divide 2 dos partes toda la distribución.\n\n```{r}\n\ndatos |> \n  summarise(mediana = median(edad))\n\n```\nAplicando el valor 56 dentro de un if_else podriamos hacer:\n\n```{r}\ndatos <- datos |> \n  mutate(grupo_edad1 = if_else(condition = edad > 56, \n                                  true = \"mayor a la mediana\", \n                                  false = \"menor o igual a la mediana\"))\n\ndatos |> \n  count(grupo_edad1)\n```\n\nObservamos en el conteo que `grupo_edad1` se construyó adecuadamente pero el orden de los niveles no es correcto si queremos que siga el ordenamiento natural de edad (de menor a mayor).\n\nUna de las formas que vimos es convertir a factor:\n\n```{r}\ndatos <- datos |> \n  mutate(grupo_edad1 = if_else(condition = edad > 56, \n                                  true = \"mayor a la mediana\", \n                                  false = \"menor o igual a la mediana\"),\n         grupo_edad1 = factor(grupo_edad1, \n                                 levels = c(\"menor o igual a la mediana\",\n                                            \"mayor a la mediana\")))\n\ndatos |> \n  count(grupo_edad1)\n```\n\nVemos que en el conteo el formato de la variable ya no es `chr` sino `fct` y el orden de las etiquetas siguen la forma *\"menor a mayor\"*.\n\nOtra forma es:\n\n```{r}\ndatos <- datos |> \n  mutate(grupo_edad1 = if_else(condition = edad > 56, \n                                  true = \"2.mayor a la mediana\", \n                                  false = \"1.menor o igual a la mediana\"))\n\ndatos |> \n  count(grupo_edad1)\n```\n\nSi en cambio necesitamos que los grupos sean mas de dos y que estos intervalos de clase sean regulares, podemos usar `cut_interval`\n\n```{r}\ndatos <- datos |> \n  mutate(grupo_edad2 = cut_interval(x = edad, \n                                    length = 10))\n\ndatos |> \n  count(grupo_edad2)\n```\nLa salida muestra 8 grupos etarios con etiquetas ordenadas con notación matemática, donde un corchete indica que el límite del intervalo es cerrado, es decir contiene el valor y un paréntesis es abierto y no lo hace.Así es que el primer grupo va de 0 a 10 años y el segundo de 11 a 20.\n\nEstos sucede así porque en forma predeterminada el argumento **right** está en `TRUE`. Veamos que pasa si lo cambiamos a `FALSE`:\n\n```{r}\ndatos <- datos |> \n  mutate(grupo_edad2 = cut_interval(x = edad, \n                                    length = 10,\n                                    right = F))\n\ndatos |> \n  count(grupo_edad2)\n```\nEn esta salida el primer grupo va de 0 a 9 y el segundo de 10 a 19.\n\nHasta ahora la variable grupo_edad2 es de tipo caracter, pero si deseamos que la salida sea factor podemos incorporar el argumento **ordered_result** en `TRUE`.\n\n```{r}\ndatos <- datos |> \n  mutate(grupo_edad2 = cut_interval(x = edad, \n                                    length = 10,\n                                    ordered_result = T))\n\ndatos |> \n  count(grupo_edad2)\n```\nConstruimos así una variable factor ordenada <ord>.\n\nPor último, con el argumento **labels** en `FALSE` hacemos que las etiquetas de los 8 grupos sean numéricas.\n\n```{r}\ndatos <- datos |> \n  mutate(grupo_edad2 = cut_interval(x = edad, \n                                    length = 10,\n                                    labels = F))\n\ndatos |> \n  count(grupo_edad2)\n```\n\nOtro ejemplo, podría ser aplicando `case_when()` donde discretizamos la edad en 4 grupos irregulares, forzando sus etiquetas para lograr el orden adecuado.\n\n\n```{r}\ndatos <- datos |> \n  mutate(grupo3 = case_when(\n    edad < 13              ~ \"1.Niño\",\n    edad > 12 & edad < 26  ~ \"2.Adolescente\",\n    edad > 25 & edad < 65  ~ \"3.Adulto_joven\",\n    edad > 64              ~ \"4.Adulto_mayor\"\n  ))\n\ndatos |> \n  count(grupo3)   \n```\n\nSi no hubiesemos etiquetado con los numeros por delante el orden alfabético hacía que Niño fuese a parar al final del conteo.\n\nDe la misma forma pero más sencillo y controlado es:\n\n```{r}\ndatos <- datos |> \n  mutate(grupo3 = case_when(\n    between(edad, 0, 12)   ~ \"1.Niño\",\n    between(edad, 13, 25)  ~ \"2.Adolescente\",\n    between(edad, 26, 64)  ~ \"3.Adulto_joven\",\n    between(edad, 65, Inf) ~ \"4.Adulto_mayor\"\n  ))\n\ndatos |> \n  count(grupo3)  \n```\n\n\n\n### Función **summarise()**\n\nLa función `summarise()` (se puede escribir también `summarize()`) resume variables de un conjunto de datos.\n\n```{r, echo=F, message=F, warning=F}\ndatos <- read_csv(\"datos/noti-vih.csv\")\n```\n\n\n```{r}\ndatos |> \n  summarise(promedio_casos = mean(casos), \n            casos_totales = sum(casos))\n```\n\nSu uso es muy interesante cuando la combinamos con `group_by()` (función que detallaremos luego). Esta situación permite estratificar los resultados por grupos específicos.\n\nPor ejemplo, podemos agrupar el por año y simultáneamente aplicar el mismo `summarise()` anterior.\n\n```{r}\ndatos |>  \n  group_by(año) |>  \n  summarise(promedio_casos = mean(casos), \n            casos_totales = sum(casos))\n```\n\nEl resultado es una tabla con dos filas, una para cada grupo (año 2015 y año 2016) con los valores promedio y casos totales respectivos.\n\nAlgunas de las funciones del R base que se pueden utilizar dentro de los argumentos de esta función son:\n\n-   `min()` mínimo\n-   `max()` máximo\n-   `mean()` media\n-   `median()` mediana\n-   `var()` varianza\n-   `sd()` desvío\n-   `sum()` sumatoria\n\nOtras funciones que se pueden incorporar las provee el mismo paquete **dplyr**, por ejemplo:\n\n-   `first()` primer valor en el vector\n-   `last()` último valor en el vector\n-   `n()` número de valores en el vector\n-   `n_distinct()` números de valores distintos en el vector\n\nDesde la versión 1.4.0 de **dplyr** la función `summarise()` incorpora un nuevo argumento para agrupamientos temporales. El argumento `.by =` trabaja igual que un `group_by()` previo pero lo hace solo para realizar el calculo definido dentro del resumen evitando que el dataframe de salida mantenga el agrupamiento.\n\nLa estructura básica de la función actualizada es:\n\n```{r}\n#| eval: false\n\ndatos |> \n  summarise(\n    var_resumen = funcion(var),\n    .by = var_grupo\n  )\n```\n\nAplicada en el ejemplo previo:\n\n```{r}\ndatos |>  \n  summarise(promedio_casos = mean(casos), \n            casos_totales = sum(casos),\n            .by = año)\n```\n\n### Función **group_by()**\n\nDecíamos recién que la función `group_by()` es útil cuando trabaja conjuntamente con `summarise()` dado que agrupa un conjunto de filas seleccionado en un conjunto de filas de resumen de acuerdo con los valores de una o más columnas o expresiones.\n\nPara ejemplificar su trabajo asociado obtendremos una nueva tabla con el cálculo de las tasas crudas para cada jurisdicción por año (similar al ejemplo de la aplicación de `mutate()`:\n\n```{r, message=F}\ndatos |> \n  group_by(jurisdiccion, año) |>  \n  summarise(tasa = casos/pob*100000)\n```\n\nEn la mayoría de estos ejemplos la salida es directa, es decir no construimos nuevos objetos contenedores de los datos producidos y vemos los resultados en consola o en el visualizador de RStudio. Pero en muchas situaciones vamos a necesitar generar nuevos conjunto de datos con las transformaciones realizadas. Si en alguna de estas ocasiones llegamos a agrupar datos mediante `group_by()` y posteriormente necesitamos volver a tener la información desagrupada existe una función vinculada denominada `ungroup()` que vamos a necesitar aplicar o bien si no se desea tener el agrupamiento de forma fija se puede usar el argumento `.by =` del `summarise()` como mostramos anteriormente.\n\n### Combinaciones\n\nEn los ejemplos anteriores vimos como se van integrando alguna de las funciones mediante el uso de la tubería **%\\>%** o **\\|\\>**. La idea detrás de la búsqueda gramatical del paquete es poder enlazar las acciones para construir oraciones más complejas.\n\nUn ejemplo que podría integrar gran parte de los visto sería:\n\nObtener una nueva tabla con las tasas crudas de casos notificados de VIH, por año y jurisdicción, mayores a 20 x 100000 habitantes ordenadas de mayor a menor.\n\n```{r, message=F}\ndatos |>                                   # siempre partimos de los datos\n  group_by(año, jurisdiccion) |>           # agrupamos\n  summarise(tasa = casos/pob*100000) |>    # resumimos\n  filter(tasa > 20) |>                     # filtramos\n  arrange(desc(tasa))                       # ordenamos   \n```\n\nObservemos que una buena manera de construir el código es respetar un salto de línea para cada término de la oración para una lectura más clara.\n\nDemostramos así la potencialidad que tienen estas funciones combinadas donde en esta situación integramos las funciones `group_by()`, `summarise()` , `filter()` y `arrange()` en una misma operación.\n\n### Función **count()**\n\nEsta última función que presentamos permite contar rápidamente los valores únicos de una o más variables.\n\nProduce fácilmente tablas de frecuencias absolutas que luego posibilitan construir frecuencias relativas.\n\nLa aplicamos sobre la variable **jurisdiccion** de *datos*\n\n```{r}\ndatos |> \n  count(jurisdiccion)\n```\n\nTiene un par de argumentos opcionales:\n\n-   **name**: es el nombre de la columna con el conteo. Por defecto se llama **n**\n-   **sort**: ordena la tabla de frecuencia de mayor a menor\n-   **wt**: se puede opcionalmente incorporar una variable con la ponderación (factor de expansión) para el calculo de la frecuencia.\n\n## Gráficos estadísticos con **ggplot2**\n\n**ggplot2** es un paquete que se autodefine como librería para *“crear elegantes visualizaciones de datos usando una gramática de gráficos”*\n\nPropone una forma intuitiva de construir gráficos basada en [The Grammar of Graphics](https://www.springer.com/gp/book/9780387245447), a partir de utilizar capas y un sistema apoyado en tres componentes básicos:\n\n-   datos\n-   coordenadas\n-   objetos geométricos\n\nLa estructura para construir un gráfico es la siguiente:\n\n```{r,echo=F,  fig.align='center', out.width = \"40%\"}\nknitr::include_graphics(\"img/03/estructura_ggplot.JPG\")\n```\n\n### Anatomía de gráficos con ggplot2\n\nEl paquete se basa en una gramática de gráficos que puede ser entendida a partir de conocer sus componentes:\n\n```{r,echo=F,  fig.align='center', out.width = \"40%\"}\nknitr::include_graphics(\"img/03/ggplot1.JPG\")\n```\n\n-   **data** es aquél conjunto de datos que vamos a graficar, con toda la información pertinente para realizar el gráfico.\n-   **aes** reducción de aesthetic mapping o mapeo estético en el que se puede declarar todo lo que puede ser visible de un gráfico.\n-   **geoms** son representaciones para dibujar gráficos (puntos, líneas, cajas, entre otros).\n-   **stats** son aquellas transformaciones estadísticas que le hacemos a los datos. Nos ayudan a hacer un resumen del conjunto de datos para visualizar mejor (por ejemplo, la media o la mediana como estadísticas de tendencia central).\n-   **scales** facilitan colorear (o escalar) los datos según distintas variables. Dibujan los ejes y las leyendas.\n-   **coordinate Systems** es el sistema de coordenadas para el mapeo del gráfico en un plano bidimensional.\n-   **facets** nos permiten partir el conjunto de datos según factores para graficar en viñetas separadas creando matrices gráficas.\n-   **themes** son conjuntos de características gráficas que permiten controlar la apariencia general de todos los elementos que no son datos (por ejemplo, el color del fondo o el tipo de fuente).\n\nAntes de comenzar a explicar cada componente vamos a leer un conjunto de datos que nos permita mostrar los ejemplos gráficos.\n\n```{r, message=FALSE, warning=FALSE}\nlibrary(tidyverse)\n\nfacultad <- read_csv(\"datos/facultad.csv\") # lectura\n\nhead(facultad) # mostramos las 6 primeras observaciones\n```\n\nEl archivo leído se llama *facultad.csv* y contiene información de salud sobre ingresantes a una facultad tales como sexo, edad, talla y peso, entre otras. (son datos ficticios con fines docentes).\n\n### Mapeo estético (**aesthetic mapping**) y objetos geométricos (**geom**)\n\nDecíamos que `aes()` hace referencia al contenido estético del gráfico. Es decir, la función le brinda indicios a **ggplot2** sobre cómo dibujar los distintas líneas, formas, colores y tamaños.\n\nEs importante notar que `aes()` crea una nueva capa en relación a las variables y agrega leyendas a los gráficos. Al incorporar `aes()` al llamado de `ggplot()` estamos compartiendo la información estética en todas las capas. Si deseamos que esa información sólo esté en una de las capas, debemos usar `aes()` en la capa correspondiente.\n\nVeamos como funciona y sus diferencias.\n\n```{r,eval=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO)) # solo la capa estética aes()\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO))  +\n  theme(text = element_text(size = 100))\n```\n\nEste gráfico solo contiene los ejes que especificamos (PESO y TALLA) pero no contiene los datos. Si deseamos incorporarlos agregamos una capa de puntos con `geom_point()` a través del símbolo **+**.\n\n```{r,eval=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO))  + \n  geom_point()                    # agregamos la capa geométrica de puntos\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO))   + \n  geom_point() +                   # agregamos la capa geométrica de puntos\n  theme(text = element_text(size = 100))\n```\n\nPodemos diferenciar los puntos según se traten de ingresantes mujeres y hombres, asociando el argumento **color** dentro de `aes()` con la variable SEXO.\n\n```{r,eval=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n  geom_point()\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n  geom_point()         +     \n  theme(text = element_text(size = 100))\n```\n\nEstos gráficos también posibilitan el agregado de otra capa geométrica, por ejemplo rectas de regresión para cada grupo según sexo.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) + \n  geom_point() + \n  geom_smooth(method = \"lm\")            # agregamos una segunda capa geométrica \n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n  geom_point()  + \n  geom_smooth(method = \"lm\") +            \n  theme(text = element_text(size = 100))\n```\n\nEsta función `geom_smooth()` posee distintos métodos y en este ejemplo utilizamos el de regresión lineal entre talla y peso junto a sus intervalos de confianza.\n\nA continuación vamos a ver que diferencias existen cuando `aes()` se encuentra dentro del `ggplot()` y cuando se ubica en otras capas de funciones como en `geom_point()`\n\nDecíamos anteriormente que al incorporar `aes()` al llamado de `ggplot()` estamos compartiendo la información estética en todas las capas.\n\nEntonces si quitamos `aes()` de allí y lo ubicamos en una capa única, esta configuración deja de afectar al conjunto del gráfico.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO)) + \n  geom_point(aes(color = SEXO)) + # color esta definido en el aes() \n                                  # de la capa geométrica\n  geom_smooth(method = \"lm\")\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO)) +\n  geom_point(aes(color = SEXO))  + \n  geom_smooth(method = \"lm\") +            \n  theme(text = element_text(size = 100))\n```\n\nEn este ejemplo, `aes()` para el color solo se ubica dentro de `geom_point()` y por lo tanto dibuja los puntos con sus respectivos colores, pero no afecta a la capa de `geom_smooth()` produciendo solo una línea de regresión para el conjunto de puntos.\n\nEs decir que `geom_smooth()` no recibe la orden de agrupar según SEXO, a raíz de no haber definido color dentro del `aes()` general.\n\nEste comportamiento nos permite gran versatilidad en los gráficos que realicemos.\n\nAlgunas otras funciones de **geom\\_** son:\n\n`geom_line()`, para líneas\n\n`geom_boxplot()`, para boxplot\n\n`geom_histogram()` para histogramas\n\n`geom_density()` para curvas de densidad\n\n`geom_bar()` para barras\n\nEstas funciones geométricas aplicadas sobre los mismos datos definen el tipo de gráfico.\n\nPara ejemplificar, podemos gráficar dos variables como SEXO y TALLA generando una base a la que sumaremos capas diferentes de `geom()`:\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, color = SEXO)) + \n  geom_point()                # capa geométrica de puntos\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, color = SEXO)) + \n  geom_point() +            \n  theme(text = element_text(size = 100))\n```\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, color = SEXO)) + \n  geom_boxplot()            # capa geométrica de boxplot\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, color = SEXO)) + \n  geom_boxplot() +            \n  theme(text = element_text(size = 100))\n```\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, color = SEXO)) + \n  geom_jitter()               # capa geométrica jitter (entramado de puntos)\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, color = SEXO)) + \n  geom_jitter()  +            \n  theme(text = element_text(size = 100))\n```\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_violin()            # capa geométrica de violin\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_violin() +            \n  theme(text = element_text(size = 100))\n```\n\nObservemos que en este último gráfico cambiamos, dentro de `aes()`, color por fill. Mientras que **color** define el color del contorno del polígono, la línea de una recta o curva y los puntos, **fill** define el relleno de los objetos como es el caso de los violines construidos o cualquier elemento geométrico de polígono.\n\n### Escalas (**scale**)\n\nLas configuraciones que se pueden realizar con **scale** son numerosas. Entre ellas encontramos cambios de color de contorno y relleno, cambios de posición, de tamaño y tipo de línea.\n\nEl argumento para modificar valores de escala comienzan siempre con con `scale_` (por ejemplo scale_fill\\_ )\n\nSigamos trabajando con el conjunto de datos leído para mostrar ejemplos de gráficos donde agregamos capas de escala para color de relleno. ( `scale_fill_brewer()` )\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_brewer(palette = \"Oranges\")   # paleta de los naranjas\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_brewer(palette = \"Oranges\") +           \n  theme(text = element_text(size = 100))\n```\n\nEn este ejemplo aplicamos una capa `scale_fill_brewer()` con una paleta de colores (Oranges) que se vincula con el argumento fill de `aes()` y definen los colores del boxplot.\n\nLo mismo hacemos para una gama de grises mediante `scale_fill_grey()`\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_grey(start = 0.4, end = 0.8)   # paleta de los grises\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_grey(start = 0.4, end = 0.8)  +           \n  theme(text = element_text(size = 100))\n```\n\nOtro uso de escalas, esta vez aplicado a los ejes, es la inversión del eje x.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n  geom_point() +\n  scale_x_reverse()     # escala inversa de x\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n  geom_point() +\n  scale_x_reverse() +           \n  theme(text = element_text(size = 100))\n```\n\nComo se observa en el gráfico la inclusión de `scale_x_reverse()` provoca que la escala x se invierta, quedando la TALLA ordenada de mayor a menor.\n\nPor último, otro ejemplo interesante es aplicado a escalas de etiquetado de ejes. Volvamos al ejemplo reciente de boxplot con relleno en escala de grises, su eje y se dibuja predeterminado desde 130 a casi 200 cms con cortes cada 5 cms y etiquetas cada 10 cms.\n\nCon escalas continuas manuales de la forma `scale_*_continuos()` podemos personalizar el eje y.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_grey(start = 0.4, end = 0.8)   +\n  scale_y_continuous(breaks = seq(130,200,2))\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_grey(start = 0.4, end = 0.8)   +\n  scale_y_continuous(breaks = seq(130,200,2)) +           \n  theme(text = element_text(size = 100))\n```\n\nEn este caso particular definimos un eje y con etiquetas de 2 en 2, mediante la línea `scale_y_continuous(breaks = seq(130,200,2))`\n\n### Transformaciones estadísticas (**stat**)\n\nAlgunos gráficos no requieren de transformaciones estadísticas, en cambio, otros como boxplot, histogramas, etc poseen valores predeterminados de **stat** que pueden ser modificados.\n\nEstos valores se encuentra en forma de argumentos dentro de la función geométrica, por ejemplo para los histograma el argumento **bins** define la cantidad de intervalos de clase.\n\n```{r,eval=FALSE}\nfacultad |> \n  ggplot(aes(EDAD)) +\n    geom_histogram(bins = nclass.Sturges(facultad$EDAD), fill = \"Blue\")\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(EDAD)) +\n    geom_histogram(bins = nclass.Sturges(facultad$EDAD), fill = \"Blue\") +           \n  theme(text = element_text(size = 100))\n```\n\nVemos que el gráfico se construyó utilizando la *regla de Sturges* para determinar la cantidad de intervalos de clase para la variable EDAD. (función `nclass.Sturges()`)\n\nOtras transformaciones estadísticas se incorporan como capas independientes, por ejemplo si queremos agregar los valores de media a los boxplot de talla según sexo construidos anteriormente.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_brewer(palette = \"Greens\") +\n  stat_summary(fun = mean, color = \"darkred\", geom = \"point\", \n               shape = 18, size = 3)\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_brewer(palette = \"Greens\") +\n  stat_summary(fun = mean, color = \"darkred\", geom = \"point\", \n               shape = 18, size = 3) +           \n  theme(text = element_text(size = 100))\n```\n\nAquí la capa completa surge a partir de la función `stat_summary()`, con argumentos que indican que se aplique la función `mean`. Incluye también la definición del objeto geométrico (point) que representa el valor de media (color, forma y tamaño)\n\n### Facetado (**facet**)\n\nCon `facet` es posible separar gráficos en distintas ventanas o viñetas, creando matrices de gráficos separados por grupos de datos, a partir de la estratificación, en función de diferentes categorías de una variable cualitativa.\n\nEste comportamiento es sumamente útil cuando tenemos más de una variable categórica o cuando deseamos utilizar color para simbolizar otra variable.\n\nggplot ofrece dos posibilidades de hacer el facetado:\n\n-   `facet_wrap()` – define subgrupos a partir de los niveles de una sola variable categórica\n\n-   `facet_grid()` – define subgrupos a partir del cruce de dos variables de categóricas.\n\nUna aplicación de `facet_wrap()` podría ser que el primer gráfico que hicimos de dispersión de puntos con las variables TALLA y PESO se visualice en dos gráficos distintos según cada categoría de SEXO.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n     geom_point() +\n     facet_wrap(~SEXO)\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n     geom_point() +\n     facet_wrap(~SEXO) +           \n  theme(text = element_text(size = 80))\n```\n\nUsamos `facet_grid()` para crear una matriz producto del cruce de las variables FUMA y SEXO.Dentro de la cuadrícula graficaremos histogramas de la variable PESO coloreados por SEXO.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(PESO, fill = SEXO)) +\n     geom_histogram(bins = nclass.Sturges(facultad$PESO)) +\n     scale_fill_brewer(palette = \"Set1\") +\n     facet_grid(SEXO ~ FUMA)\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(PESO, fill = SEXO)) +\n     geom_histogram(bins = nclass.Sturges(facultad$PESO)) +\n     scale_fill_brewer(palette = \"Set1\") +\n     facet_grid(SEXO ~ FUMA) +           \n  theme(text = element_text(size = 80))\n```\n\nSi observamos las 4 líneas que integran todas las capas del código de ggplot notaremos que estamos integrando varias de las funciones que fuimos mostrando.\n\nSe hace imposible generar todas combinaciones posibles dada la variedad y extensión de argumentos que posee el paquete. De todas formas, el objetivo de este material es entender la base de funcionamiento, es decir la estructura \"gramatical\" que proponen sus autores.\n\n### Sistema de coordenadas (**Coordinate Systems**)\n\nEn algunas ocasiones puede que necesitemos introducir modificaciones en el sistema de coordinadas predeterminado.\n\nSobre las coordenadas cartesianas iniciales se puede invertir la orientación para que, por ejemplo, las barras se dibujen horizontales.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip()   # invierte disposición de ejes\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip()  +           \n  theme(text = element_text(size = 100))\n```\n\n### Temas (**themes**)\n\nEl paquete ofrece un conjunto reducido de temas gráficos. El tema por defecto o inicial es `theme_gray()` pero se puede modificar a partir de agregar una capa de tema dentro de la estructura ggplot.\n\nA modo de ejemplo repetimos el último gráfico con el tema blanco y negro ( `theme_bw()` ):\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip() +\n     theme_bw()  # tema blanco y negro\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip() +\n     theme_bw()  +           \n  theme(text = element_text(size = 100))\n```\n\nOtro tema que podemos utilizar es `theme_dark()` que tiene un fondo gris oscuro.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip() +\n     theme_dark()\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip() +\n     theme_dark() +           \n  theme(text = element_text(size = 100))\n```\n\nEl siguiente cuadro muestra el nombre y presentación de los temas que contiene el paquete.\n\n```{r,echo=F,  fig.align='center', out.width = \"40%\"}\nknitr::include_graphics(\"img/03/temas_ggplot.jpg\")\n```\n\nContinuando con cuestiones estéticas en otra capa se pueden definir etiquetas, como título, subtítulo y nombres de ejes.\n\nLa forma de la función con argumentos básicos es `labs( x = “Etiqueta X\", y = “Etiqueta Y\", title =“Título del gráfico\", subtitle = \"Subtítulo del gráfico\")`\n\nAdemás se utiliza la función `theme()` para configurar el tipo de fuente y tamaño, entre otras opciones posibles.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip() +\n     labs(y = \"Cantidad\", title = \"Distribución de Sexo\") +\n     theme(plot.title=element_text(face=\"italic\", size=16)) \n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip() +\n     labs(y = \"Cantidad\", title = \"Distribución de Sexo\") +           \n  theme(text = element_text(size = 100),\n        plot.title=element_text(face=\"italic\", size=160))\n```\n\n### Paquete **esquisse**\n\n**Esquisse** es un paquete que contiene una aplicación asistente para crear gráficos **ggplot2** de forma interactiva. Basta con arrastrar y soltar las variables para asignarlas a diferentes estéticas.\n\nPodemos visualizar rápidamente los datos de acuerdo con su tipo, exportarlos en varios formatos y recuperar el código para reproducir el gráfico.\n\nEl paquete se instala mediante el menú Packages de RStudio o ejecutando:\n\n```{r, eval=F}\ninstall.packages(\"esquisse\")\n```\n\nLuego se puede acceder a la aplicación por medio del acceso Addins\n\n```{r,echo=F,  fig.align='center', out.width = \"70%\"}\nknitr::include_graphics(\"img/03/esquisse.PNG\")\n```\n\no ejecutando en consola `esquisser()`\n\nTambién se puede agregar el nombre de la tabla de datos dentro de los paréntesis\n\n```{r, eval=F}\nesquisser(datos)\n```\n\nPara más información consultar en la [viñeta](https://cran.r-project.org/web/packages/esquisse/vignettes/get-started.html) del paquete en CRAN.\n\n## Uniones en datos relacionales\n\nExisten situaciones donde debemos analizar datos que se encuentran en diferentes tablas.\n\nCon el fin de responder a nuestras preguntas de interés en ocasiones deberemos unirlas previamente.\n\nDe manera general, se le llama ***datos relacionales*** a esas múltiples tablas de datos que provienen muchas veces de sistemas de bases de datos construidas bajo el modelo relacional o bien cuando las tablas de datos tienen fuentes distintas pero comparten alguna variable común que permita \"conectarlas\".\n\nUn ejemplo recurrente sucede cuando necesitamos calcular la tasa de algún evento de salud y tenemos en una tabla el conteo (dato agregado) del evento (numerador) y en otra el conteo de la población en riesgo (denominador). \n\n### Tipos de operaciones\n\nPara trabajar con datos relacionales necesitamos de *funciones-verbos* que vinculen pares de tablas.\n\nLas tres familias de funciones del paquete **dplyr** diseñadas para trabajar con datos relacionales son:\n\n-   **Uniones de transformación** (del inglés *mutating joins*), agregan nuevas variables a una tabla a partir de observaciones coincidentes de otra tabla.\n\n-   **Uniones de filtro** (del inglés *filtering joins*), filtran observaciones de una tabla en función de la coincidencia o no coincidencia de otra tabla.\n\n-   **Operaciones en filas y columnas**, sirven para unir tablas por columnas o por filas.\n\n### Claves\n\n-   Las variables usadas para conectar cada par de variables se llaman **claves** (del inglés *key*)\n\n-   Una clave es una variable (o un conjunto de variables) que identifican de manera *única* una observación.\n\nExisten dos tipos de claves:\n\n-   Una **clave primaria** identifica únicamente una observación en su propia tabla.\n\n-   Una **clave foránea** únicamente identifica una observación en otra tabla.\n\nUna vez que identificadas las claves primarias en las tablas, es una buena práctica verificar que identifican de forma **única cada observación**. Una forma de hacerlo es usar `count()` con las claves primarias y buscar las entradas con n mayor a uno:\n\n```{r}\n#| eval: false\n\ndatos |> \n  count(clave_primaria) |> \n  filter(n > 1)\n```\n\nLa salida debería mostrar que no hay ninguna observación que cumpla la condición de n > 1, es decir todas las observaciones tienen una sola clave primaria unívoca.\n\nEn ocasiones podemos tener claves primarias compuestas por más de una variable. Tendremos que utilizar entonces esta combinación de variables a la vez en las uniones que realicemos.\n\nOtra situación inversa es no tener ninguna variable como clave primaria, aunque sepamos que cada observación pertenece a una misma unidad de análisis pero de elementos (sujetos, etc) diferentes. Aquí se puede usar la función `row_number()` que numera en orden ascendente las observaciones de la tabla y almacena esta numeración en una variable, creando una **clave subrogada**.\n\n```{r}\n#| eval: false\n\ndatos <- datos |> \n  mutate(clave = row_number()) \n```\n\n\n### Uniones de transformación\n\nLa forma más simple de unión es la unión interior (del inglés inner join). Una unión interior une pares de observaciones siempre que sus claves sean iguales.\n\n**Unión interior**\n\nUna unión interior mantiene las observaciones que aparecen en ambas tablas. La estructura del código sirve de base para las demás uniones:\n\n\n```{r}\n#| eval: false\n\ndatos_x |> \n  inner_join(datos_y, by = \"variable_clave\") \n```\n\n\n![](img/03/inner-join.PNG){fig-align=\"center\" width=50%}\n\nLa propiedad más importante de una unión interior es que las filas no coincidentes no se incluyen en el resultado\n\n**Uniones exteriores**\n\nUna unión exterior mantiene las observaciones que aparecen en al menos una de las tablas.\n\n-   Una unión izquierda (left join) mantiene todas las observaciones en x.\n\n![](img/03/left.png){fig-align=\"center\" width=50%}\n\n-   Una unión derecha (right join) mantiene todas las observaciones en y.\n\n![](img/03/right.png){fig-align=\"center\" width=50%}\n\n-   Una unión completa (full join) mantiene todas las observaciones en x e y.\n\n![](img/03/full.png){fig-align=\"center\" width=50%}\n\nEstas uniones funcionan agregando una observación “virtual” adicional a cada tabla. Esta observación tiene una clave que siempre coincide (de no haber otras claves coincidentes) y un valor que se llena con **NA**.\n\nOtra forma de ilustrar diferentes tipos de uniones es mediante un diagrama de Venn.\n\n\n![](img/03/venn.PNG){fig-align=\"center\" width=50%}\n\nSin embargo, tiene una limitante importante: un diagrama de Venn no puede mostrar qué ocurre con las claves que no identifican de manera única una observación.\n\n### Claves duplicadas\n\nHasta ahora todas las situaciones han asumido que las claves son únicas. Pero esto no siempre es así.  \n\nExisten dos posibilidades habituales:\n\n- Una tabla tiene claves duplicadas producto de una relación uno a varios.\n\n![](img/03/dupli-key.PNG){fig-align=\"center\" width=50%}\n\n- Ambas tablas tienen claves duplicadas (producto de una relación real varios a varios o por algún \"error\")\n\n![](img/03/dupli-key2.PNG){fig-align=\"center\" width=50%}\n\nSiempre que unimos claves duplicadas, obtenemos todas las posibles combinaciones, es decir, el producto cartesiano\n\n### Variables claves\n\nLa forma común del argumento `by =` donde se define/n la/s variable/s clave/s es igualarlo al nombre la variable o variables concatenadas con `c()` que deberán tener el mismo nombre en las dos tablas a unir.\n\nOtra maneras de conectar las tablas sería:\n\n- Sin definir `by =` o bien `by = NULL`, que de forma predeterminada utiliza todas las variables que se llamen de la misma forma (respetando mayúsculas y minúsculas). Esta se denomina **unión natural**.\n\n- Utilizar la función `join_by()` en el argumento `by =` que nos da la posibilidad de declarar cuales son las variables de unión cuando estas tengan nombres distintos en cada tabla.\n\n```{r}\n#| eval: false\n\ndatos_x |> \n  inner_join(datos_y, \n             by = join_by(var_clave_x == var_clave_y)) \n```\n\nObserven que la igualdad de las variables claves de **x** e **y** es un operador de comaparación `==`\n\nEn caso que hubiese más de una variable clave de unión se puede hacer:\n\n```{r}\n#| eval: false\n\ndatos_x |> \n  inner_join(datos_y, \n             by = join_by(var1_clave_x == var1_clave_y,\n                          var2_clave_x == var2_clave_y,)) \n```\n\n### Uniones de filtro\n\nLa función `semi_join()` mantiene todas las observaciones de la tabla **x** donde la **_clave coincide_** con la clave de la tabla **y**\n\n![](img/03/semi.png){fig-align=\"center\" width=50%}\n\nPara hacer lo inverso, `anti_join()` descarta todas las observaciones de la tabla **x** donde la **_clave coincide_** con la clave de la tabla **y**\n\n![](img/03/anti.png){fig-align=\"center\" width=50%}\n\n\n### Unión por filas y por columnas\n\nEn algunas ocasiones necesitamos unir tablas que tienen formatos particulares por medio de filas o por medio de columnas.\n\nLas funciones de **dplyr** para esta tarea son:\n\n- **bind_rows()** Une una tabla debajo de otra. Aplica cuando tenemos la misma estructura en tabla de datos divida en varios archivos (por ejemplo, producto de carga simultánea de datos en diferentes computadoras con diferentes data-entry)\n\n- **bind_cols()** Une una tabla al lado de la otra. Es peligroso su uso si la confundimos con las uniones de transformación porque perdemos integridad de datos en las observaciones. Sirve sólo si el \"orden\" de las observaciones pueden garantizar la misma identidad de las partes a unir.\n\n\n\n\n\n\n","srcMarkdownNoYaml":"\n\n```{r, message=FALSE, echo=F}\nknitr::opts_chunk$set(comment=NA, dpi = 300)\n```\n\n![](img/03/tidyverse.gif){width=10% fig-align=\"center\"}\n\n```{r, echo=F, message=F, warning=F}\nlibrary(dlookr)\n```\n\n## Introducción\n\nTidyverse es el nombre que se ha dado al conjunto de paquetes desarrollados a partir de la inciativa de [Hadley Wickham](https://en.wikipedia.org/wiki/Hadley_Wickham) (jefe científico de Posit -antes RStudio-) y su equipo, para ciencia de datos con R.\n\nEstos paquetes están diseñados para funcionar juntos y comparten una misma filosofía, que se puede consultar en [The tidy tools manifesto](https://cran.r-project.org/web/packages/tidyverse/vignettes/manifesto.html).\n\nLos cuatro principios básicos en los que se basa son:\n\n-   Reutilizar las estructuras de datos\n-   Resolver problemas complejos combinando varias piezas sencillas\n-   Utilizar programación funcional\n-   Diseñado para humanos\n\nLos paquetes incluidos en el tidyverse tienen como objetivo cubrir todas las fases del análisis de datos dentro de R: importar datos, ponerlos en formato ordenado (tidy data), buscar relaciones entre ellos (mediante su transformación, visualización y creación de modelos) y comunicar los resultados.\n\nLa palabra \"tidy\" se puede traducir como \"ordenado\" y refiere a que los datos deben cumplir con una estructura determinada donde:\n\n-   Cada ***variable*** es una *columna* de la tabla de datos.\n-   Cada ***observación*** es una *fila* de la tabla de datos.\n-   Cada ***tabla*** responde a una *unidad de observación o análisis*.\n\n```{r,echo=F,  fig.align='center', out.width = \"60%\"}\nknitr::include_graphics(\"img/03/tidy.PNG\")\n```\n\nAdemás de los paquetes principales que realizan estas funciones, al instalar el tidyverse también se proporcionan otros que ayudan a trabajar con fechas, cadenas de caracteres o factores siguiendo los mismos principios.\n\nUna de las interesantes incorporaciones transversales en el ambiente tidyverse es el uso de tuberías (pipe en inglés).\n\nUna tubería conecta un trozo de código con otro mediante el conector `%>%` que surge del paquete **magrittr** que permite transformar llamadas de funciones anidadas (con muchos paréntesis) en una simple serie de operaciones que son más fáciles de escribir y comprender. Este aporte fue tan importante que el equipo de desarrolladores que mantiene el lenguaje R incorporó la idea a partir de la versión 4.1.0 de 2021, agregando la funcionalidad nativa con el operador `|>`.\n\n**Nota:** *durante el curso pueden llegar a coexistir ambas tuberías, dado que funcionan igual. De todas maneras, al utilizar versiones actualizadas del lenguaje preferimos utilizar la tubería nativa que es más eficiente que la propia del tidyverse.*\n\nLa idea de tubería responde al principio donde cada función es un paso y la forma de trabajar se puede ver en el siguiente esquema general:\n\n```{r,echo=F,  fig.align='center', out.width = \"40%\"}\nknitr::include_graphics(\"img/03/pipe.png\")\n```\n\n**Base gramatical**\n\nLa intención de los desarrolladores para este conjunto de paquetes es lograr incorporar una gramática a la sintaxis de las funciones y sus argumentos buscando un entendimiento semántico más claro.\n\nUna prueba de ello, es que la mayoría de las funciones son verbos que se entrelazan con objetos y argumentos que permiten construir *\"frases\"*.\n\n## El paquete de paquetes\n\nEl paquete tidyverse nucleo actual (versión 2.0.0) se puede descargar del repositorio oficial CRAN mediante menú **Packages** de **RStudio** o ejecutando en consola:\n\n```{r, eval=F}\ninstall.packages(\"tidyverse\")\n```\n\nSe activa, como cualquier otro paquete, mediante:\n\n```{r, warning=FALSE}\nlibrary(tidyverse)\n```\n\nObservamos que nos informa sobre la versión del paquete, el listado de paquetes que acabamos de activar sólo llamando a tidyverse y una serie de conflictos de nombres de funciones.\n\nEsto es muy habitual cuando activamos varios paquetes, dado que las funciones que se encuentran dentro de ellos pueden llamarse iguales.\n\nPor ejemplo, existe en el paquete base stats y en el paquete dplyr (que es parte de tidyverse) una función llamada `filter()`, por lo tanto al activar tidyverse nos informa de esta manera: **dplyr::filter() masks stats::filter()**\n\nEn este caso, cuando necesitemos asegurarnos que la función que deseamos ejecutar pertenece a determinado paquete, es recomendable escribirla de la siguiente forma:\n\n> nombre_paquete::nombre_función\n\n**stats::filter()** para la función **filter()** del paquete **stats**\n\n**dplyr::filter()** para la función **filter()** del paquete **dplyr**\n\nLos paquetes incluidos que se instalan en esta versión son 31:\n\n```{r}\ntidyverse_packages()\n```\n\nExisten otros paquetes (la cantidad crece con el tiempo) que son creados bajo la misma filosofía pero no están incluidos. En esos casos hay que instalarlos y activarlos individualmente.\n\nPara profundizar sobre **tidyverse** se puede visitar el sitio <https://www.tidyverse.org/> y la primera versión del libro traducido al español [r4ds](https://es.r4ds.hadley.nz/index.html). La segunda versión está disponible en inglés en [r4ds(2e)](https://r4ds.hadley.nz/)\n\n## Lectura y escritura de datos\n\n### Paquete **readr**\n\n**readr** contiene funciones similares a las de la familia **read.table()** de **R base** pero desarrollados bajo el ecosistema **tidyverse**.\n\nLos archivos de texto plano (**ASCII y otras codificaciones**) son universalmente utilizados por la mayoría de los gestores de bases de datos y/o planillas de cálculo. Generalmente encontrados con extensiones **.txt** o **.csv** (por comma-separated values) son el tipo de archivo de datos más habitual dentro del lenguaje R.\n\nEstos datos planos tienen dos peculiaridades:\n\n-   La cabecera (en inglés **header**)\n-   El caracter o símbolo **separador** que indica la separación de columnas: pueden estar separadas por comas, puntos y comas, por tabulación, etc…\n\nLa cabecera puede existir o no, y de existir puede ser simple o compleja. La inclusión o no de la cabecera se maneja desde los argumentos `col_names` y `skip`.\n\nCon `col_names = TRUE` incluimos la primer fila como cabecera (nombre de las columnas) y en FALSE la salteamos.\n\nCon `skip = 0` la lectura de produce desde la primer fila (se puede omitir), pero si la cabecera fuese compleja con varias filas entre títulos y subtítulos, debemos indicar cuantas filas iniciales se \"saltea\". Por ejemplo con `skip = 5` se saltea las primeras 5 filas del archivo.\n\nEl otro elemento a tener en cuenta es el caracter separador que utiliza el archivo para indicar cuando comienza una nueva columna (variable).\n\nGeneralmente los separadores más comunes son: la coma (,), el punto y coma (;), el tabulador (TAB), el espacio ( ), el caracter pipe (\\|), entre otros posibles.\n\nAlgunas de las funciones del paquete asumen un separador particular. Por caso `read_csv()` lee separados por coma y `read_tsv()` separado por tabulaciones, pero la función `read_delim()` permite que definamos el separador a través del argumento `delim =`.\n\nEn forma detallada el paquete **readr** soporta siete formatos de archivo a partir de siete funciones:\n\n-   **read_csv()**: archivos separados por comas (CSV)\n-   **read_tsv()**: archivos separados por tabulaciones\n-   **read_delim()**: archivos separados con delimitadores generales\n-   **read_fwf()**: archivos con columnas de ancho fijo\n-   **read_table()**: archivos formato tabla con columnas separadas por espacios\n-   **read_log()**: archivos log web\n\nEn comparación con las funciones base de R, las funciones de **readr**:\n\n-   Usan un esquema de nombres consistente de parámetros\n-   Son más rápida.\n-   Analizan eficientemente los formatos de datos comunes, incluyendo fecha/hora.\n-   Muestran una barra de progreso si la carga va a llevar un tiempo. (para archivos grandes)\n\nViene incluida dentro de la instalación de tidyverse y se activa con él, pero también permite activarse solo:\n\n```{r, message=F}\nlibrary(readr)\n```\n\nAlgunos ejemplos de sintaxis:\n\n-   Leemos un archivo sin cabecera separado por comas\n\n```{r, message=F, warning=F}\nread_csv(\"datos/ejemplo-datos.csv\", col_names = F)\n```\n\n-   Leemos el mismo archivo con cabecera y separado por punto y comas\n\n```{r, message=F, warning=F}\nread_csv2(\"datos/ejemplo-datos-header.csv\", col_names = T)\n```\n\n-   Leemos el archivo con cabecera separado por tabulaciones\n\n```{r}\nread_tsv(\"datos/ejemplo-datos-header2.csv\", col_names = T)\n```\n\nObservemos que cada vez que hacemos una lectura la función se encarga de analizar (*parse*) el tipo de dato que hay en cada columna. En esta última ocasión además, devuelve un listado con el resultado del análisis antes de mostrar la tabla importada.\n\nLos posibles tipos de datos son los atómicos del lenguaje más algún agregado: character, integer, numeric, double, logical y date/time.\n\nPor ejemplo, en la tabla leída anteriormente las columnas donde hay números enteros fueron reconocidos como double (**\\<dbl\\>**), los que tienen algún caracter como character (**\\<chr\\>**) y las fechas como date (**\\<date\\>**).\n\nAhora escribimos la sintaxis para leer un archivo con cabecera compleja (la tabla comienza en la fila 9) separado por |.\n\n```{r, message=F, warning=F}\nread_delim(\"datos/ejemplo-datos-header-skip.txt\", \n           col_names = T, \n           skip = 8,      # salteamos las primeras 8 filas\n           delim = \"|\")\n```\n\n> En estos ejemplos visualizamos el contenido de los archivos leídos en consola con el propósito de mostrar como trabajan las funciones, pero en la práctica cada vez que importemos datos de un archivo debemos **asignar** su salida a un nombre, que será el nombre del dataframe que reciba los datos dentro de nuestra sesión de trabajo. (`<-`)\n\n#### Funciones de escritura\n\nDentro del paquete coexisten funciones espejo de escritura para las posibilidades de lectura más relevantes. Así encontramos estos cuatro:\n\n-   **write_csv()**: escribe archivos separados por comas (csv)\n-   **write_csv2()**: escribe archivos separados por punto y comas (csv)\n-   **write_tsv()**: escribe archivos separados por tabulaciones\n-   **write_delim()**: escribe archivos separados con delimitadores definidos por el usuario\n\nLos argumentos son generales y para el caso del último más extensos, dado que hay que definir cual es el separador que deseamos en el archivo.\n\n```{r}\nargs(write_delim)\n```\n\nPor ejemplo para exportar un conjunto de datos en texto plano al que denominaremos **ejemplo.csv** con separador **punto y coma** y **cabecera incluida** podemos hacer:\n\n```{r, eval=F}\nwrite_delim(x = datos, file = \"ejemplo.csv\", delim = \";\")\n```\n\no más sencillo:\n\n```{r, eval=F}\nwrite_csv2(datos, \"ejemplo.csv\")\n```\n\n### Paquete **readxl**\n\nUno de los formatos de documentos más comunes en los que se almacenan datos son las hojas de cálculo, en particular, las creadas con el programa **Excel** de Microsoft Office.\n\nEl paquete `readxl` es parte del ecosistema tidyverse y permite leer este tipo de archivos.\n\nPosee compatibilidad con hojas de cálculo de Excel 97-03, de extensión **.xls**, y con hojas de cálculo de las versiones más recientes de Excel, de extensión, **.xlsx**\n\nLa primera función interesante es `excel_sheets()`, útil para conocer y listar los nombre de las hojas contenidas dentro de un archivo (libro) Excel.\n\nPor ejemplo, supongamos que tenemos un archivo denominado **datos.xlsx** y queremos saber por cuantas hojas está compuesto y que nombre tienen.\n\n```{r}\nlibrary(readxl) # hay que activarlo independientemente de tidyverse\n\nexcel_sheets(\"datos/datos.xlsx\")\n```\n\nObtenemos de esta manera información sobre el archivo. Hay tres hojas llamadas diabetes, vigilancia y mortalidad.\n\nPara poder leer cada una de estas hojas de datos debemos usar la función `read_excel()`, que tiene los siguientes argumentos:\n\n```{r}\nargs(read_excel)\n```\n\nDonde los más relevantes son:\n\n**path**: nombre del archivo y la ubicación (si fuese necesaria) entre comillas\n\n**sheet**: nombre de la hoja o número de ubicación\n\n**col_names**: si se activa toma la primer fila como nombres de columnas (variables)\n\n**skip**: permite saltear una cantidad determinada de filas antes de comenzar la lectura\n\nEn primer lugar, cuando ejecutamos esta función, llama a otra denominada `excel_format()` que determina frente a que formato de archivo estamos. Si es un Excel tipo .xsl o tipo .xlsx. En relación a esta respuesta, luego aplica la función específica para cada caso - `read_xls()` o `readxlsx()`.\n\nTodas estas funciones mencionadas en el procedimiento que sigue `read_excel()` se pueden utilizar en forma específica.\n\nContinuemos con el archivo **datos.xlsx** y procedamos a leer los datos de su primer hoja, llamada *diabetes*.\n\n```{r}\ndiabetes <- read_excel(path = \"datos/datos.xlsx\", \n                       sheet = \"diabetes\",\n                       col_names = T)\n\nhead(diabetes) # mostramos las 6 primeras observaciones\n```\n\nObservemos que en los argumentos escribimos el nombre del archivo que se encuentra en nuestro proyecto y por lo tanto en nuestra carpeta activa, el nombre de la hoja y nos aseguramos que la primer fila representa a la cabecera de la tabla (sus nombres de variables).\n\nComo el paquete `readxl` se inscribe dentro del universo tidyverse el formato de salida es un dataframe/tibble. En este caso de 23 observaciones por 8 variables.\n\nAhora leamos la segunda hoja de nombre *vigilancia*.\n\n```{r, message=F}\nvigilancia <- read_excel(path = \"datos/datos.xlsx\", \n                         sheet = 2, \n                         col_names = F)\n\nhead(vigilancia) # mostramos las 6 primeras observaciones\n```\n\nCentremos nuestra mirada en los argumentos anteriores: en lugar del nombre de la hoja usamos un **2** que es su ubicación (la segunda hoja del archivo Excel) y configuramos a **col_names** con **F** (false) porque el conjunto de datos no tiene cabecera.\n\nCuando ocurre esta situación donde la tabla no tiene nombre de columnas readxl le asigna nombres del tipo `...1`, `...2`, `...x`\n\nFinalmente leemos la última hoja disponible del archivo.\n\n```{r}\nmortalidad <- read_excel(path = \"datos/datos.xlsx\", \n                         sheet = \"mortalidad\",\n                         col_names = T, \n                         skip = 1)\n\nhead(mortalidad) # mostramos las 6 primeras observaciones\n```\n\nLo novedoso de esta lectura es el argumento `skip = 1` que debimos incorporar dado que, en este caso, la hoja de Excel comienza con una línea de título que no pertenece al conjunto de datos. También que el argumento sheet permite el nombre de la hoja elegida entre comillas.\n\nRetomando los argumentos generales de la función podemos mencionar estos otros:\n\n**n_max**: número máximo de filas leídas\n\n**range**: rango de celdas a leer (definidas como se suele usar en Excel, por ej: B3:D87)\n\n**col_types**: especificación del tipo de dato para cada columna leída. Se pueden utilizar los tipos habituales \"numeric\", \"logical\", \"text\", \"date\", etc. Existen dos tipos específicos más: \"skip\" que saltea la lectura de la columna y \"guess\" que permite que la función decida cual es el formato adecuado de importación. Este último es el modo predeterminado cuando no especificamos el argumento.\n\n**na**: caracter o vector que deseamos se interprete como valor perdido (missing). Por defecto las celdas vacías se interpretan de esta forma y se le asigna `NA`\n\n## Gestión de datos con el Paquete **dplyr**\n\nEl paquete **dplyr** es parte del universo tidyverse que fue desarrollado por *Hadley Wickham* a partir de optimizar una versión del paquete plyr.\n\nLa contribución significativa del paquete es proporcionar una \"gramática\" (funciones-verbos) para la manipulación y operaciones de datos que lo hace más fácil de entender.\n\nLas funciones clave del paquete, responden a las siguientes acciones (verbos):\n\n-   `select()`: devuelve un conjunto de columnas (variables)\n-   `rename()`: renombra variables en una conjunto de datos\n-   `filter()`: devuelve un conjunto de filas (observaciones) según una o varias condiciones lógicas\n-   `arrange()`: reordena filas de un conjunto de datos\n-   `mutate()`: añade nuevas variables/columnas o transforma variables existentes\n-   `summarise()`/`summarize()`: genera resúmenes estadísticos de diferentes variables en el conjunto de datos.\n-   `group_by()`: agrupa un conjunto de filas seleccionado, en un conjunto de filas de resumen de acuerdo con los valores de una o más columnas o expresiones.\n-   `count()`: contabiliza valores que se repiten, es decir genera tabla de frecuencias.\n\n### Argumentos comúnes en las funciones dplyr\n\nTodas las funciones, básicamente, tienen en común una serie de argumentos.\n\n1. El primer argumento es el nombre del conjunto de datos (objeto donde esta nuestra tabla de datos) \n\n2. Los otros argumentos describen que hacer con el conjunto de datos especificado en el primer argumento, podemos referirnos a las columnas en el objeto directamente sin utilizar el operador $, es decir sólo con el nombre de la columna/variable. \n\n3. El valor de retorno es un nuevo conjunto de datos. \n\n4. Los conjunto de datos deben estar bien organizados/estructurados, es decir debe existir una observación por columna y, cada columna representar una variable, medida o característica de esa observación. Es decir, debe cumplir con *tidy data*.\n\n### Activación del paquete\n\n**dplyr** está incluído en el paquete **tidyverse**, por lo que se encuentra disponible si tenemos activado a este último.\n\nTambién se puede activar en forma independiente, aunque no es necesario si ya activamos tidyverse:\n\n```{r, message=F, warning=F}\nlibrary(dplyr)\n```\n\n### Conjunto de datos para ejemplo\n\nVisualizar y entender el funcionamiento de estos \"verbos\" de manipulación es posible si ejemplificamos su aplicación. Por este motivo vamos a leer un conjunto de datos que servirá para ejercitar las funciones del paquete.\n\n```{r}\ndatos <- read_csv(\"datos/noti-vih.csv\") # asignamos la lectura a datos\n\nhead(datos) # mostramos las 6 primeras observaciones\n```\n\nLa tabla de datos \"noti-vih.csv\" contiene datos de notificación de vih por jurisdicción de Argentina para los años 2015 y 2016.\n\n### Función **select()**\n\nEsta función selecciona las variables que especificamos devolviendo un conjunto de datos \"recortado por columna\".\n\n`select()` utiliza un minilenguaje conciso que facilita hacer referencia a las variables según su nombre, ubicación, condición o tipo.\n\nAlguno de sus operadores son:\n\n- `:` para seleccionar un rango de variables consecutivas.\n\n- `-` para evitar seleccionar la variable que sigue al signo\n\n- `!` para tomar el complemento de un conjunto de variables.\n\nVeamos algunas aplicaciones de estas \"ayudas\" para hacer selecciones.\n\nTodas las variables menos *pob*\n\n```{r}\ndatos |>  \n  select(-pob)\n```\n\nOtra forma para el mismo resultado anterior (mediante el operador rango :)\n\n```{r}\ndatos |>  \n  select(jurisdiccion:casos)\n```\n\nLas variables *jurisdiccion* y *casos*\n\n```{r}\ndatos |>  \n  select(jurisdiccion, casos)\n```\n\nOtra forma para el mismo resultado anterior (mediante números de columna):\n\n```{r}\ndatos |>  \n  select(1, 3)\n```\n\nTodas las variables pasando *año* a la primera columna\n\n```{r}\ndatos |>  \n  select(\"año\", everything())\n```\n\nEsta última función `everything()`, pasada como argumento, es una de las  posibles funciones llamadas **\"ayudantes de selección\"**, entre las cuales se encuentra:\n\n-   `starts_with()`: selecciona todas las columnas que comiencen con el patrón indicado.\n\n-   `ends_with()`: selecciona todas las columnas que terminen con el patrón indicado.\n\n-   `contains()`: selecciona las columnas que posean el patrón indicado.\n\n-   `matches()`: similar a `contains()`, pero permite poner una expresión regular.\n\n-   `all_of()`: selecciona las variables pasadas en un vector (todos los nombres deben estar presentes o devuelve un error)\n\n-   `any_of()`: idem anterior excepto que no se genera ningún error para los nombres que no existen.\n\n-   `num_range()`: selecciona variables con nombre combinados con caracteres y números (ejemplo: num_range(\"x\", 1:3) selecciona las variables x1, x2 y x3.\n\n-   `where()`: aplica una función a todas las variables y selecciona aquellas para las cuales la función regresa TRUE (por ejemplo: `is.numeric()` para seleccionar todas las variables numéricas)\n\n- `group_cols()`: selecciona todas las columnas de agrupación.\n\nTodas estas funciones son muy útiles a la hora de seleccionar el conjunto de variables necesarias no solo para un `select()` básico sino también cuando necesitemos aplicar operaciones simultáneas y/o pivotear tablas de datos que necesiten garantizar formato ordenado (tidy-data).\n\n### Función **rename()**\n\nEsta función es una extensión de `select()`, dado que esta última permite cambiar el nombre de variables pero no es muy útil porque descarta todas las variables que no se mencionan explícitamente. En cambio `rename()` renombra variables mientras que mantiene las demás no mencionadas.\n\nPor ejemplo, cambiamos el nombre de la variable *pob* por *población*.\n\n```{r}\ndatos |> \n  rename(\"población\" = pob)\n```\n\n### Función **filter()**\n\nAsí como la función `select()` es utilizada para seleccionar columnas, la función `filter()` hace lo propio con las filas del conjunto de datos, produciendo un subconjunto de observaciones.\n\nVeamos un ejemplo sencillo sobre nuestros datos:\n\n```{r}\ndatos |> \n  filter(jurisdiccion == \"Tucuman\")\n```\n\nUtiliza los mismos operadores de comparación propios del lenguaje R\n\n| Comparación |                 |\n|:-----------:|-----------------|\n|     \\<      | menor a         |\n|     \\>      | mayor a         |\n|     ==      | igual a         |\n|     \\<=     | menor o igual a |\n|     \\>=     | mayor o igual a |\n|     !=      | no igual a      |\n|    %in%     | es parte de     |\n|    is.na    | es NA           |\n|   !is.na    | no es NA        |\n\nLo mismo con los operadores lógicos que se utilizan como conectores entre las expresiones.\n\n| Lógicos |                |\n|:-------:|----------------|\n|    &    | AND booleano   |\n|   \\|    | OR booleano    |\n|   xor   | OR exclusivo   |\n|    !    | NOT            |\n|   any   | cualquier TRUE |\n|   all   | todos TRUE     |\n\nCuando usamos múltiples argumentos separados por coma dentro de `filter()` se combinan con un conector **AND**, es decir cada expresión debe ser verdadera para que una fila sea incluida en la salida.\n\nPor ejemplo:\n\nFiltramos a las observaciones que cumplan con la condición que casos sea mayor a 100 y población sea menor a 1000000\n\n```{r}\ndatos |> \n  filter(casos > 100, pob < 1000000)\n```\n\nPara combinaciones dentro de una misma variable debemos utilizar el conector OR (`|`) o más útil el operador `%in%`.\n\nFiltramos a las jurisdicciones \"Buenos Aires\" y \"La Pampa\"\n\n```{r}\ndatos |> \n  filter(jurisdiccion == \"Buenos Aires\" | jurisdiccion == \"La Pampa\")\n```\n\n```{r}\ndatos |> \n  filter(jurisdiccion %in% c(\"Buenos Aires\", \"La Pampa\"))\n```\n\nFiltramos las observaciones de 2016 con casos mayores a 200 utilizando el conector AND (`&`). Es el mismo resultado que si utilizamos una coma.\n\n```{r}\ndatos |> \n  filter(año == \"2016\" & casos > 200)\n```\n\nFiltramos las observaciones inversas a la anterior mediante xor(), que selecciona los valores de año y casos exclusivos (es decir que no se den ambos en TRUE).\n\n```{r}\ndatos |> \n  filter(xor(año == \"2016\", casos > 200))\n```\n\n### Función **arrange()**\n\nLa función `arrange()` se utiliza para ordenar las filas de un conjunto de datos de acuerdo a una o varias columnas/variables. Por defecto, el ordenamiento es ascendente alfanumérico.\n\nOrdenamos la tabla **datos** por la variable *pob* (forma ascendente predeterminada):\n\n```{r}\ndatos |> \n  arrange(pob)\n```\n\nPara ordenar en forma descendente podemos utilizar `desc()` dentro de los argumentos de `arrange()`:\n\n```{r}\ndatos |> \n  arrange(desc(pob))\n```\n\nPodemos combinar ordenamientos. Por ejemplo, en forma alfabética ascendente para *jusrisdiccion* y luego numérica descendente para *casos*.\n\n```{r}\ndatos |> \n  arrange(jurisdiccion, desc(casos))\n```\n\n### Función **mutate()**\n\nEsta función nos proporciona computar tranformaciones de variables en un conjunto de datos. A menudo, tendremos la necesidad de modificar variables existentes o crear nuevas variables que se calculan a partir de las que tenemos, `mutate()` nos ofrece una interface clara para realizar este tipo de operaciones.\n\nPor ejemplo, nos puede interesar calcular tasas crudas para cada jurisdicción y año, en función de los casos y el total de población.\n\n```{r}\ndatos |> \n  mutate(tasa = casos/pob*100000)\n```\n\nObservemos que la función realiza el cálculo (en este caso tasas crudas por 100000 habitantes) e incorpora una nueva variable por cada observación con el resultado.\n\nTambién se pueden construir múltiples variables en la misma expresión, solamente separadas por comas.\n\n```{r}\ndatos |> \n  mutate(tasaxcien_mil = casos/pob*100000, \n         tasaxdiez_mil = casos/pob*10000)\n```\n\nSi necesitemos que estas dos nuevas variables queden dentro de la tabla de datos y no solo mostrarla en consola como hasta ahora, debemos utilizar el operador de asignación:\n\n```{r, eval=F}\ndatos <- datos |> \n  mutate(tasaxcien_mil = casos/pob*100000, \n         tasaxdiez_mil = casos/pob*10000)\n```\n\nLa propiedad imprescindible es que la función debe poder vectorizar: debe tomar un vector de valores como entrada, y devolver un vector con el mismo número de valores que la salida.\n\nNo hay forma de enumerar todas las funciones posibles que se podría usar, pero mencionaremos algunas que pueden ser útiles:\n\n-   Operadores aritméticos: +, -, \\*, /, \\^.\n\n-   Aritmética modular: %/% (división entera) y %% (resto), donde $x == y * (x \\ \\%/\\% \\ y) + (x\\ \\%\\% \\ y)$. La aritmética modular es una herramienta útil porque te permite dividir números enteros en porciones.\n\n-   Funciones matemáticas: `log()`, `log2()`, `log10()`, `exp()`, `sqrt()`, `abs()`, etc\n\n-   Valores acumulados: R proporciona funciones para ejecutar sumas, productos, mínimos y máximos acumulados: `cumsum()`, `cumprod()`, `cummin()`, `cummax()`; y **dplyr** proporciona `cummean()` para promedios acumulados.\n\n-   Clasificaciones (ranking): hay una serie de funciones de clasificación, por ejemplo `min_rank()`. Genera el tipo de clasificación habitual (1º, 2º, etc). El valor predeterminado relaciona los valores más pequeños a rangos pequeños; podemos usar `desc(x)` para invertir la relación (valores más grandes a rangos más pequeños)\n\nSi utilizamos el mismo nombre de una variable incluída dentro de la tabla de datos, estaremos sobrescribiendola (se usa cuando transformamos una variable, por ejemplo: le cambiamos su tipo de `character` a `factor`). Para que la variable sea nueva debe nombrarse con un nombre que no exista previamente dentro de la tabla de datos.\n\n### Funciones condicionales\n\nDentro un `mutate()`, algunas veces vamos a necesitar agrupar, agregar o discretizar variables continuas donde generemos variables dicotómicas o politómicas.\n\nEstas funciones que llamaremos \"condicionales\", dado que utilizan condiciones para decidir que valor tomar, no se limitan a la tarea de construir agrupamientos de variables cuantitativas sino que sirven para cualquier situación donde a partir de una o más condiciones se produzcan una o más valores como respuesta.\n\n#### Condicional simple - función **if_else()**\n\nPara salidas dicotómicas tenemos la función condicional `if_else()` derivada de la simplificación del **IF condicional** que existe en todos los lenguajes de programación.\n\nSupongamos que creamos una nueva variable dentro del dataframe **datos** que se llama **_variable_nueva_** de tipo cualitativa y queremos que la misma tome valores a partir del cumplimiento de una condición de una variable cuantitativa existente denominada **var1**. \n\nSi los valores de **var1** son mayores a 10, entonces **variable_nueva**, tomará el valor \"mayor a 10\", en caso contrario, tomará el valor \"menor o igual a 10\"\n\n```{r, eval=F}\ndatos <- datos |> \n  mutate(variable_nueva = if_else(condition = var1 > 10, \n                                  true = \"mayor a 10\", \n                                  false = \"menor o igual a 10\"))\n```\n\n`if_else()` tiene tres argumentos obligatorios, el primero siempre es una condición, el segundo y el tercero son los valores que tomará la nueva variable si esa condición se cumple o no se cumple. \n\nHabitualmente decimos que en este proceso dicotomizamos una variable, dado que el resultado posible consta siempre de 2 valores.\n\nLos valores de salida de esta función pueden ser de variado tipo (caracter, numerico o logico) aunque si estamos discretizando una variable cuantitativa generalmente construimos una variable resultado cualitativa ordinal. Es común que esta variable salida sea tipo `character` (observar que las nuevas categorías van encerradas entre comillas).\n\nAhora bien, al ser ordinal estas categorías de la variable_nueva deben \"ordenarse\" en la forma de los valores de la variable, pero el lenguaje R no sabe con que estamos trabajando y respeta siempre el ordenamiento alfanumérico. Por lo tanto, en este ejemplo las categorías se van a estar ordenando al reves del orden numérico natural (de menor a mayor).\n\n*\"mayor a 10\"* se ordena alfabéticamente antes de *\"menor o igual a 10\"*, porque luego del empate de las letras `m`, le siguen la `a` en el primer caso y la `e` en el segundo.\n\nPara ordenar estas categorías debemos transformar la variable de caracter a factor. Esto se puede hacer en un solo paso dentro del mutate:\n\n```{r, eval=F}\ndatos <- datos |> \n  mutate(variable_nueva = if_else(condition = var1 > 10, \n                                  true = \"mayor a 10\", \n                                   false = \"menor o igual a 10\"),\n         variable_nueva = factor(variable_nueva, \n                                 levels = c(\"menor o igual a 10\",\n                                            \"mayor a 10\")))\n```\n\nOtra forma más artesanal, igualmente válido, es \"forzar\" el ordenamiento con las categorías así:\n\n```{r, eval=F}\ndatos <- datos |> \n  mutate(variable_nueva = if_else(condition = var1 > 10, \n                                  true = \"2.mayor a 10\", \n                                  false = \"1.menor o igual a 10\"))\n```\n\nAquí agregamos números iniciales a las etiquetas de las categorías para darle el orden que deseamos, sin necesidad de convertir a factor.\n\n#### Condicional multiple \n\nEn salidas politómicas a partir de variables cuantitativas tenemos varias opciones dependiendo de si los intervalos de clase a construir son regulares o irregulares.\n\n#### Función **cut_interval()**\n\n**tidyverse** ofrece la función `cut_interval()` para la creación de intervalos regulares.\n\nEs una adptación de la función `cut()` de R base para tidy data y sus argumentos son similares.\n\n```{r, eval=F}\ndatos <- datos |> \n  mutate(grupo_var = cut_interval(x = var1, \n                                  length = 10,\n                                  right = T,\n                                  labels = T,\n                                  ordered_result = F))\n```\n\nLos argumentos obligatorios y opcionales de la función `cut()` son:\n\n- **x**: [obligatorio] El conjunto de datos numéricos de entrada (variable cuantitativa continua)\n\n- **length**: [obligatorio] la longitud de cada intervalo regular\n\n- **right**: [opcional] Indica si los intervalos son cerrados a la derecha o viceversa. Por defecto vale TRUE (cerrados a derecha)\n\n- **labels**: [opcional] Etiquetas de los intervalos automáticas o numéricas. Valor predeterminado TRUE (intervalos matemáticos)\n\n- **ordered_result**: [opcional] - determina si el resultado es un factor ordenado. Por defecto vale FALSE (la salida es tipo caracter)\n\nLos argumentos opcionales no son necesarios definirlos siempre y cuando los valores por defecto son los que sirven para la tarea.\n\n\n#### Función **case_when()**\n\nCuando las condiciones no son simples, es decir, el resultado no es dicotómico y además los intervalos son irregulares, utilizamos la función `case_when()` que es una vectorización de la función `if_else()`.\n\nSupongamos que no queremos agrupar la variable en dos valores, sino en 3 grupos irregulares.\n\nEsquema básico de funcionamiento:\n\n```{r, eval=F}\n# var1 es una variable cuantitativa de números enteros \n\ndatos <- datos |> \n  mutate(grupo_var = case_when( \n    var1 >= 0 & var1 < 25  ~  \"Grupo1\", \n    var1 > 24 & var1 < 65  ~ \t\"Grupo 2\", \n    var1 >= 65             ~ \t\"Grupo 3\"))\n```\n\nExiste una condición por cada grupo creado, como si fuese un `if_else()` donde el valor declarado siempre es el verdadero. Se utilizan operadores de comparación como mayor ( > ), menor ( < ) y/o igual ( = ) y conectores lógicos como & ( AND ). En cada línea va una virgulilla similar a la usada en la sintaxis formula ( ~ ) y luego la etiqueta que tomarán las observaciones que cumplan con esa condición en la nueva variable (grupo_var).\n\nEsta evaluación es secuencial y su funcionamiento provoca que el usuario del lenguaje tenga el control de lo que esta sucediendo, por lo que cualquier mala definición de las condiciones puede provocar resultados incorrectos.\n\nSi incorporamos el argumento **.default** podemos indicar que valor toma si no se cumple ninguna de las condiciones anteriores.\n\nPor ejemplo, podríamos tener algun valor perdido (NA) en `var1` y queremos que la variable `grupo_var` etiquete esos valores perdidos como \"Sin dato\":\n\n```{r, eval=F}\n# var1 es una variable cuantitativa de números enteros con algun valor NA\n\ndatos <- datos |> \n  mutate(grupo_var = case_when( \n\t\tvar1 >= 0 & var1 < 25  ~  \"Grupo1\", \n\t\tvar1 > 24 & var1 < 65  ~ \t\"Grupo 2\", \n\t\tvar1 >= 65             ~ \t\"Grupo 3\",\n\t\t.default = \"Sin dato\"))\n```\n\nLas salidas son de tipo **_carácter_** (chr) y debemos manejar el ordenamiento de las etiquetas como vimos anteriormente, por medio de factores o comenzando con caracteres ordenados alfabeticamente.\n\nPara simplificar el trabajo de estos intervalos de clase irregulares y no provocar errores en la confección de las condiciones, tidyverse tiene a la función `between()`.\n\n#### Intervalos - función **between()**\n\nBáicamente opera como un atajo para condiciones de intervalos. Define dentro de los argumentos los límites inferior y superior de un intervalo y se utiliza dentro de una función de condición tipo `if_else()` o `case_when()`. \n\nAplicado sobre el ejemplo anterior se vería así:\n\n```{r, eval=F}\n# var1 es una variable cuantitativa de números enteros con algun valor NA\n\ndatos <- datos |> \n  mutate(grupo_var = case_when( \n    between(var1, 0, 24)   ~  \"Grupo1\", \n\t\tbetween(var1, 25, 64)  ~ \t\"Grupo 2\", \n\t\tbetween(var1, 65, Inf) ~ \t\"Grupo 3\",\n\t\t.default = \"Sin dato\"))\n```\n\nLos valores declarados como límites quedan incluídos siempre dentro del intervalo (son cerrados ambos). También podemos utilizar valores reservados como `Inf` o `-Inf` cuando desconocemos con que valor máximo o mínimo nos vamos a encontrar en la variable cuantitativa original.\n\n#### Ejemplos con variable edad\n\nTomemos un caso clásico como la variable edad medida en años, variable que generalmente tenemos en toda tabla de datos vinculada a personas. En este ejemplo la variable tiene 106 observaciones.\n\n```{r, echo=F, message=F, warning=F}\ndatos <- read_csv2(\"datos/edad.txt\", locale = locale(encoding = \"ISO-8859-1\"))\n\ndatos <- datos |> mutate(fecha_nacimiento = dmy(fecha_nacimiento),\n                fecha_test = dmy(fecha_test),\n                edad = round(as.duration(fecha_test - fecha_nacimiento) / dyears(1))) |> select(edad)\n\n```\n\nUna posibilidad es dicotomizarla usando el valor de la mediana que divide 2 dos partes toda la distribución.\n\n```{r}\n\ndatos |> \n  summarise(mediana = median(edad))\n\n```\nAplicando el valor 56 dentro de un if_else podriamos hacer:\n\n```{r}\ndatos <- datos |> \n  mutate(grupo_edad1 = if_else(condition = edad > 56, \n                                  true = \"mayor a la mediana\", \n                                  false = \"menor o igual a la mediana\"))\n\ndatos |> \n  count(grupo_edad1)\n```\n\nObservamos en el conteo que `grupo_edad1` se construyó adecuadamente pero el orden de los niveles no es correcto si queremos que siga el ordenamiento natural de edad (de menor a mayor).\n\nUna de las formas que vimos es convertir a factor:\n\n```{r}\ndatos <- datos |> \n  mutate(grupo_edad1 = if_else(condition = edad > 56, \n                                  true = \"mayor a la mediana\", \n                                  false = \"menor o igual a la mediana\"),\n         grupo_edad1 = factor(grupo_edad1, \n                                 levels = c(\"menor o igual a la mediana\",\n                                            \"mayor a la mediana\")))\n\ndatos |> \n  count(grupo_edad1)\n```\n\nVemos que en el conteo el formato de la variable ya no es `chr` sino `fct` y el orden de las etiquetas siguen la forma *\"menor a mayor\"*.\n\nOtra forma es:\n\n```{r}\ndatos <- datos |> \n  mutate(grupo_edad1 = if_else(condition = edad > 56, \n                                  true = \"2.mayor a la mediana\", \n                                  false = \"1.menor o igual a la mediana\"))\n\ndatos |> \n  count(grupo_edad1)\n```\n\nSi en cambio necesitamos que los grupos sean mas de dos y que estos intervalos de clase sean regulares, podemos usar `cut_interval`\n\n```{r}\ndatos <- datos |> \n  mutate(grupo_edad2 = cut_interval(x = edad, \n                                    length = 10))\n\ndatos |> \n  count(grupo_edad2)\n```\nLa salida muestra 8 grupos etarios con etiquetas ordenadas con notación matemática, donde un corchete indica que el límite del intervalo es cerrado, es decir contiene el valor y un paréntesis es abierto y no lo hace.Así es que el primer grupo va de 0 a 10 años y el segundo de 11 a 20.\n\nEstos sucede así porque en forma predeterminada el argumento **right** está en `TRUE`. Veamos que pasa si lo cambiamos a `FALSE`:\n\n```{r}\ndatos <- datos |> \n  mutate(grupo_edad2 = cut_interval(x = edad, \n                                    length = 10,\n                                    right = F))\n\ndatos |> \n  count(grupo_edad2)\n```\nEn esta salida el primer grupo va de 0 a 9 y el segundo de 10 a 19.\n\nHasta ahora la variable grupo_edad2 es de tipo caracter, pero si deseamos que la salida sea factor podemos incorporar el argumento **ordered_result** en `TRUE`.\n\n```{r}\ndatos <- datos |> \n  mutate(grupo_edad2 = cut_interval(x = edad, \n                                    length = 10,\n                                    ordered_result = T))\n\ndatos |> \n  count(grupo_edad2)\n```\nConstruimos así una variable factor ordenada <ord>.\n\nPor último, con el argumento **labels** en `FALSE` hacemos que las etiquetas de los 8 grupos sean numéricas.\n\n```{r}\ndatos <- datos |> \n  mutate(grupo_edad2 = cut_interval(x = edad, \n                                    length = 10,\n                                    labels = F))\n\ndatos |> \n  count(grupo_edad2)\n```\n\nOtro ejemplo, podría ser aplicando `case_when()` donde discretizamos la edad en 4 grupos irregulares, forzando sus etiquetas para lograr el orden adecuado.\n\n\n```{r}\ndatos <- datos |> \n  mutate(grupo3 = case_when(\n    edad < 13              ~ \"1.Niño\",\n    edad > 12 & edad < 26  ~ \"2.Adolescente\",\n    edad > 25 & edad < 65  ~ \"3.Adulto_joven\",\n    edad > 64              ~ \"4.Adulto_mayor\"\n  ))\n\ndatos |> \n  count(grupo3)   \n```\n\nSi no hubiesemos etiquetado con los numeros por delante el orden alfabético hacía que Niño fuese a parar al final del conteo.\n\nDe la misma forma pero más sencillo y controlado es:\n\n```{r}\ndatos <- datos |> \n  mutate(grupo3 = case_when(\n    between(edad, 0, 12)   ~ \"1.Niño\",\n    between(edad, 13, 25)  ~ \"2.Adolescente\",\n    between(edad, 26, 64)  ~ \"3.Adulto_joven\",\n    between(edad, 65, Inf) ~ \"4.Adulto_mayor\"\n  ))\n\ndatos |> \n  count(grupo3)  \n```\n\n\n\n### Función **summarise()**\n\nLa función `summarise()` (se puede escribir también `summarize()`) resume variables de un conjunto de datos.\n\n```{r, echo=F, message=F, warning=F}\ndatos <- read_csv(\"datos/noti-vih.csv\")\n```\n\n\n```{r}\ndatos |> \n  summarise(promedio_casos = mean(casos), \n            casos_totales = sum(casos))\n```\n\nSu uso es muy interesante cuando la combinamos con `group_by()` (función que detallaremos luego). Esta situación permite estratificar los resultados por grupos específicos.\n\nPor ejemplo, podemos agrupar el por año y simultáneamente aplicar el mismo `summarise()` anterior.\n\n```{r}\ndatos |>  \n  group_by(año) |>  \n  summarise(promedio_casos = mean(casos), \n            casos_totales = sum(casos))\n```\n\nEl resultado es una tabla con dos filas, una para cada grupo (año 2015 y año 2016) con los valores promedio y casos totales respectivos.\n\nAlgunas de las funciones del R base que se pueden utilizar dentro de los argumentos de esta función son:\n\n-   `min()` mínimo\n-   `max()` máximo\n-   `mean()` media\n-   `median()` mediana\n-   `var()` varianza\n-   `sd()` desvío\n-   `sum()` sumatoria\n\nOtras funciones que se pueden incorporar las provee el mismo paquete **dplyr**, por ejemplo:\n\n-   `first()` primer valor en el vector\n-   `last()` último valor en el vector\n-   `n()` número de valores en el vector\n-   `n_distinct()` números de valores distintos en el vector\n\nDesde la versión 1.4.0 de **dplyr** la función `summarise()` incorpora un nuevo argumento para agrupamientos temporales. El argumento `.by =` trabaja igual que un `group_by()` previo pero lo hace solo para realizar el calculo definido dentro del resumen evitando que el dataframe de salida mantenga el agrupamiento.\n\nLa estructura básica de la función actualizada es:\n\n```{r}\n#| eval: false\n\ndatos |> \n  summarise(\n    var_resumen = funcion(var),\n    .by = var_grupo\n  )\n```\n\nAplicada en el ejemplo previo:\n\n```{r}\ndatos |>  \n  summarise(promedio_casos = mean(casos), \n            casos_totales = sum(casos),\n            .by = año)\n```\n\n### Función **group_by()**\n\nDecíamos recién que la función `group_by()` es útil cuando trabaja conjuntamente con `summarise()` dado que agrupa un conjunto de filas seleccionado en un conjunto de filas de resumen de acuerdo con los valores de una o más columnas o expresiones.\n\nPara ejemplificar su trabajo asociado obtendremos una nueva tabla con el cálculo de las tasas crudas para cada jurisdicción por año (similar al ejemplo de la aplicación de `mutate()`:\n\n```{r, message=F}\ndatos |> \n  group_by(jurisdiccion, año) |>  \n  summarise(tasa = casos/pob*100000)\n```\n\nEn la mayoría de estos ejemplos la salida es directa, es decir no construimos nuevos objetos contenedores de los datos producidos y vemos los resultados en consola o en el visualizador de RStudio. Pero en muchas situaciones vamos a necesitar generar nuevos conjunto de datos con las transformaciones realizadas. Si en alguna de estas ocasiones llegamos a agrupar datos mediante `group_by()` y posteriormente necesitamos volver a tener la información desagrupada existe una función vinculada denominada `ungroup()` que vamos a necesitar aplicar o bien si no se desea tener el agrupamiento de forma fija se puede usar el argumento `.by =` del `summarise()` como mostramos anteriormente.\n\n### Combinaciones\n\nEn los ejemplos anteriores vimos como se van integrando alguna de las funciones mediante el uso de la tubería **%\\>%** o **\\|\\>**. La idea detrás de la búsqueda gramatical del paquete es poder enlazar las acciones para construir oraciones más complejas.\n\nUn ejemplo que podría integrar gran parte de los visto sería:\n\nObtener una nueva tabla con las tasas crudas de casos notificados de VIH, por año y jurisdicción, mayores a 20 x 100000 habitantes ordenadas de mayor a menor.\n\n```{r, message=F}\ndatos |>                                   # siempre partimos de los datos\n  group_by(año, jurisdiccion) |>           # agrupamos\n  summarise(tasa = casos/pob*100000) |>    # resumimos\n  filter(tasa > 20) |>                     # filtramos\n  arrange(desc(tasa))                       # ordenamos   \n```\n\nObservemos que una buena manera de construir el código es respetar un salto de línea para cada término de la oración para una lectura más clara.\n\nDemostramos así la potencialidad que tienen estas funciones combinadas donde en esta situación integramos las funciones `group_by()`, `summarise()` , `filter()` y `arrange()` en una misma operación.\n\n### Función **count()**\n\nEsta última función que presentamos permite contar rápidamente los valores únicos de una o más variables.\n\nProduce fácilmente tablas de frecuencias absolutas que luego posibilitan construir frecuencias relativas.\n\nLa aplicamos sobre la variable **jurisdiccion** de *datos*\n\n```{r}\ndatos |> \n  count(jurisdiccion)\n```\n\nTiene un par de argumentos opcionales:\n\n-   **name**: es el nombre de la columna con el conteo. Por defecto se llama **n**\n-   **sort**: ordena la tabla de frecuencia de mayor a menor\n-   **wt**: se puede opcionalmente incorporar una variable con la ponderación (factor de expansión) para el calculo de la frecuencia.\n\n## Gráficos estadísticos con **ggplot2**\n\n**ggplot2** es un paquete que se autodefine como librería para *“crear elegantes visualizaciones de datos usando una gramática de gráficos”*\n\nPropone una forma intuitiva de construir gráficos basada en [The Grammar of Graphics](https://www.springer.com/gp/book/9780387245447), a partir de utilizar capas y un sistema apoyado en tres componentes básicos:\n\n-   datos\n-   coordenadas\n-   objetos geométricos\n\nLa estructura para construir un gráfico es la siguiente:\n\n```{r,echo=F,  fig.align='center', out.width = \"40%\"}\nknitr::include_graphics(\"img/03/estructura_ggplot.JPG\")\n```\n\n### Anatomía de gráficos con ggplot2\n\nEl paquete se basa en una gramática de gráficos que puede ser entendida a partir de conocer sus componentes:\n\n```{r,echo=F,  fig.align='center', out.width = \"40%\"}\nknitr::include_graphics(\"img/03/ggplot1.JPG\")\n```\n\n-   **data** es aquél conjunto de datos que vamos a graficar, con toda la información pertinente para realizar el gráfico.\n-   **aes** reducción de aesthetic mapping o mapeo estético en el que se puede declarar todo lo que puede ser visible de un gráfico.\n-   **geoms** son representaciones para dibujar gráficos (puntos, líneas, cajas, entre otros).\n-   **stats** son aquellas transformaciones estadísticas que le hacemos a los datos. Nos ayudan a hacer un resumen del conjunto de datos para visualizar mejor (por ejemplo, la media o la mediana como estadísticas de tendencia central).\n-   **scales** facilitan colorear (o escalar) los datos según distintas variables. Dibujan los ejes y las leyendas.\n-   **coordinate Systems** es el sistema de coordenadas para el mapeo del gráfico en un plano bidimensional.\n-   **facets** nos permiten partir el conjunto de datos según factores para graficar en viñetas separadas creando matrices gráficas.\n-   **themes** son conjuntos de características gráficas que permiten controlar la apariencia general de todos los elementos que no son datos (por ejemplo, el color del fondo o el tipo de fuente).\n\nAntes de comenzar a explicar cada componente vamos a leer un conjunto de datos que nos permita mostrar los ejemplos gráficos.\n\n```{r, message=FALSE, warning=FALSE}\nlibrary(tidyverse)\n\nfacultad <- read_csv(\"datos/facultad.csv\") # lectura\n\nhead(facultad) # mostramos las 6 primeras observaciones\n```\n\nEl archivo leído se llama *facultad.csv* y contiene información de salud sobre ingresantes a una facultad tales como sexo, edad, talla y peso, entre otras. (son datos ficticios con fines docentes).\n\n### Mapeo estético (**aesthetic mapping**) y objetos geométricos (**geom**)\n\nDecíamos que `aes()` hace referencia al contenido estético del gráfico. Es decir, la función le brinda indicios a **ggplot2** sobre cómo dibujar los distintas líneas, formas, colores y tamaños.\n\nEs importante notar que `aes()` crea una nueva capa en relación a las variables y agrega leyendas a los gráficos. Al incorporar `aes()` al llamado de `ggplot()` estamos compartiendo la información estética en todas las capas. Si deseamos que esa información sólo esté en una de las capas, debemos usar `aes()` en la capa correspondiente.\n\nVeamos como funciona y sus diferencias.\n\n```{r,eval=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO)) # solo la capa estética aes()\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO))  +\n  theme(text = element_text(size = 100))\n```\n\nEste gráfico solo contiene los ejes que especificamos (PESO y TALLA) pero no contiene los datos. Si deseamos incorporarlos agregamos una capa de puntos con `geom_point()` a través del símbolo **+**.\n\n```{r,eval=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO))  + \n  geom_point()                    # agregamos la capa geométrica de puntos\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO))   + \n  geom_point() +                   # agregamos la capa geométrica de puntos\n  theme(text = element_text(size = 100))\n```\n\nPodemos diferenciar los puntos según se traten de ingresantes mujeres y hombres, asociando el argumento **color** dentro de `aes()` con la variable SEXO.\n\n```{r,eval=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n  geom_point()\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n  geom_point()         +     \n  theme(text = element_text(size = 100))\n```\n\nEstos gráficos también posibilitan el agregado de otra capa geométrica, por ejemplo rectas de regresión para cada grupo según sexo.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) + \n  geom_point() + \n  geom_smooth(method = \"lm\")            # agregamos una segunda capa geométrica \n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n  geom_point()  + \n  geom_smooth(method = \"lm\") +            \n  theme(text = element_text(size = 100))\n```\n\nEsta función `geom_smooth()` posee distintos métodos y en este ejemplo utilizamos el de regresión lineal entre talla y peso junto a sus intervalos de confianza.\n\nA continuación vamos a ver que diferencias existen cuando `aes()` se encuentra dentro del `ggplot()` y cuando se ubica en otras capas de funciones como en `geom_point()`\n\nDecíamos anteriormente que al incorporar `aes()` al llamado de `ggplot()` estamos compartiendo la información estética en todas las capas.\n\nEntonces si quitamos `aes()` de allí y lo ubicamos en una capa única, esta configuración deja de afectar al conjunto del gráfico.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO)) + \n  geom_point(aes(color = SEXO)) + # color esta definido en el aes() \n                                  # de la capa geométrica\n  geom_smooth(method = \"lm\")\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO)) +\n  geom_point(aes(color = SEXO))  + \n  geom_smooth(method = \"lm\") +            \n  theme(text = element_text(size = 100))\n```\n\nEn este ejemplo, `aes()` para el color solo se ubica dentro de `geom_point()` y por lo tanto dibuja los puntos con sus respectivos colores, pero no afecta a la capa de `geom_smooth()` produciendo solo una línea de regresión para el conjunto de puntos.\n\nEs decir que `geom_smooth()` no recibe la orden de agrupar según SEXO, a raíz de no haber definido color dentro del `aes()` general.\n\nEste comportamiento nos permite gran versatilidad en los gráficos que realicemos.\n\nAlgunas otras funciones de **geom\\_** son:\n\n`geom_line()`, para líneas\n\n`geom_boxplot()`, para boxplot\n\n`geom_histogram()` para histogramas\n\n`geom_density()` para curvas de densidad\n\n`geom_bar()` para barras\n\nEstas funciones geométricas aplicadas sobre los mismos datos definen el tipo de gráfico.\n\nPara ejemplificar, podemos gráficar dos variables como SEXO y TALLA generando una base a la que sumaremos capas diferentes de `geom()`:\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, color = SEXO)) + \n  geom_point()                # capa geométrica de puntos\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, color = SEXO)) + \n  geom_point() +            \n  theme(text = element_text(size = 100))\n```\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, color = SEXO)) + \n  geom_boxplot()            # capa geométrica de boxplot\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, color = SEXO)) + \n  geom_boxplot() +            \n  theme(text = element_text(size = 100))\n```\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, color = SEXO)) + \n  geom_jitter()               # capa geométrica jitter (entramado de puntos)\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, color = SEXO)) + \n  geom_jitter()  +            \n  theme(text = element_text(size = 100))\n```\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_violin()            # capa geométrica de violin\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_violin() +            \n  theme(text = element_text(size = 100))\n```\n\nObservemos que en este último gráfico cambiamos, dentro de `aes()`, color por fill. Mientras que **color** define el color del contorno del polígono, la línea de una recta o curva y los puntos, **fill** define el relleno de los objetos como es el caso de los violines construidos o cualquier elemento geométrico de polígono.\n\n### Escalas (**scale**)\n\nLas configuraciones que se pueden realizar con **scale** son numerosas. Entre ellas encontramos cambios de color de contorno y relleno, cambios de posición, de tamaño y tipo de línea.\n\nEl argumento para modificar valores de escala comienzan siempre con con `scale_` (por ejemplo scale_fill\\_ )\n\nSigamos trabajando con el conjunto de datos leído para mostrar ejemplos de gráficos donde agregamos capas de escala para color de relleno. ( `scale_fill_brewer()` )\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_brewer(palette = \"Oranges\")   # paleta de los naranjas\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_brewer(palette = \"Oranges\") +           \n  theme(text = element_text(size = 100))\n```\n\nEn este ejemplo aplicamos una capa `scale_fill_brewer()` con una paleta de colores (Oranges) que se vincula con el argumento fill de `aes()` y definen los colores del boxplot.\n\nLo mismo hacemos para una gama de grises mediante `scale_fill_grey()`\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_grey(start = 0.4, end = 0.8)   # paleta de los grises\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_grey(start = 0.4, end = 0.8)  +           \n  theme(text = element_text(size = 100))\n```\n\nOtro uso de escalas, esta vez aplicado a los ejes, es la inversión del eje x.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n  geom_point() +\n  scale_x_reverse()     # escala inversa de x\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n  geom_point() +\n  scale_x_reverse() +           \n  theme(text = element_text(size = 100))\n```\n\nComo se observa en el gráfico la inclusión de `scale_x_reverse()` provoca que la escala x se invierta, quedando la TALLA ordenada de mayor a menor.\n\nPor último, otro ejemplo interesante es aplicado a escalas de etiquetado de ejes. Volvamos al ejemplo reciente de boxplot con relleno en escala de grises, su eje y se dibuja predeterminado desde 130 a casi 200 cms con cortes cada 5 cms y etiquetas cada 10 cms.\n\nCon escalas continuas manuales de la forma `scale_*_continuos()` podemos personalizar el eje y.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_grey(start = 0.4, end = 0.8)   +\n  scale_y_continuous(breaks = seq(130,200,2))\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_grey(start = 0.4, end = 0.8)   +\n  scale_y_continuous(breaks = seq(130,200,2)) +           \n  theme(text = element_text(size = 100))\n```\n\nEn este caso particular definimos un eje y con etiquetas de 2 en 2, mediante la línea `scale_y_continuous(breaks = seq(130,200,2))`\n\n### Transformaciones estadísticas (**stat**)\n\nAlgunos gráficos no requieren de transformaciones estadísticas, en cambio, otros como boxplot, histogramas, etc poseen valores predeterminados de **stat** que pueden ser modificados.\n\nEstos valores se encuentra en forma de argumentos dentro de la función geométrica, por ejemplo para los histograma el argumento **bins** define la cantidad de intervalos de clase.\n\n```{r,eval=FALSE}\nfacultad |> \n  ggplot(aes(EDAD)) +\n    geom_histogram(bins = nclass.Sturges(facultad$EDAD), fill = \"Blue\")\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(EDAD)) +\n    geom_histogram(bins = nclass.Sturges(facultad$EDAD), fill = \"Blue\") +           \n  theme(text = element_text(size = 100))\n```\n\nVemos que el gráfico se construyó utilizando la *regla de Sturges* para determinar la cantidad de intervalos de clase para la variable EDAD. (función `nclass.Sturges()`)\n\nOtras transformaciones estadísticas se incorporan como capas independientes, por ejemplo si queremos agregar los valores de media a los boxplot de talla según sexo construidos anteriormente.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_brewer(palette = \"Greens\") +\n  stat_summary(fun = mean, color = \"darkred\", geom = \"point\", \n               shape = 18, size = 3)\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, TALLA, fill = SEXO)) + \n  geom_boxplot() +\n  scale_fill_brewer(palette = \"Greens\") +\n  stat_summary(fun = mean, color = \"darkred\", geom = \"point\", \n               shape = 18, size = 3) +           \n  theme(text = element_text(size = 100))\n```\n\nAquí la capa completa surge a partir de la función `stat_summary()`, con argumentos que indican que se aplique la función `mean`. Incluye también la definición del objeto geométrico (point) que representa el valor de media (color, forma y tamaño)\n\n### Facetado (**facet**)\n\nCon `facet` es posible separar gráficos en distintas ventanas o viñetas, creando matrices de gráficos separados por grupos de datos, a partir de la estratificación, en función de diferentes categorías de una variable cualitativa.\n\nEste comportamiento es sumamente útil cuando tenemos más de una variable categórica o cuando deseamos utilizar color para simbolizar otra variable.\n\nggplot ofrece dos posibilidades de hacer el facetado:\n\n-   `facet_wrap()` – define subgrupos a partir de los niveles de una sola variable categórica\n\n-   `facet_grid()` – define subgrupos a partir del cruce de dos variables de categóricas.\n\nUna aplicación de `facet_wrap()` podría ser que el primer gráfico que hicimos de dispersión de puntos con las variables TALLA y PESO se visualice en dos gráficos distintos según cada categoría de SEXO.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n     geom_point() +\n     facet_wrap(~SEXO)\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(TALLA, PESO, color = SEXO)) +\n     geom_point() +\n     facet_wrap(~SEXO) +           \n  theme(text = element_text(size = 80))\n```\n\nUsamos `facet_grid()` para crear una matriz producto del cruce de las variables FUMA y SEXO.Dentro de la cuadrícula graficaremos histogramas de la variable PESO coloreados por SEXO.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(PESO, fill = SEXO)) +\n     geom_histogram(bins = nclass.Sturges(facultad$PESO)) +\n     scale_fill_brewer(palette = \"Set1\") +\n     facet_grid(SEXO ~ FUMA)\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(PESO, fill = SEXO)) +\n     geom_histogram(bins = nclass.Sturges(facultad$PESO)) +\n     scale_fill_brewer(palette = \"Set1\") +\n     facet_grid(SEXO ~ FUMA) +           \n  theme(text = element_text(size = 80))\n```\n\nSi observamos las 4 líneas que integran todas las capas del código de ggplot notaremos que estamos integrando varias de las funciones que fuimos mostrando.\n\nSe hace imposible generar todas combinaciones posibles dada la variedad y extensión de argumentos que posee el paquete. De todas formas, el objetivo de este material es entender la base de funcionamiento, es decir la estructura \"gramatical\" que proponen sus autores.\n\n### Sistema de coordenadas (**Coordinate Systems**)\n\nEn algunas ocasiones puede que necesitemos introducir modificaciones en el sistema de coordinadas predeterminado.\n\nSobre las coordenadas cartesianas iniciales se puede invertir la orientación para que, por ejemplo, las barras se dibujen horizontales.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip()   # invierte disposición de ejes\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip()  +           \n  theme(text = element_text(size = 100))\n```\n\n### Temas (**themes**)\n\nEl paquete ofrece un conjunto reducido de temas gráficos. El tema por defecto o inicial es `theme_gray()` pero se puede modificar a partir de agregar una capa de tema dentro de la estructura ggplot.\n\nA modo de ejemplo repetimos el último gráfico con el tema blanco y negro ( `theme_bw()` ):\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip() +\n     theme_bw()  # tema blanco y negro\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip() +\n     theme_bw()  +           \n  theme(text = element_text(size = 100))\n```\n\nOtro tema que podemos utilizar es `theme_dark()` que tiene un fondo gris oscuro.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip() +\n     theme_dark()\n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip() +\n     theme_dark() +           \n  theme(text = element_text(size = 100))\n```\n\nEl siguiente cuadro muestra el nombre y presentación de los temas que contiene el paquete.\n\n```{r,echo=F,  fig.align='center', out.width = \"40%\"}\nknitr::include_graphics(\"img/03/temas_ggplot.jpg\")\n```\n\nContinuando con cuestiones estéticas en otra capa se pueden definir etiquetas, como título, subtítulo y nombres de ejes.\n\nLa forma de la función con argumentos básicos es `labs( x = “Etiqueta X\", y = “Etiqueta Y\", title =“Título del gráfico\", subtitle = \"Subtítulo del gráfico\")`\n\nAdemás se utiliza la función `theme()` para configurar el tipo de fuente y tamaño, entre otras opciones posibles.\n\n```{r, eval=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip() +\n     labs(y = \"Cantidad\", title = \"Distribución de Sexo\") +\n     theme(plot.title=element_text(face=\"italic\", size=16)) \n```\n\n```{r, echo=FALSE, out.width=\"65%\", fig.align=\"center\", message=FALSE}\nfacultad |> \n  ggplot(aes(SEXO, fill = SEXO)) +\n     scale_fill_brewer(palette = \"Set2\") +\n     geom_bar() +\n     coord_flip() +\n     labs(y = \"Cantidad\", title = \"Distribución de Sexo\") +           \n  theme(text = element_text(size = 100),\n        plot.title=element_text(face=\"italic\", size=160))\n```\n\n### Paquete **esquisse**\n\n**Esquisse** es un paquete que contiene una aplicación asistente para crear gráficos **ggplot2** de forma interactiva. Basta con arrastrar y soltar las variables para asignarlas a diferentes estéticas.\n\nPodemos visualizar rápidamente los datos de acuerdo con su tipo, exportarlos en varios formatos y recuperar el código para reproducir el gráfico.\n\nEl paquete se instala mediante el menú Packages de RStudio o ejecutando:\n\n```{r, eval=F}\ninstall.packages(\"esquisse\")\n```\n\nLuego se puede acceder a la aplicación por medio del acceso Addins\n\n```{r,echo=F,  fig.align='center', out.width = \"70%\"}\nknitr::include_graphics(\"img/03/esquisse.PNG\")\n```\n\no ejecutando en consola `esquisser()`\n\nTambién se puede agregar el nombre de la tabla de datos dentro de los paréntesis\n\n```{r, eval=F}\nesquisser(datos)\n```\n\nPara más información consultar en la [viñeta](https://cran.r-project.org/web/packages/esquisse/vignettes/get-started.html) del paquete en CRAN.\n\n## Uniones en datos relacionales\n\nExisten situaciones donde debemos analizar datos que se encuentran en diferentes tablas.\n\nCon el fin de responder a nuestras preguntas de interés en ocasiones deberemos unirlas previamente.\n\nDe manera general, se le llama ***datos relacionales*** a esas múltiples tablas de datos que provienen muchas veces de sistemas de bases de datos construidas bajo el modelo relacional o bien cuando las tablas de datos tienen fuentes distintas pero comparten alguna variable común que permita \"conectarlas\".\n\nUn ejemplo recurrente sucede cuando necesitamos calcular la tasa de algún evento de salud y tenemos en una tabla el conteo (dato agregado) del evento (numerador) y en otra el conteo de la población en riesgo (denominador). \n\n### Tipos de operaciones\n\nPara trabajar con datos relacionales necesitamos de *funciones-verbos* que vinculen pares de tablas.\n\nLas tres familias de funciones del paquete **dplyr** diseñadas para trabajar con datos relacionales son:\n\n-   **Uniones de transformación** (del inglés *mutating joins*), agregan nuevas variables a una tabla a partir de observaciones coincidentes de otra tabla.\n\n-   **Uniones de filtro** (del inglés *filtering joins*), filtran observaciones de una tabla en función de la coincidencia o no coincidencia de otra tabla.\n\n-   **Operaciones en filas y columnas**, sirven para unir tablas por columnas o por filas.\n\n### Claves\n\n-   Las variables usadas para conectar cada par de variables se llaman **claves** (del inglés *key*)\n\n-   Una clave es una variable (o un conjunto de variables) que identifican de manera *única* una observación.\n\nExisten dos tipos de claves:\n\n-   Una **clave primaria** identifica únicamente una observación en su propia tabla.\n\n-   Una **clave foránea** únicamente identifica una observación en otra tabla.\n\nUna vez que identificadas las claves primarias en las tablas, es una buena práctica verificar que identifican de forma **única cada observación**. Una forma de hacerlo es usar `count()` con las claves primarias y buscar las entradas con n mayor a uno:\n\n```{r}\n#| eval: false\n\ndatos |> \n  count(clave_primaria) |> \n  filter(n > 1)\n```\n\nLa salida debería mostrar que no hay ninguna observación que cumpla la condición de n > 1, es decir todas las observaciones tienen una sola clave primaria unívoca.\n\nEn ocasiones podemos tener claves primarias compuestas por más de una variable. Tendremos que utilizar entonces esta combinación de variables a la vez en las uniones que realicemos.\n\nOtra situación inversa es no tener ninguna variable como clave primaria, aunque sepamos que cada observación pertenece a una misma unidad de análisis pero de elementos (sujetos, etc) diferentes. Aquí se puede usar la función `row_number()` que numera en orden ascendente las observaciones de la tabla y almacena esta numeración en una variable, creando una **clave subrogada**.\n\n```{r}\n#| eval: false\n\ndatos <- datos |> \n  mutate(clave = row_number()) \n```\n\n\n### Uniones de transformación\n\nLa forma más simple de unión es la unión interior (del inglés inner join). Una unión interior une pares de observaciones siempre que sus claves sean iguales.\n\n**Unión interior**\n\nUna unión interior mantiene las observaciones que aparecen en ambas tablas. La estructura del código sirve de base para las demás uniones:\n\n\n```{r}\n#| eval: false\n\ndatos_x |> \n  inner_join(datos_y, by = \"variable_clave\") \n```\n\n\n![](img/03/inner-join.PNG){fig-align=\"center\" width=50%}\n\nLa propiedad más importante de una unión interior es que las filas no coincidentes no se incluyen en el resultado\n\n**Uniones exteriores**\n\nUna unión exterior mantiene las observaciones que aparecen en al menos una de las tablas.\n\n-   Una unión izquierda (left join) mantiene todas las observaciones en x.\n\n![](img/03/left.png){fig-align=\"center\" width=50%}\n\n-   Una unión derecha (right join) mantiene todas las observaciones en y.\n\n![](img/03/right.png){fig-align=\"center\" width=50%}\n\n-   Una unión completa (full join) mantiene todas las observaciones en x e y.\n\n![](img/03/full.png){fig-align=\"center\" width=50%}\n\nEstas uniones funcionan agregando una observación “virtual” adicional a cada tabla. Esta observación tiene una clave que siempre coincide (de no haber otras claves coincidentes) y un valor que se llena con **NA**.\n\nOtra forma de ilustrar diferentes tipos de uniones es mediante un diagrama de Venn.\n\n\n![](img/03/venn.PNG){fig-align=\"center\" width=50%}\n\nSin embargo, tiene una limitante importante: un diagrama de Venn no puede mostrar qué ocurre con las claves que no identifican de manera única una observación.\n\n### Claves duplicadas\n\nHasta ahora todas las situaciones han asumido que las claves son únicas. Pero esto no siempre es así.  \n\nExisten dos posibilidades habituales:\n\n- Una tabla tiene claves duplicadas producto de una relación uno a varios.\n\n![](img/03/dupli-key.PNG){fig-align=\"center\" width=50%}\n\n- Ambas tablas tienen claves duplicadas (producto de una relación real varios a varios o por algún \"error\")\n\n![](img/03/dupli-key2.PNG){fig-align=\"center\" width=50%}\n\nSiempre que unimos claves duplicadas, obtenemos todas las posibles combinaciones, es decir, el producto cartesiano\n\n### Variables claves\n\nLa forma común del argumento `by =` donde se define/n la/s variable/s clave/s es igualarlo al nombre la variable o variables concatenadas con `c()` que deberán tener el mismo nombre en las dos tablas a unir.\n\nOtra maneras de conectar las tablas sería:\n\n- Sin definir `by =` o bien `by = NULL`, que de forma predeterminada utiliza todas las variables que se llamen de la misma forma (respetando mayúsculas y minúsculas). Esta se denomina **unión natural**.\n\n- Utilizar la función `join_by()` en el argumento `by =` que nos da la posibilidad de declarar cuales son las variables de unión cuando estas tengan nombres distintos en cada tabla.\n\n```{r}\n#| eval: false\n\ndatos_x |> \n  inner_join(datos_y, \n             by = join_by(var_clave_x == var_clave_y)) \n```\n\nObserven que la igualdad de las variables claves de **x** e **y** es un operador de comaparación `==`\n\nEn caso que hubiese más de una variable clave de unión se puede hacer:\n\n```{r}\n#| eval: false\n\ndatos_x |> \n  inner_join(datos_y, \n             by = join_by(var1_clave_x == var1_clave_y,\n                          var2_clave_x == var2_clave_y,)) \n```\n\n### Uniones de filtro\n\nLa función `semi_join()` mantiene todas las observaciones de la tabla **x** donde la **_clave coincide_** con la clave de la tabla **y**\n\n![](img/03/semi.png){fig-align=\"center\" width=50%}\n\nPara hacer lo inverso, `anti_join()` descarta todas las observaciones de la tabla **x** donde la **_clave coincide_** con la clave de la tabla **y**\n\n![](img/03/anti.png){fig-align=\"center\" width=50%}\n\n\n### Unión por filas y por columnas\n\nEn algunas ocasiones necesitamos unir tablas que tienen formatos particulares por medio de filas o por medio de columnas.\n\nLas funciones de **dplyr** para esta tarea son:\n\n- **bind_rows()** Une una tabla debajo de otra. Aplica cuando tenemos la misma estructura en tabla de datos divida en varios archivos (por ejemplo, producto de carga simultánea de datos en diferentes computadoras con diferentes data-entry)\n\n- **bind_cols()** Une una tabla al lado de la otra. Es peligroso su uso si la confundimos con las uniones de transformación porque perdemos integridad de datos en las observaciones. Sirve sólo si el \"orden\" de las observaciones pueden garantizar la misma identidad de las partes a unir.\n\n\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"link-external-filter":"^https:\\/\\/(raw|datos-ine|www)?\\.?(linkedin|twitter|github|githubusercontent)\\.*"},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"include-in-header":[{"text":"<link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n"}],"output-file":"03-introTidy.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"Contenido","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","theme":{"light":"../../custom.scss","dark":["darkly","../../custom_dark.scss"]},"code-copy":true,"anchor-sections":false,"bibliography":["../../references.bib"],"title":"**Tidyverse**","number_sections":true,"anchor_sections":true,"page-layout":"full","toc-title":"Contenidos","toc-location":"left","toc_float":true,"toc_collapsed":false,"toc_depth":4},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}