{
  "hash": "ea8ae88935ade7487809bcb3f73782bb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle:  \"**Lectura de un archivo de datos de texto plano**\"\nformat:\n  html:\n    page-layout: full\n    include-in-header: \n      - text: |\n          <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">    \n    toc: true\n    toc-title: Contenidos\n    toc-location: left\n    toc_float: true\n    toc_collapsed: false\n    toc_depth: 4\nnumber_sections: true\nanchor_sections: true\n---\n\n\n\n\n\n\n## Introducción\n\nAnteriormente dijimos que para leer o importar datos de un archivo de datos con texto plano separado por comas vamos a utilizar alguna de las funciones del paquete **readr** del tidyverse.\n\nPero para saber cual es la función adecuada y para adaptar sus argumentos correctamente vamos a necesitar conocer la configuración del archivo de datos.\n\nEn este paso a paso, mostraremos las etapas a ejecutar ante una situación de lectura.\n\nEn primer lugar, es deseable que conozcamos previamente los archivos con los cuales trabajamos, o bien si son archivos de datos que se reciben de alguna fuente externa vengan acompañados de un diccionario de datos con especificaciones técnicas del propio archivo como de sus variables.\n\nUn ejemplo de esto es el detalle técnico de la tabla de datos que figura en el documento usuario de la **Encuesta Nacional de Factores de Riesgo** que vemos debajo:\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](img/02/enfr.PNG){fig-align='center' width=60%}\n:::\n:::\n\n\n\nEsta información nos dice que el archivo es de texto plano, utiliza como delimitador de columna a la barra vertical, que la primera línea lleva los nombres de las variables y que la codificación (encoding) de los caracteres tiene el estándar UTF-8.\n\nEn función de estos datos podríamos componer nuestra lectura de la siguiente forma:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenfr <- read_delim(file = \"ENFR2013_base_usuario.txt\", \n                   delim = \"|\", \n                   locale = locale(encoding = \"UTF-8\"))\n```\n:::\n\n\n\nAunque es el estándar predeterminado, completamos el argumento del encoding a propósito para mostrar como se vincula cada parte de la función con la información del archivo de datos.\n\nSi no llegasemos a disponer de esta información es muy posible que debamos investigar el archivo que deseamos importar para saber sus características.\n\nEn este documento utilizaremos el archivo **def2022.csv** con las defunciones del año 2022 producido por la DEIS.\n\n## Separador o delimitador de columnas\n\nLa primera cosa que podemos hacer con un archivo de texto plano es abrirlo con un software tipo block de notas o con el mismo RStudio para saber cual es el caracter que utiliza como separador de columnas. \n\nCuando el archivo tiene extensión csv generalmente el separador puede ser coma o punto y coma. Pero recién vimos que la extensión puede ser txt y el separador, alguno de los caracteres habituales (espacio, tabulación, etc).\n\nDesde **RStudio**, cuando se pulsa el botón izquierdo del mouse sobre el archivo de datos que aparece en el panel *Files*, se abre una ventana emergente que nos ofrece la posibilidad de visualizarlo en el editor (*\"View File\"*). Si el archivo es muy pesado (mayor a 5 Mb) RStudio nos avisará que no lo puede hacer porque excede su capacidad, entonces deberemos hacerlo desde un programa similar al **Block de Notas** de Windows que trabaja con texto plano. \n\nVeríamos algo así:\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](img/02/visor.PNG){fig-align='center' width=90%}\n:::\n:::\n\n\n\nPodemos identificar claramente que el caracter que se repite como delimitador es la coma (,). Si hubiese datos numéricos con decimales, también es importante identificar cual es el separador de decimales (en los casos de delimitadores de columna con coma se utiliza el punto para los decimales).\n\nTambién se puede advertir que la primera línea corresponde a los nombres de las columnas (variables) de nuestra tabla de datos.\n\nCon esta información seleccionaremos como función de lectura a `read_csv()` que tiene estos valores de separadores como predeterminados.\n\n## Encoding\n\nPara conocer cual es la codificación del archivo podemos usar una función del paquete **readr**, llamada `guess_encoding()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nguess_encoding(\"datos/def2022.csv\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  encoding   confidence\n  <chr>           <dbl>\n1 ISO-8859-1       0.52\n```\n\n\n:::\n:::\n\n\n\nEl resultado nos informa del estándar ISO-8859-1 con una confianza del 52 %. Existen muchos estandares como posibilidad en el mundo informático, aunque el predeterminado de RStudio es el UTF-8.\n\nA partir de tener esta información podemos configurar el argumento necesario para hacer una lectura correcta de los caracteres especiales que puede tener el archivo.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndef2022 <- read_csv(\"datos/def2022.csv\", \n                 locale = locale(encoding = \"ISO-8859-1\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 397115 Columns: 28\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (20): JURI, MEDSUS, CODMUER, FECDEF, FECNAC, DEPOC, PROVOC, DEPRES, PROV...\ndbl  (8): ANO, ATENMED, EDAD, UNIEDAD, SEXO, OCLOC, PAISRES, ASOCIAD\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\nLa ejecución de la función nos confirma que se realizó usando:\n\n- la coma como delimitador. \n- que se importaron 397115 filas y 28 columnas. \n- detectó 20 variables de tipo character y 8 numéricas (double)\n\nVeamos 10 observaciones para verificar la lectura:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 28\n   JURI    ANO ATENMED MEDSUS CODMUER FECDEF    FECNAC  EDAD UNIEDAD  SEXO OCLOC\n   <chr> <dbl>   <dbl> <chr>  <chr>   <chr>     <chr>  <dbl>   <dbl> <dbl> <dbl>\n 1 02     2022       1 1      J189    04/01/20… 03/05…    83       1     2     1\n 2 02     2022       1 1      I509    01/11/20… 02/05…    68       1     1     1\n 3 02     2022       1 1      G409    12/06/20… 22/09…     1       1     2     2\n 4 02     2022       1 2      J129    22/12/20… 31/10…    90       1     2     2\n 5 02     2022       1 1      K746    28/09/20… 26/02…    65       1     1     2\n 6 02     2022       1 1      C700    12/06/20… 25/02…    48       1     2     2\n 7 02     2022       1 2      I470    27/03/20… 09/09…    89       1     1     2\n 8 02     2022       1 2      F03X    05/02/20… 14/09…    97       1     2     2\n 9 02     2022       1 2      I470    30/01/20… 08/07…    71       1     2     1\n10 02     2022       1 1      J189    28/09/20… 21/09…    91       1     1     2\n# ℹ 17 more variables: DEPOC <chr>, PROVOC <chr>, DEPRES <chr>, PROVRES <chr>,\n#   PAISRES <dbl>, ASOCIAD <dbl>, FINSTRUC <chr>, FSITLABOR <chr>,\n#   MINSTRUC <chr>, MEDAD <chr>, MSITCONY <chr>, PINSTRUC <chr>,\n#   SITLABOR <chr>, PESONAC <chr>, PESOMOR <chr>, TIEMGEST <chr>,\n#   GRUPEDAD <chr>\n```\n\n\n:::\n:::\n\n\n\nHacer coincidir el encoding del archivo con el definido en la lectura hace que los caracteres se importen adecuadamente y no tengamos inconvenientes con caracteres especiales como vocales acentuadas, eñes u otras situaciones.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}