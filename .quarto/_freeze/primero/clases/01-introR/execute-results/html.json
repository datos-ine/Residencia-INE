{
  "hash": "564b151589172f707d45fcd1c0dd3e82",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"**Introducción al lenguaje R**\"\nformat:\n  html:\n    page-layout: full\n    toc: true\n    toc-title: Contenidos\n    toc-location: left\n    toc_float: true\n    toc_collapsed: false\n    toc_depth: 4\n    include-in-header: \n      - text: |\n          <link rel=\"icon\" type=\"image/x-icon\" href=\"img/favicon.ico\">\nnumber_sections: true\nanchor_sections: true\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n## Qué es el lenguaje R?\n\nEl sitio oficial [r-project.org](https://www.r-project.org/) dice que *\"R es un entorno de software libre para gráficos y computación estadística. Se compila y se ejecuta en una amplia variedad de plataformas UNIX, Windows y MacOS.”.* \n\nProfundizando en su descripción podemos decir, técnicamente, que es un __*lenguaje de programación interpretado, orientado a objetos, multiplataforma y open source aplicado al manejo de datos estadísticos.*__\n\nA continuación detallamos cada parte de la definición:\n\n**R es un lenguaje de programación estadístico**\n\nR es un lenguaje de programación, con sus estructuras y reglas de sintaxis, que posee una gran variedad de funciones desarrolladas con fines estadísticos.\n\n**R es un lenguaje Orientado a Objetos**\n\nImplementa conceptos de la programación orientada a objetos y esto\nle permite ser simple y flexible en el manejo de datos. En R\ntodo con lo que trabajamos es considerado un \"objeto\": las variables, funciones, datos, resultados, etc. que pueden ser modificados por otros objetos.\n\n**R es un lenguaje interpretado**\n\nNo es necesario compilar los scripts de programación para construir\nejecutables sino que directamente se ejecutan por medio del intérprete que  devuelve resultados de forma inmediata.\n\n**R es multiplataforma (corre en Linux, Windows y Mac)**\n\nFunciona en diferentes sistemas operativos como Linux, Windows y Mac. \n\n**R es Open Source y se distribuye bajo licencia GNU - GPL**\n\nEsto quiere decir que se distribuye gratuitamente bajo licencia GNU\n(General Public License) -- GPL y que los usuarios tienen la libertad de\nusar, estudiar, compartir (copiar) y modificar el software.\n\n## Breve historia \n\nR fue desarrollado a partir del lenguaje S que tiene sus orígenes en Bell Labs de la AT&T (actualmente Lucent Technologies) de mediados de la década del '70. Posteriormente, S fue vendido y dio origen a una versión propietaria denominada S-Plus que es comercializada por Insighful Corporation.\n\nEn 1995 dos profesores de estadística de la Universidad de Auckland, en\nNueva Zelanda [Ross Ihaka](https://en.wikipedia.org/wiki/Ross_Ihaka) y [Robert Gentleman](https://en.wikipedia.org/wiki/Robert_Gentleman_(statistician)), iniciaron el [\"Proyecto\nR\"](https://en.wikipedia.org/wiki/R_(programming_language)), con la intención de desarrollar un programa estadístico inspirado en el lenguaje S pero de dominio público.\n\nAunque se dice que R es un dialecto de S existen diferencias importantes\nen el diseño de ambos lenguajes.\n\nEl software está desarrollado en lenguaje C++ con algunas rutinas\nagregadas en Fortran) y su nombre se debe a la letra con la que inician\nlos nombres de pila de sus autores (Ross y Robert).\n\nActualmente es mantenido por un grupo internacional de desarrolladores\nvoluntarios denominado [Core Development Team](https://www.r-project.org/contributors.html).\n\n## Scripts\n\nUn script es un archivo de texto plano con una lista secuencial de\nfunciones y comandos del lenguaje R para ser ejecutado por el intérprete\nde R.\n\nScript se puede traducir como guión, archivo de órdenes, archivo de\nprocesamiento por lotes o archivo de sintaxis.\n\nGeneralmente se crea en editores especiales y/o en cualquier procesador básico de texto plano. Se almacena en un archivo que puede ser leído,\nmodificado, guardado y se puede ejecutar completo o línea a línea.\n\nPoseen una cualidad muy provechosa: son re-utilizables, adaptándolos a\notras necesidades.\n\n**Documentación de los scripts de R:**\n\nLa documentación es una tarea de mucha importancia en cualquier lenguaje\nde programación, ya que nos permite entender que estamos haciendo en el\nscript. Además nos sirve para el futuro mantenimiento o para la\nreutilización del código elaborado, tanto para otros usuarios como para\nnosotros mismos.\n\nLa forma de documentar los scripts de código en R es utilizando\ncomentarios. Toda línea que comienza con el símbolo `#` es entendido por\nel interprete como un comentario y los caracteres que sigan a ese\nsímbolo no seran tenidos en cuenta cuando se ejecute ese código.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# esto es una línea de comentario y no es tenida en cuenta por el intérprete\n```\n:::\n\n\n\nAsí que a la hora de documentar es preferible abusar de estos\ncomentarios que no utilizarlos.\n\n## Funciones\n\nLos comandos u órdenes elementales de R se denominan **funciones**. A algunas se las llama \"integradas\" porque están incluidas en el núcleo (R base) y sus nombres están reservados.\n\nTambien podemos utilizar otras pertenecientes a librerías (paquetes) que se pueden instalar y activar.\n\nToda función tiene un nombre y normalmente recibe argumentos o\nparámetros que deben ser escritos **entre paréntesis y separados por comas**. Incluso algunas de ellas que no tienen asociado ningún argumento necesitan finalizar con paréntesis `()` para ser entendidas como funciones.\n\nSiempre una función devuelve un resultado, un valor o realiza una\nacción.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](img/01/funciones.JPG){fig-align='center' width=50%}\n:::\n:::\n\n\n\nComo el interprete de R no permite errores en la sintaxis de las expresiones, debemos atender a los siguientes puntos a la hora de escribirlas:\n\n-   La sintaxis habitual de una función y sus argumentos es la siguiente:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfuncion(arg1, arg2, arg3,...)\n```\n:::\n\n\n\n-   Los títulos de los argumentos pueden escribirse y mediante un igual\n    agregar el valor correspondiente. También se puede omitir el título\n    del argumento y escribir directamente el valor, pero en este caso,\n    hay que respetar el orden definido por la función.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfuncion(arg1=32, arg2=5, arg3=65,...)\n```\n:::\n\n\n\nes igual a hacer:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfuncion(32, 5, 65,...)\n```\n:::\n\n\n\nsiempre que se respete el mismo orden.\n\n-   Con los argumentos se deben cumplir las mismas reglas que en todo el\n    lenguaje. Los valores numéricos, lógicos, especiales y objetos van\n    escritos en forma directa y cuando escribimos caracteres (texto) van\n    necesariamente encerrados entre comillas.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfuncion(arg1=3, arg2=NA, arg3=TRUE, arg4=\"less\", arg5=x,...)\n```\n:::\n\n\n\n## Librerías (paquetes)\n\nLas librerías son grupos de funciones empaquetados que se pueden\ninstalar y utilizar en el análisis de datos. Habitualmente se agrupan\npor tema o similitud de funciones.\n\nEstos paquetes se pueden descargar directamente del repositorio oficial\nde CRAN en Internet (similar al uso de los repositorios de Linux) o bien\ndescargar en formato .zip para luego instalar y usar.\n\nSe pueden activar y desactivar en cualquier momento del análisis.\n\nAlgunos poseen dependencias de otros paquetes que serán necesarios para\nque funcione.\n\n## Sintaxis, errores y advertencias\n\nEl lenguaje es muy preciso en su sintaxis y equivocarse en la forma de escribir una función o cualquier otro objeto produce respuestas de error del interprete de R que es habitual cuando iniciamos el aprendizaje.\n\nLa exactitud en la escritura de comandos y funciones incluye la\ndistinción entre mayúsculas y minúsculas. Es decir, que no es lo mismo una 'a' que una 'A'.\n\nExisten tres grupos de mensajes de error:\n\n- error de sintaxis\n- error de objeto no encontrado\n- otros errores\n\nSe dice que hay un error de sintaxis, cuando ejecutamos una línea de código que el motor de R no puede interpretar debido a que algo está mal escrito.\n\nHabitualmente los errores de sintaxis se deben a que falta o sobra algún elemento necesario en la estructura de una función (comas, parentesis, llaves, corchetes, comillas, etc.)\n\nPor ejemplo la función `rep()` repite valores una cantidad de veces. Tiene dos argumentos, `x` donde se coloca el valor a repetir y `times` donde se define la cantidad de veces.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(x = 3, times = 4) #repetimos 4 veces 3 con rep()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 3 3 3\n```\n\n\n:::\n:::\n\n\n\nSi nos olvidamos de cerrar el paréntesis...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(x = 3, times = 4\n    \nError: Incomplete expression: rep(x = 3, times = 4\n```\n:::\n\n\nSi nos olvidamos de separar los argumentos con la coma\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(x = 3 times = 4)\n\nError: unexpected symbol in \"rep(x =3 times\"\n```\n:::\n\n\nSi en lugar de escribir x como primer argumento y escribimos otra letra...\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(y =3, times = 4)\n\nError in rep(y = 3, times = 4) : \n  attempt to replicate an object of type 'symbol'\n```\n:::\n\n\nSi escribimos mal la función...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nREP(x =3, times = 4)\n\nError in REP(x = 3, times = 4) : no se pudo encontrar la función \"rop\"\n```\n:::\n\n\nEsta última posibilidad es similar a un \"objeto no encontrado\" por **error de sintaxis**.\n\nLos mensajes de error en general y sobre todo al principio pueden parecer extraños y difíciles de entender, pero con un poco de práctica podemos inferir donde está el problema.\n\nLos errores de **objetos no encontrados** pueden tener una de varias causas:\n\n- el nombre no se escribió correctamente (p.ej.: sintaxis, mayúsculas / minúsculas)\n- el paquete o archivo que contiene el objeto no ha sido cargado\n- olvidamos poner comillas en un lugar que corresponde \n- otros motivos posibles\n\nVolvamos al ejemplo anterior, ahora repitiendo un valor tipo character\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(x = \"A\", times = 4) #repetimos 4 veces 3 con rep()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A\" \"A\" \"A\" \"A\"\n```\n\n\n:::\n:::\n\n\nSi olvidamos las comillas...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(x = A, times = 4) #repetimos 4 veces 3 con rep()\n\nError: objeto 'A' no encontrado\n```\n:::\n\n\n\n**Advertencias**\n\nUna advertencia no es algo tan serio, como un error, o al menos no lo parece, ya que esta permite que la función se ejecute igual. Pero puede ocurrir que ignorar una advertencia llegue a ser algo muy serio, si esto implica que la salida de la función es equivocada.\n\nPor lo tanto, es una buena política entender los mensajes de advertencia para ver si indican problemas para preocuparnos o no.\n\nResumiendo:\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](img/01/errores_advertencias.PNG){fig-align='center' width=60%}\n:::\n:::\n\n\n\n\n## Creación de objetos \n\nTodas las declaraciones donde se crean objetos, tienen este símbolo de asignación `<-`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnombre_objeto <- valor\n```\n:::\n\n\n\nVeámoslo en un ejemplo:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1\n```\n:::\n\n\n\nEn este caso asignamos el valor 1 al objeto `a`. El objeto `a` es un vector de una posición (un solo valor).\n\nSi llamasemos al objeto `a`, el interprete nos devuelve el valor\nasignado previamente.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\nObservemos que además de devolvernos el valor aparece delante un 1 entre corchetes `[1]`.Este número es la ubicación o índice del comienzo del objeto, que en este caso tiene una sola posición. \n\n\n\n## Estructuras de datos\n\nLos objetos *contenedores de datos* más simples pertenecen a **cinco\nclases** que se denominan *atómicas* y que son los siguientes tipos de\ndatos:\n\n-   integer (números enteros)\n-   numeric / double (números reales)\n-   complex (números complejos)\n-   chacacter (cadena de caracteres)\n-   logical (lógicos o booleanos -- toman valores por si o no)\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](img/01/tipo_datos.JPG){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\nSin embargo, cada una de estas clases de datos no se encuentran de\nmanera aislada, sino encapsulados dentro de la clase de objeto\noperacional más básica del lenguaje a la que se denomina **vector**.\n\n**Vector**\n\nUn vector es un conjunto de valores (números o símbolos), todos del\nmismo tipo ordenados de la forma (elemento 1, elemento 2, ... , elemento\n$n$) y $n$ es la longitud o tamaño del vector.\n\nSurge de la definición dos términos importantes: el tipo y la longitud.\n\nTodos los objetos de datos tienen estos dos atributos intrínsecos.\n\n-   el tipo, que puede ser integer, numeric, chacacter, complex y\n    logical\n-   la longitud, que es el número de elementos que contiene el objeto.\n\nEl vector más simple es el que contiene un dato, podría ser numérico de\nun solo dígito. El tipo sería numeric y la longitud 1.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec1 <- 1\nvec1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\nOtro vector más grande por ejemplo podría ser (1,5,2). En este caso\ntambién es del tipo numeric pero tiene una longitud de 3 elementos (3\nposiciones que integran el vector).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec2 <- c(1,5,2)\nvec2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 5 2\n```\n\n\n:::\n:::\n\n\n\nComo vemos, para concatenar estos tres valores numéricos usamos la forma\n`c()`. Esta `c` es una función de R, justamente para concatenar. (todo\nlo que aparece siempre antes de paréntesis es una función). Dentro de la\nfunción los valores van separados por comas.\n\nAquí podemos señalar otra característica, según la definición de vector,\nla colección de elementos se encuentra ordenada, por lo que en nuestro\nejemplo la primera posición la ocupa el 1, la segunda el 5 y la tercera\nel 2. Como el orden importa, si tuviese otro vector (5,1,2), a pesar de\ntener los mismos elementos no sería el mismo vector porque están\nordenados de forma diferente.\n\nPara ver la longitud del vector usamos:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(vec2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\nNos informa que `vec2` tiene 3 elementos.\n\nAsimismo podemos ver que los datos almacenados en este segundo ejemplo\ncumplen con la definición en lo que respecta al tipo de dato, ya que\ncada elemento es del mismo tipo (numeric).\n\nPara conocer la clase del dato ejecutamos:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(vec2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\nVeamos un ejemplo de asignación de otro tipo de dato atómico, como es el\ncharacter:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec3 <- \"Hola\"\nvec3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hola\"\n```\n\n\n:::\n:::\n\n\n\nSiempre que escribamos contenido de tipo caracter debemos hacerlo entre\ncomillas. En este caso generamos el vector `vec3` con el contenido\n\"Hola\". A pesar de ser una palabra que, por supuesto, esta compuesta de\nvarios caracteres, dentro del vector `vec3` esta ocupa una sola\nposición.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(vec3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\nRespecto a la clase del dato si usamos la función `class()` tendremos:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(vec3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n**Dataframe**\n\nUn dataframe es un objeto cuya finalidad es contener conjuntos de datos.\nSe asemeja a una tabla que tiene filas y columnas (dos\ndimensiones), donde cada columna puede almacenar\nelementos de diferentes tipos.\n\nAdemás las columnas suelen tener nombres únicos y podemos referenciarlas\npor estos nombres, como si fueran variables del conjunto de datos.\n\nEs el tipo de objeto que utilizamos para almacenar información leída de\ntablas de datos provenientes de archivos externos (formato texto\nseparado por comas, Excel, etc) y con las cuales acostumbramos a\ntrabajar en el análisis.\n\nDesde el punto de vista de su estructura, todo dataframe esta conformado\npor una serie de vectores de la misma longitud ubicados verticalmente\nuno al lado de otro.\n\nPodemos verlo en la siguiente porción de código:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHC <- c(\"F324\", \"G21\", \"G34\", \"F231\")\nedad <- c(34,32,34,54)\nsexo <- c(\"M\", \"H\", \"H\", \"M\")\n\ndf1 <- data.frame(HC, edad, sexo)\n\ndf1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    HC edad sexo\n1 F324   34    M\n2  G21   32    H\n3  G34   34    H\n4 F231   54    M\n```\n\n\n:::\n:::\n\n\n\nCreamos tres vectores con datos de supuestos individuos, su historia\nclinica, la edad y el sexo. Luego mediante la función `data.frame()`\n\"unimos\" esos vectores en forma vertical para formar un dataframe de 3\nvariables y 4 observaciones.\n\nExisten otras estructuras de datos que aparecen en la siguiente figura. Las más habituales en nuestro trabajo son los vectores y los dataframes.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](img/01/objetos_R.png){fig-align='center' width=55%}\n:::\n:::\n\n\n\n## Videos sobre Objetos\n\n\n\n{{< video https://youtu.be/JK4o_dnhyIQ?si=PFCQGww4vvieQGdJ >}}\n\n\n{{< video https://youtu.be/UCOCMdXzbo0?si=vtzC_thJvh3ZaDzh >}}\n\n\n\n\n\n## Operadores en R\n\nAdemás de funciones, el lenguaje R cuenta con operadores similares a otros lenguajes de programación, que permiten realizar operaciones con datos.\n\n### R como calculadora\n\nEl lenguaje R cuenta con operadores aritméticos de uso relativamente intuitivo, que permiten realizar operaciones matemáticas como si usasemos una calculadora.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](img/01/op_aritmeticos.JPG){fig-align='center' width=45%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# suma\n2 + 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\n# resta\n3 - 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n# multiplicación\n9 * 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 27\n```\n\n\n:::\n\n```{.r .cell-code}\n# división\n10 / 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\n# potenciación\n5 ^ 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n:::\n\n\n\n**Nota**: observarán que el interprete del lenguaje al devolvernos un valor en consola lo muestra con una notación inicial de un 1 encerrado entre corchetes `[1]`.\nEste número es el índice del vector que nos está mostrando R y que siempre comienza con 1. Si la cantidad de elementos de un vector mostrados por la consola superase el ancho de la pantalla, entonces el listado seguiría debajo y al comienzo de la nueva línea veríamos otro número entre corchetes que sería el indice de ese primer valor. Veamos un ejemplo:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.10 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.20 0.21 0.22 0.23 0.24\n[16] 0.25 0.26 0.27 0.28 0.29 0.30 0.31 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.39\n[31] 0.40 0.41 0.42 0.43 0.44 0.45 0.46 0.47 0.48 0.49 0.50 0.51 0.52 0.53 0.54\n[46] 0.55 0.56 0.57 0.58 0.59 0.60 0.61 0.62 0.63 0.64 0.65 0.66 0.67 0.68 0.69\n[61] 0.70 0.71 0.72 0.73 0.74 0.75 0.76 0.77 0.78 0.79 0.80 0.81 0.82 0.83 0.84\n[76] 0.85 0.86 0.87 0.88 0.89 0.90\n```\n\n\n:::\n:::\n\n\nEl 0.25 que es primer valor de la segunda fila esta en la posición 16 de ese vector de números. Y, por ejemplo, el 0.70 en la posición 61.\n\nPara otras operaciones matemáticas como la raíz cuadrada o el valor absoluto de un múmero, existen funciones específicas incluídas en R base.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# radicación (raíz cuadrada)\nsqrt(9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# valor absoluto\nabs(-3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\nTambién se pueden hacer operaciones con los objetos que almacenan a estos valores numéricos asignados:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# a contiene el valor 3\na <- 3\n\n# b contiene el valor 6\nb <- 6\n\n# aplicamos una fórmula determinada\n(a + b) * b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 54\n```\n\n\n:::\n:::\n\n\n\nY funciona con objetos como los vectores que contienen más de un elemento, aplicando **artimética vectorial**, donde las operaciones se realizan elemento a elemento.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# creamos el vector a con 3 elementos\na <- c(1, 2, 3)\n\n# ejecutamos una operación matemática a todos los elementos de a\na * 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 6 9\n```\n\n\n:::\n:::\n\n\n\nO bien, con operaciones entre objetos, donde se las operaciones se realizan entre los elementos de la misma posición:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# creamos el vector a con 3 elementos\na <- c(1, 2, 3)\n\n# ejecutamos una operación matemática a todos los elementos de a * a\na * a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 4 9\n```\n\n\n:::\n:::\n\n\n\nMediante `sum()` se puede hacer sumatorias de elementos en  vectores numéricos.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# creamos el vector a con 3 elementos\na <- c(1, 2, 3)\n\n# realizamos una sumatoria de todos los elementos de a\nsum(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n\nOtra función muy utilizada es la que permite que redondeemos valores con decimales.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## redondeamos definiendo 2 digitos decimales\n\nround(23.76859, digits = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 23.77\n```\n\n\n:::\n:::\n\n\n\n\n## Concatenación y secuencias regulares\n\nYa usamos la función `c()` para concatenar elementos. Habitualmente cuando  deseemos crear vectores con más de un elemento vamos a recurrir a esta función.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# vector numérico de 4 elementos\nc(6, 3, 6, 8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6 3 6 8\n```\n\n\n:::\n\n```{.r .cell-code}\n# vector caracter de 2 elementos\nc(\"Hola\", \"Chau\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hola\" \"Chau\"\n```\n\n\n:::\n:::\n\n\n\nExiste otra forma de concatenar elementos a partir de un operador de rango.\nProduce un intervalo secuencial de enteros que puede ser ascendente o descendente.\nEl operador es `:` y se usa de la siguiente forma:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ascendente\n1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n# descendente\n10:1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 10  9  8  7  6  5  4  3  2  1\n```\n\n\n:::\n:::\n\n\n\nOtra manera es por medio de la función `seq()` que tiene como argumentos principales *from*, *to* y *by*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# secuencia de 1 a 20 cada 2\nseq(from = 1, to = 20, by = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  3  5  7  9 11 13 15 17 19\n```\n\n\n:::\n:::\n\n\n\nAlgunos otros ejemplos de la misma función pueden ser:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# secuencia de 0.1 a 0.9 cada 0.1\nseq(from = 0.1, to = 0.9, by = 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9\n```\n\n\n:::\n\n```{.r .cell-code}\n# secuencia de -5 a 5 cada 1\nseq(from = -5, to = 5, by = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n```\n\n\n:::\n\n```{.r .cell-code}\n# secuencis de 300 a 0 cada 50 (se escribe -50 porque es descendente)\nseq(from = 300, to = 0, by = -50)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 300 250 200 150 100  50   0\n```\n\n\n:::\n:::\n\n\n\nFinalmente la última posibilidad que vamos a mostrar es la función `rep()` que repite valores. Su forma más sencilla es `rep(x, times = Nº)` que coloca un Nº de repeticiones de x, una tras otra.\n\nAlgunos ejemplos de la función:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# repetimos 5 veces el número 2\nrep(x = 2, times = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2 2 2 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# combinada con el operador de rango\nrep(1:4, 5)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\n# combinada con la función de concatenación\nrep(c(4.5,6.8,7.2), 2) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.5 6.8 7.2 4.5 6.8 7.2\n```\n\n\n:::\n:::\n\n\n\n\nTambién existen **operadores relacionales** y **conectores lógicos** que vamos a ver más adelante, cuando por ejemplo, necesitemos construir condiciones para filtrar subconjuntos de datos.\n\n## Valores especiales en R\n\nExisten algunos valores especiales para datos con expresiones reservadas\nen R, entre ellos encontramos los valores NA, NaN, Inf y NULL.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](img/01/valores_esp.JPG){fig-align='center' width=60%}\n:::\n:::\n\n\n\n\nEl más relevante de estos valores especiales es el NA que sirve para\nindicar la inexistencia de valor.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}