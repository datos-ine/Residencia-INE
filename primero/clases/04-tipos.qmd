---
title: "**Gestión de tipos de datos**"
format:
  html:
    page-layout: full
    include-in-header: 
      - text: |
          <link rel="icon" type="image/x-icon" href="favicon.ico">  
    toc: true
    toc-title: Contenidos
    toc-location: left
    toc_float: true
    toc_collapsed: false
    toc_depth: 4
number_sections: true
anchor_sections: true
---

![](img/04/types.png){fig-align="left" width=30%}

## Exploración de datos

El primer paso en la exploración de un conjunto de datos es conocer su estructura y tamaño.

El tamaño está definido por la cantidad de observaciones (filas) y la cantidad de variables (columnas).

Llamamos estructura a la forma en se organizan sus variables, sus tipos de datos y sus categorías/valores.

```{r, echo = F, message=FALSE, warning=FALSE}
library(tidyverse)
library(readxl)

datos <- read_excel("datos/datos_demo.xlsx", 
                    col_types = c("numeric", "text", "numeric", "numeric", "numeric", "logical", "date")) %>% 
  mutate(fecha = as.Date(fecha),
         id = as.integer(id))
datos <- as.data.frame(datos)
```

Vamos a utilizar un dataframe de ejemplo con variedad en sus tipos de datos. Para ver su estructura en R base tenemos la función `str()`

```{r}
str(datos)
```

Nos informa que la tabla tiene 74 observaciones y 7 variables con su tipo de dato al lado.

En R base los tipos de datos son:

-   **int** (integer): números enteros
-   **num** (numeric): números reales
-   **chr** (character): caracteres (texto)
-   **logi** (logical): valores lógicos
-   **Date**: fechas
-   **fct** (factor): factores

En tidyverse, la función que reemplaza a str() es `glimpse()`:

```{r}
glimpse(datos)
```

Parece idéntica pero tiene una ventaja cuando la tabla de datos tiene muchas variables. La lista de respuesta de str() se trunca y no nos deja visualizar la totalidad de columnas, cosa que si hace glimpse().

Por otra parte vamos a encontrar distintas definiciones para los tipos de datos, del modo tidyverse:

-   num para a ser **dbl** (double): números reales
-   logi para a ser **lgl** (logical): valores lógicos

Y se incluyen un tipo nuevo:

-   **dttm** (date-time): fechas y horas

Esta exploración inicial de la estructura generalmente viene acompañada por el "diccionario de datos" (codebook) asociado a la tabla de datos, ya sea que esta tabla provenga de un proyecto de investigación propio (fuente primaria), producto de una fuente secundaria o de un sistema de vigilancia epidemiológica.

## Comprobación y coerción de tipos de datos

La mayoría de las funciones producen un error cuando el tipo de datos que esperan no coincide con los que pasamos como argumentos. En esta situación seguiremos el siguiente camino:

-   Comprobar el tipo de datos utilizando las funciones `is.*()`, que nos responden con un valor lógico (TRUE si el tipo de dato coincide y FALSE si no lo hace). Si el tipo de dato coincide con el formato esperado por el argumento de la función, entonces podemos aplicarla, de lo contrario necesitaremos continuar:

-   Forzar el tipo de datos deseado coercionando con funciones de la familia `as.*()`, que fuerzan el tipo de datos, siempre y cuando esto devuelva valores correctos. Por ejemplo, no podremos obtener valores correctos si intento coercionar caracteres a tipos numéricos.

```{r}
# Ejmeplo coercionando la variable sexo de caracter a factor

as.factor(datos$sexo) # llamamos a la variable con el formato <dataframe>$<variable>

# detecta que hay dos niveles o categorías posibles (F y M) 

is.factor(as.factor(datos$sexo))

# nos confirma que los datos se coercionaron a factor
```

-   Transformar el tipo de dato a partir de aplicar funciones específicas incluidas en paquetes que gestionan datos especiales, como por ejemplo las fechas (el paquete *lubridate* del tidyverse, que conoceremos más adelante, se ocupa de esto)

A continuación se muestra una lista con los tipos más importantes que se pueden comprobar o forzar a partir de funciones de R base:

| Tipo      | Comprobación     | Coerción         |
|-----------|------------------|------------------|
| character | `is.character()` | `as.character()` |
| numeric   | `is.numeric()`   | `as.numeric()`   |
| integer   | `is.integer()`   | `as.integer()`   |
| double    | `is.double()`    | `as.double()`    |
| factor    | `is.factor()`    | `as.factor()`    |
| logical   | `is.logical()`   | `as.logical()`   |
| NA        | `is.na()`        | `as.na()`        |

## Variables de tiempo

<center>

![[Artwork por \@allison_horst](https://allisonhorst.com/)](img/04/lubridate.PNG){width=40%}

</center>

Los eventos epidemiológicos se presentan en algun momento del tiempo, por lo que las variables de tiempo son habituales componentes de las bases de datos con las que trabaja un epidemiólogo. Estas variables pueden presentarse en distintas unidades de medida, tales como horas, días, años, decadas, etc.

A veces trabajar con datos tipo fecha y hora puede ser frustrante.Las fechas vienen en muchos formatos diferentes, que hace que reconocerlos y analizarlos sea un desafío.

Primero necesitamos que los datos sean reconocidos como formato fecha (*Date*) y luego debemos lidiar con operaciones específicas como extraer componentes de los horarios, como años, meses o segundos, o cambiar zonas horarias o hacer cálculos entres fechas.

Para simplificar esta tarea tidyverse trae el paquete **lubridate** que proporciona herramientas para manipular variables fecha-hora.

Específicamente, lubridate ayuda a los usuarios a:

-   Identificar y analizar los datos de fecha y hora.
-   Extrer y modificar componentes de una fecha y hora, como años, meses, días, horas, minutos y segundos.
-   Realizar cálculos precisos con fecha y hora.
-   Manejar zonas horarias y horario de verano.

**lubridate** se instala y activa con tidyverse:

```{r, warning=FALSE, echo=FALSE}
library(tidyverse)
```

### Lectura de fechas

Podemos leer fechas en R usando la serie de funciones **ymd()** proporcionada por este paquete. Estas funciones analizan el contenido de cadenas de caracteres y las transforman a fechas.

Las letras y, m y d corresponden al año, mes y día de una fecha. Para leer una fecha, seleccionamos el nombre de la función que coincide con el orden de los elementos contenidos en el objeto original. Por ejemplo, en la siguiente fecha el elemento mes viene primero, seguido por el día y luego el año, al estilo estadounidense. Entonces usaríamos la función `mdy()`:

```{r, echo=TRUE}
mdy("01-24-2024")
```

El formato de salida siempre año-mes-día, es decir se organiza del elemento más grande que anida a los otros.

Si en cambio tuviese la forma en que usamos las fechas nosotros, usaríamos `dmy()`.

```{r}
dmy("24-01-2024")
```

Como se observa el formato de los *caracteres de entrada* pueden utilizar distintos separadores, como guión medio (-), punto (.), barra inclinada (/), guión bajo (\_) o incluso espacios.

La clase de los objetos convertidos es **Date**.

```{r}
x <- dmy("24/01/2024")

class(x)
```

| Orden de los elementos                | Función   |
|---------------------------------------|-----------|
| año, mes y día                        | ymd()     |
| año, día y mes                        | ydm()     |
| mes, día y año                        | mdy()     |
| día, mes y año                        | dmy()     |
| hora y minuto                         | hm()      |
| hora, minuto y segundo                | hms()     |
| año, mes, día, hora, minuto y segundo | ymd_hms() |

Las funciones que tienen componente de hora crean objetos POSIXct.

Cuando una función `dmy()` se aplica a un vector de fechas, **lubridate** supone que todas las fechas tienen el mismo orden y los mismos separadores.

### Manipulando fechas

Cada estructura fecha-hora es una combinación de diferentes elementos, cada uno con su propio valor. Por ejemplo, la mayoría de las fechas incluyen un valor de año, un valor de mes, un valor de día, etc. Juntos estos elementos especifican el momento exacto al que se refiere la fecha y la hora.

Podemos extraer fácilmente cada elemento de una fecha-hora con la función de acceso que tiene su nombre, como se muestra en la siguiente tabla.

| Componente de fecha         | Función  |
|-----------------------------|----------|
| Año                         | year()   |
| Mes                         | month()  |
| Semana                      | week()   |
| Día del año                 | yday()   |
| Día del mes                 | mday()   |
| Día de la semana            | wday()   |
| Hora                        | hour()   |
| Minuto                      | minute() |
| Segundo                     | second() |
| Zona horaria (huso horario) | tz()     |

Por ejemplo, si almacenamos la fecha y hora actual del sistema en un objeto:

```{r}
fecha <- now()

fecha
```

podemos extraer cada uno de sus elementos.

Tengamos en cuenta que la función `now()`, perteneciente al mismo paquete lubridate, devolverá una fecha diferente cada vez que se ejecute.

```{r}
year(fecha)
```

```{r}
mday(fecha)
```

```{r}
hour(fecha)

minute(fecha)
```

Para los elementos de mes y día de la semana (wday), también podemos especificar si queremos extraer el valor numérico del elemento, una abreviatura del nombre del mes o día de la semana, o el nombre completo.

Por ejemplo:

```{r}
month(fecha)
```

```{r}
month(fecha, label = TRUE)
```

```{r}
month(fecha, label = TRUE, abbr = FALSE)
```

```{r}
wday(fecha, label = TRUE, abbr = FALSE)
```

Otra buena noticia es que el paquete se adapta al formato regional del sistema operativo donde se encuentra funcionando, por lo que los nombres de los meses o los días de la semana, en este caso, figuran en español (si nuestro sistema operativo está instalado bajo ese idioma).

Por otra parte, también podemos usar cualquiera de las funciones de acceso para establecer el valor de un elemento. Por ejemplo,

```{r}
fecha

day(fecha) <- 5

fecha
```

cambia nuestra fecha al quinto día del mes. También podemos configurar los elementos para más valores complicados, por ejemplo:

```{r}
fechas <- ymd_hms("2017-01-01 01:00:00", "2017-01-01 01:30:00")

minute(fechas) <- mean(minute(fechas))

fechas # promedió los minutos en los dos casos
```

Si asignamos a un elemento un valor mayor de lo admitido, la diferencia se extenderá en el siguiente elemento superior (respetando la cantidad de días del mes de mayo adecuadamente en este caso.)

```{r}
fecha

day(fecha) <- 35 

fecha
```

Finalmente, también podemos cambiar las fechas agregando o restando unidades de tiempo.

```{r}
fecha

fecha <- fecha + hours(3)

fecha
```

Observemos que `hours()` (plural) no es la misma función que `hour()` (singular).

Por último, algo muy útil para nuestro trabajo es poder extraer la semana epidemiologica, con la función `epiweek()`, en la que cae una fecha en particular o un conjunto de ellas dentro de una variable.

```{r}
epiweek(fecha)
```

Junto con la semana epidemiológica se puede obtener el año epidemiológico con la función `epiyear()`

Por ejemplo, la fecha 01/01/2022 es el primer día de enero de 2022 pero pertenece a la semana epidemiológica 52 de año 2021. Veamos:

```{r}
fecha <- dmy("01-01-2022")

fecha

epiweek(fecha)
```

Si uno obtiene el año al que pertenece, nos dice que 2022 pero si lo queremos asociar con su semana epidemiológica, nos quedaría que estamos en la semana 52 del año 2022, cosa que no es cierta.

```{r}
year(fecha)
```

En estas situaciones que no coinciden el año de la fecha con el año epidemiológico de la semana es que se aplica `epiyear()`.

```{r}
epiyear(fecha)
```


### Cálculos con fecha-horas

Los cálculos con fechas y horas son más complicados que la aritmética con números, pero puede hacerse con precisión y facilidad mediante este paquete.

¿Qué es lo que complica a la aritmética con datos de tiempo (fechas u horas)?

El tiempo que medimos en el reloj se calibra periódicamente para ajustar las condiciones astronómicas, por caso los años bisiestos o los horarios de verano que se utilizan en muchos países.

En diferentes momentos, la duración de meses, semanas, días, horas e incluso minutos puede variar. Por lo tanto, podemos considerar que son unidades relativas de tiempo; su longitud es relativa a cuando ocurren; por el contrario, los segundos siempre tienen una longitud constante (son unidades de tiempo exactas)

**lubridate** permite cálculos con unidades relativas y exactas introduciendo cuatro nuevos elementos relacionados: instantes, intervalos, duraciones y períodos. Estos conceptos son tomados del proyecto **Joda Time** *(Colebourne y O'Neill 2010)*. Conceptos similares para instantes, períodos y duraciones también aparecen en la biblioteca C++ Boost - Date Time (Garland 2011).

**lubridate** proporciona funciones auxiliares, clases de objetos y métodos para usar los cuatro conceptos en el lenguaje R.

#### Instantes

Un instante es un momento específico en el tiempo, como el 1 de enero de 2024. Creamos un instante cada vez que convertimos una fecha a formato Date de R.

```{r}
start_2024 <- ymd_hms("2024-01-01 12:00:00")
```

**lubridate** no crea una nueva clase de objetos instantes. En cambio, reconoce cualquier objeto de fecha y hora como un instante. Podemos probar si un objeto es un instante usando el identificador `is.instant()`. Por ejemplo:

```{r}
is.instant(start_2024)
```

#### Intervalos

Los intervalos, duraciones y períodos son todas formas de registrar tiempos. De estos, los intervalos son los más simples. Un intervalo es un lapso de tiempo que ocurre entre dos instantes específicos.

Podemos crear objetos de intervalo restando dos instantes, mediante **%--%** o usando la función `new_interval()`.

```{r}
start_2023 <- ymd_hms("2023-01-01 12:00:00")
start_2024 <- ymd_hms("2024-01-01 12:00:00")
intervalo <- start_2023 %--% start_2024
intervalo
```

Podemos acceder a las fechas de inicio y finalización de un objeto de intervalo con `int_start()` e `int_end()`.

Los intervalos siempre comienzan en la fecha y hora que ocurre primero y finaliza en la fecha y hora que ocurre último. Por lo tanto, los intervalos siempre tienen una longitud positiva.

```{r}
int_start(intervalo)
```

```{r}
int_end(intervalo)
```

Desafortunadamente, dado que los intervalos están anclados a sus fechas de inicio y finalización, no son muy útiles para cálculos de fecha y hora.

#### Duraciones

Si eliminamos las fechas de inicio y finalización de un intervalo, tendremos un intervalo de tiempo genérico que podemos agregar a cualquier fecha. Pero, en que unidad es conveniente medir este período de tiempo? Como vimos anteriormente, si lo almacenamos en segundos, tendrá una longitud exacta ya que los segundos siempre tienen la misma longitud.

Llamamos duraciones de estos lapsos de tiempo. Alternativamente, podemos registrar el lapso de tiempo en unidades más grandes, como minutos o años.

Dado que la longitud de estas unidades varía con el tiempo, la longitud exacta de el lapso de tiempo dependerá de cuándo comience. Estos períodos de tiempo no exactos se llaman períodos y será discutido en la siguiente sección.

La duración de una duración es invariable para saltar años, segundos intercalares y horario de verano porque las duraciones se miden en segundos.

Por lo tanto, las duraciones tienen longitudes consistentes y se puede comparar fácilmente con otras duraciones. Las duraciones son el objeto apropiado para usar cuando se comparan atributos basados en tiempo, como velocidades, tasas y tiempos de vida.

El paquete base de R tiene definido a objetos de tipo duración en la clase **difftime**.

**lubridate** incorpora un segundo tipo: objetos clase **duration**

Estos objetos se pueden usar con otros objetos de fecha y hora sin preocuparse sobre en qué unidades se muestran. Se puede crear un objeto de duración con la función **duration()**:

```{r}
duration(60)
```

Para duraciones grandes, resulta inconveniente describir la longitud en segundos. Por ejemplo, no muchas personas reconocerían que 31557600 segundos es la duración de un año estándar. Por esta razón, los objetos de gran duración son seguidos entre paréntesis por una longitud estimada. Un minuto son 60 segundos, una hora 3600 segundos, un día 86400, una semana 604800 y un año 31557600 (365.25 días).

Los objetos de clase **duration** se pueden crear fácilmente con las funciones auxiliares `dyears()`, `dweeks()`, `ddays()`, `dhours()`, `dminutes()` y `dseconds()`. La **d** en el nombre representa duración.

Cada objeto se crea tomando como unidad los segundos usando las relaciones estimadas descriptas arriba. El argumento de cada función es el número de unidades estimadas que deseamos incluir en la duración.

```{r}
dminutes(1)
```

```{r}
dseconds(60)
```

```{r}
dminutes(2)
```

```{r}
1:3 * dhours(1)
```

Las duraciones se pueden agregar o restar a cualquier objeto instante.

```{r}
start_2024

start_2024 + ddays(10)
```

Las duraciones también se pueden agregar o restar de intervalos y otras duraciones. Por ejemplo:

```{r}
dweeks(1) + ddays(6) + dhours(2) + dminutes(1.5) + dseconds(3)
```

También podemos crear duraciones a partir de objetos intervalo y períodos usando `as.duration()`.

```{r}
as.duration(intervalo)
```

#### Períodos

Los períodos registran un intervalo de tiempo en unidades mayores que segundos, como años, meses, semanas, días, horas y minutos. Para mayor comodidad, también podemos crear un período que solo use segundos, pero dicho período tendría las mismas propiedades que una duración. **lubridate** introduce la clase **period** para modelar períodos. Construimos objetos de período con las funciones auxiliares `years()`, `months()`, `weeks()`, `days()`, `hours()`, `minutes()` y `seconds()`.

```{r}
months(3)
```

```{r}
months(3) + days(2)
```

Estas funciones no contienen una **d** en su nombre, porque no crean duraciones; ya no tienen longitudes consistentes (medidas en segundos). Por ejemplo, meses (2) siempre tiene una duración de dos meses, aunque la duración de dos meses cambiará según cuando comienza el período (podrán ser meses de 30, 31 0 28 días).

Por esta razón, no podemos calcular exactamente cuánto tiempo será un período en segundos hasta que sepamos cuándo ocurre. Sin embargo, aún podemos realizar cálculos de fecha y hora con períodos. Cuando agregamos o restamos un período a un instante, el período queda asociado al instante. El instante nos dice cuándo ocurre el período, lo que nos permite calcular su longitud exacta en segundos.

Por ejemplo para un año bisiesto, primero sumamos un año con `years()`:

```{r}
start_2024 + years(1)
```

vs. sumar un año como duración con `dyears()`

```{r}
start_2024 + dyears(1)
```

También podemos convertir otros objetos intervalo en períodos con la función `as.period()`.

```{r}
as.period(intervalo)
```

Los períodos se pueden agregar a instantes, intervalos y otros períodos, pero no a duraciones.

### División con intervalos de tiempo

A veces necesitamos responder preguntas que implican dividir un intervalo de tiempo por otro. Por ejemplo, ¿Cuántos años tiene una persona nacida el 26 de junio de 1976?

Objetos de clase interval, duration y period pueden dividirse por otros objetos de las mismas clases. Los resultados de estas divisiones varían dependiendo de la naturaleza de los intervalos de tiempo involucrados. La división modular (%/%) también funciona con estas clases.

Para ilustrar esto, hacemos un intervalo entre la fecha de nacimiento y la fecha actual.

```{r}
nacimiento <- ymd("1976-06-26")

hoy <- now()

intervalo <- interval(nacimiento, hoy)

intervalo
```

Como las duraciones son una medida exacta de un intervalo de tiempo, podemos dividir este intervalo por una duración para obtener una respuesta exacta.

```{r}
intervalo / dyears(1)
```

Podríamos utilizar un período en lugar de duración

```{r}
intervalo / years()
```

Pero lo más útil es la división modular para redondear y quedarnos solo con los años:

```{r}
intervalo %/% dyears()
```

En resumen, la aritmética con tipos fecha-hora puede involucrar cuatro tipos de objetos: instantes, intervalos, duraciones y períodos.

**lubridate** crea nuevas clases de objetos: *interval*, *duration* y *period*. Reconoce que las clases de fecha y hora más comunes, como **POSIXt** y **Date**, se refieren a instantes. La siguiente tabla describe qué objetos se pueden combinar con otro y qué tipo de objeto resultará.

|          | instante | interval   | duration | period   |
|----------|----------|------------|----------|----------|
| instante | NA       | instante   | instante | instante |
| interval | instante | interval\* | interval | interval |
| duration | instante | interval   | duration | period   |
| period   | instante | interval   | period   | period   |

\*= clase duration si los intervalos no se alinean.

### Redondeando fechas

Al igual que los números, las fechas se ordenan en forma creciente. Esto permite redondear los tipos de datos fecha-hora.

**lubridate** proporciona tres métodos que ayudan a realizar este redondeo: `round_date()`, `floor_date()`, y `ceiling_date()`.

El primer argumento de cada función es la fecha-hora a ser redondeada. El segundo argumento es la unidad tomada para redondear.

Por ejemplo, podríamos redondear la siguiente fecha-hora a la unidad día:

```{r}
nov23 <- ymd_hms("2023-11-23 09:38:29")

nov23

round_date(nov23, "day")
```

Pero también podríamos desear redondear al comienzo de mes más próximo, asi:

```{r}
round_date(nov23, "month")
```

Tenga en cuenta que al redondear un dato fecha-hora a una unidad determinada, se establece la fecha al inicio de esa unidad (al definir día, por ejemplo se establece la información de horas, minutos y segundos en 00).

Las otras dos funciones de redondeo lo hacen al comienzo del mes menor (floor) o mayor (ceiling).

Por ejemplo, con `ceiling_date()`, podemos hallar el último día de cada mes, sin importar la fecha que tengamos almacenada. Luego de ubicar el inicio del próximo mes, restamos un día.

```{r}
ceiling_date(nov23, "month") - days(1)
```

```{r}
oct02 <- ymd_hms("2023-10-02 00:00:00")

ceiling_date(oct02, "month") - days(1)
```

### Zonas horarias

Las zonas horarias complejizan a los datos fecha-hora, pero algunas veces nos encontramos con bases de datos o situaciones en que debemos lidiar con ellas. Cuando creamos instantes en R, la zona horaria estándar es la universal (UTC).

**lubridate** ofrece dos formas de trabajar con zonas horarias.

Podemos cambiar la zona horaria en la que se muestra un instante utilizando la función `with_tz()`. Esto cambia la forma en que se muestra el instante, pero continúa siendo el mismo. Por ejemplo, el objeto fecha tiene cargada una fecha-hora creada a partir de la función `now()` y al ejecutarse en un equipo con configuración regional de Argentina toma el uso horario de Buenos Aires (aparece -03 al final del día y horario)

```{r}
fecha
```

Al llevarlo a la zona horaria universal, le agrega 3 horas más, aunque sigue siendo el mismo instante.

```{r}
with_tz(fecha, "UTC")
```

`force_tz()` hace lo contrario de `with_tz()`: cambia el instante real de tiempo guardado en el objeto. Por ejemplo, el siguiente código nos mueve a un nuevo instante que ocurre 3 horas más temprano.

```{r}
force_tz(fecha, "UTC")
```

En este caso, un instante horario 11:32:01 UTC correponde al instante 08:32:01 -3

`with_tz()` y `force_tz()` solo funcionan con zonas horarias reconocidas por el sistema operativo de la computadora que aloja R. Esta lista de zonas horarias variará de una computadora a otra. Para más información ver la página de ayuda de R para `Sys.timezone()`.

El código de nuestra zona horaria (es conocida como UTC-03:00 - Ciudad de Buenos Aires) para incorporar al argumento es **America/Buenos_Aires**

## Cadena de caracteres

<center>

![[Artwork por \@allison_horst](https://allisonhorst.com/)](img/04/stringr2.PNG){width=40%}

</center>

El paquete encargado de trabajar con cadenas de caracteres dentro de tidyverse es **stringr**.

Todas las funciones del paquete comienzan con **str\_** y trabajan sobre un vector de caracteres como primer argumento.

Hay tres grandes familias útiles de funciones en **string**:

**Funciones de manipulación de caracteres**: estas funciones permiten manipular caracteres dentro de cadenas

**Herramientas para tratamiento de espacios en blanco**: para agregar, eliminar y manipular espacios en blanco.

**Funciones de coincidencia de patrones**: trabaja con motores de descripción de patrones, para funciones de busqueda, extracción, reemplazo, etc. Trabajan con expresiones regulares.

**stringr** también se instala y activa junto a tidyverse.

### Manipulación de caracteres

Podemos obtener la longitud de la cadena con `str_lenght()`

```{r}
str_length("abc")
```

Esta función es equivalente a la función de R base *nchar()*.

Para acceder a un carácter individual se utiliza `sub_str()`.

Se necesitan tres argumentos: un vector de caracteres, una posición inicial y una posición final. Cualquiera de las posiciones puede ser un entero positivo, que cuenta a partir de la longitud, o un entero negativo que cuenta desde la derecha. Las posiciones son inclusivas, y si es más larga que la cadena, se truncarán silenciosamente.

```{r}
x <- c("abcdef", "ghifjk")
```

la tercer letra de cada cadena

```{r}
str_sub(x, 3, 3)
```

desde la segunda letra hasta la anteúltima

```{r}
str_sub(x, 2, -2)
```

También puede utilizar `str_sub()` para modificar cadenas de caracteres

```{r}
str_sub(x, 3, 3) <- "X"

x
```

El paquete **stringr** trae incorporado algunas funciones para manipulación de mayúsculas y minúsculas, similares a `tolower()` y `toupper()`

```{r}
x <- "Curso de lenguaje R"
```

convierte a mayúsculas

```{r}
str_to_upper(x)
```

convierte a minúsculas

```{r}
str_to_lower(x)
```

convierte a tipo título (la primer letra de cada palabra en mayúsculas)

```{r}
str_to_title(x)
```

También existen funciones para ordenar secuencias de caracteres

```{r}
x <- c("y", "i", "k")

str_order(x)
```

devuelve el orden alfabético del índice de los elementos

```{r}
str_sort(x)
```

devuelve los caracteres en orden alfabético

```{r}
str_sort(x, decreasing = T)
```

igual al anterior pero en orden decreciente

### Espacios en blanco

Hay tres funciones que añaden, eliminan o modifican espacios en blanco

`str_pad()` agrega espacio en blanco extra a una cadena a una longitud fija puede ser a izquierda, derecha o ambos lados.

```{r}
x <- c ("abc", "defghi")
```

```{r}
str_pad(x, 10)
```

rellena con espacios en blanco hasta alcanzar la cantidad de 10 caracteres por cadena sin definir el argumento side= lo hace a la izquierda

```{r}
str_pad(x, 10, side = "both")
```

aquí lo hacemos rellenando los espacios en blanco a ambos lados

Lo opuesto a rellenar de espacios en blanco es eliminarlos y esta tarea la realiza la función `str_trim()`

```{r}
x <- c("  a   ", "b   ",  "   c")

str_trim(x)
```

elimina todos los espacios en blanco a ambos lados de la cadena

```{r}
str_trim(x, side="left")
```

con el argumento *side=* le podemos indicar de que lado queremos eliminarlos

### Patrones

<center>

![[Artwork por \@allison_horst](https://allisonhorst.com/)](img/04/stringr.PNG){width=40%}

</center>

La mayoría de las funciones de **stringr** para trabajo con patrones de caracteres funcionan con [expresiones regulares](https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular) (un lenguaje conciso para describir patrones de texto).

Básicamente una expresión regular es una cadena de texto especial para describir un patrón de búsqueda que se puede utilizar para:

-   localizar cadenas de caracteres (ubicar - filtrar)

-   extraer una porción de los datos (extraer)

-   modificar los datos localizados (reemplazar)

Habitualmente se construyen concatenando la especificación de caracteres secuenciados junto a otros metacaracteres.

Son muy útiles cuando tenemos variables de alfanuméricas regulares, es decir con una estructura que se repite. Por ejemplo, los códigos internacionales de enfermedad, conocidos como CIE (actualmente en la versión CIE10/CIE11)

Algunos de los metacaracteres para construir expresiones regulares son:

| Símbolos y metacaracteres | Descripción                                                    |
|-----------------------------|-------------------------------------------|
| \^                        | Inicio de la cadena                                            |
| \$                        | Final de la cadena                                             |
| \[ \]                     | Cualquier carácter del conjunto entre paréntesis               |
| \[\^\]                    | Cualquier carácter no incluido en el conjunto                  |
| ?                         | Cero o una ocurrencia de lo que precede al símbolo             |
| \+                        | El caracter que le precede debe aparecer al menos una vez      |
| \*                        | El caracter que le precede debe aparecer cero, una o más veces |
| {x}                       | x ocurrencias del caracter que lo precede                      |
| {x,z}                     | Entre x y z ocurrencias del caracter que lo precede            |
| {x,}                      | x o más ocurrencias de lo que lo precede                       |

| Símbolos y metacaracteres | Descripción                                           |
|---------------------------|-------------------------------------------------------|
| \|                        | Une subexpresiones                                    |
| .                         | Concuerda con cualquier carácter individual           |
| ( )                       | Agrupa subexpresiones                                 |
| 0-9 a-z A-Z               | Rangos de números, letras…                            |
| \\                        | Marca el carácter siguiente como un carácter especial |
| .                         | Representa un punto dentro del patrón                 |
| s                         | Representa un espacio en blanco dentro del patrón     |
| n                         | Representa un salto de línea dentro del patrón        |
| d                         | Representa un dígito numérico dentro del patrón       |
| w                         | Representa un carácter alfanumérico dentro del patrón |

------------------------------------------------------------------------

Veamos un ejemplo con un grupo de códigos CIE10 relacionados a la hepatitis B.

```{r}
#| echo: false

hepb <- c("B16","B160", "B161", "B162", "B169", "B170", "B178", "B180", "B181", "B189")

codigos <- data.frame(hepb)
```

Tenemos una pequeña tabla de datos con 10 códigos en la variable **hepb**

```{r}
codigos
```

Supongamos que se encuentran insertos en una tabla de datos con otros códigos y necesitamos detectarlos para extraerlos o contarlos.

Si las expresiones regulares no existiesen deberíamos hacer algo así:

```{r}
codigos %>% 
  filter(hepb =="B16" | hepb >= "B160" & hepb <= "B162" | hepb == "B169" | 
         hepb == "B170" | hepb =="B178" | hepb =="B180" | hepb =="B181" | 
         hepb == "B189")

```

Es decir, concatenar una serie de operadores y conectores lógicos OR dentro de un filtro por ejemplo para lograr su extracción.

Con las expresiones regulares tenemos una alternativa de hacer esta tarea dividiendo el trabajo en partes y aplicar la función `str_detect()` de **stringr**.

```{r}
codigos %>% 
  filter(str_detect(hepb, "^B16[0-2|9]?$"))  #  selecciona el grupo B16x

codigos %>% 
  filter(str_detect(hepb, "^B17[08]$")) # selecciona el grupo B17x

codigos %>% 
  filter(str_detect(hepb, "^B18[019]$")) # selecciona el grupo B18x
```

Y finalmente unirlo con conectores OR:

```{r}
codigos %>% 
  filter(str_detect(hepb, "^B16[0-2|9]?$|^B17[08]$|^B18[019]$"))
```

O mejor construir una expresión regular más sintética aprovechando los metadatos adecuados.

```{r}
codigos %>% 
  filter(str_detect(hepb, "^B1[6-9][0-9]?$"))
```

Además de la función de detección `str_detect()` el paquete aporta `str_extract()` para extraer y `str_replace()` para reemplazar directamente

## Factores

<center>

![[Artwork por \@allison_horst](https://allisonhorst.com/)](img/04/forcats.PNG){width=40%}

</center>

Los factores son simplemente el formato de datos que R reserva para las variables categóricas y estan compuesto por valores numéricos internos asociados a etiquetas que definen cada una de los niveles (categorías o niveles definidos).

El paquete **forcats** es parte del ecosistema tidyverse pensado para trabajar con este tipo de dato.

En función de que las herramientas del paquete son de aplicación práctica vamos a trabajar con un conjunto de datos ficticios creados con la finalidad de mostrar la potencialidad de **forcats**.

```{r}
#| echo: false
#| message: false
#| warning: false

datos <- read_excel("datos/Base_factores.xlsx",sheet = 1, col_names = T)

```

```{r}
glimpse(datos)
```

Observamos que el objeto llamado `datos` tiene 6 variables de tipo caracter y 19 observaciones.

Estas variables de caracter tienen como característica representar variables cualitativas nominales y ordinales que para su mejor tratamiento dentro del R deberían ser convertidas a factores.

Comenzamos con la primer variable (*Enfermedad*). La función simple y de R base que conocemos para convertirla en factor es `factor()`.

```{r}
datos <- datos |> 
  mutate(Enfermedad = factor(Enfermedad))

levels(datos$Enfermedad)
```

La función del paquete **forcats** para realizar la misma tarea se llama `as_factor()`. No agrega ningun funcionalidad extra por lo que es indistinto utilizar una forma u otra.

Aquí la utilizamos para convertir la variable *Sexo*

```{r}
datos <- datos |> 
  mutate(Sexo = as_factor(Sexo))
```

Si queremos visualizar los niveles del factor podemos usar `levels()` (función de R base):

```{r}
levels(datos$Sexo)
```

Encontramos uno de los problemas habituales cuando trabajamos con datos reales cargados por diferentes usuarios o cuando unimos bases de diverso origen. Las categorías se encuentran etiquetadas de manera diferente aunque conceptualmente se refieran a lo mismo (ejemplo: "Femenino" - "Mujer")

Debemos corregir este inconveniente y para esta tarea el paquete ofrece una función que recodifica los niveles. Se llama `fct_recode()` y la aplicamos así:

```{r}
datos <- datos |> 
  mutate(Sexo = fct_recode(Sexo, 
                           Varon = "Masculino", 
                           Mujer = "Femenino"))

levels(datos$Sexo)

datos |> 
  reframe(fct_count(Sexo))
```

Vemos en los argumentos que le indicamos que "Masculino" es igual a Varon y "Femenino" igual a Mujer. Esto provoca que en todos los casos donde aparezca "Masculino" sea reemplazado por Varon y cuando aparezcan "Femenino" se cambie por Mujer.

Finalmente verificamos que los niveles sean los dos que necesitamos y además podemos producir un listado de frecuencias de los niveles del factor con `fct_count()` dentro de un `reframe()` que es la opción correcta al `summarise()` cuando el resultado es mayor a una fila a partir de la versión 1.1.0 de **dplyr**.

Hasta aquí tenemos las dos primeras variables convertidas y podrían ser utilizadas en un análisis posterior para construir una tabla de contingencia de Sexo vs Enfermedad.

```{r}
#| message: false
#| warning: false

library(janitor)

datos |> 
  tabyl(Sexo, Enfermedad)
```

Observemos que en esta tabla el orden de los niveles de Enfermedad quizás no sea el más conveniente para tablas 2x2 y sus cálculos asociados (razones o diferencias de razones), donde se necesita que la tabla tenga una forma y orden específico para que los valores e las ecuaciones sean los correctos.

Esta situación causa que muchas veces tengamos que reordenar las categorías de las variables cualitativas y los niveles de los factores son ideales para esto. La función encargada de esta tarea en **forcats** es `fct_relevel()` que no es muy diferente al `relevel()` del R base.

```{r}
datos <- datos |> 
  mutate(Enfermedad = fct_relevel(Enfermedad, "Si"))

datos |> 
  tabyl(Sexo, Enfermedad)
```

Aplicado sobre **Enfermedad** observamos, luego en la tabla 2x2, que la categoría **Si** aparece primera como necesitamos.

Lo mismo podríamos hacer con la variable **Sexo** si quisieramos que el nivel de referencia fuese Mujer en lugar de Varon.

```{r}
datos <- datos |> 
  mutate(Sexo = fct_relevel(Sexo, "Mujer"))

datos |> 
  tabyl(Sexo, Enfermedad)
```

Continuamos con la siguiente variable y luego de transformarla pedimos sus niveles.

```{r}
datos <- datos |> 
  mutate(Civil = factor(Civil))

levels(datos$Civil)
```

Aparecen 4 niveles para la variable. Para ver la frecuencia de aparición hacemos:

```{r}
datos |> 
  reframe(fct_count(Civil))
```

En la frecuencia aparecen los 4 niveles más un valor faltante (NA). Estos valores habitualmente se omiten en muchas de las operaciones que realiza el lenguaje.

Pero supongamos que deseamos mostrar dentro de una tabla de frecuencia la cantidad de valores perdidos o desconocidos que tenemos de la variable **Estado Civil**. Deberíamos etiquetar ese `NA` para poder visualizarlo.

La función del paquete encargada de la tarea es `fct_na_value_to_level()`

```{r}
datos <- datos |> 
  mutate(Civil = fct_na_value_to_level(Civil, 
                                       level = "Desconocido"))

datos |> 
  reframe(fct_count(Civil))

levels(datos$Civil)
```

Pensando en poder graficar esta variable construimos un gráfico de barras sencillo.

```{r, out.width="60%", fig.align="center"}
datos |> 
  ggplot(aes(x = Civil, fill = Civil)) + 
  geom_bar()
```

Una mejor presentación sería si las barras se encuentran ordenadas (de mayor a menor) por la frecuencia de cada categoría.

Podríamos ordenar mediante `arrange()` (del paquete dplyr de tidyverse) pero este ordenamiento sirve solo como prosentación, es decir el nuevo orden no se guarda dentro de los niveles del factor.

Para poder hacer usamos `fct_infreq()`:

```{r}
datos <- datos |> 
  mutate(Civil = fct_infreq(Civil))

levels(datos$Civil)
```

Ahora el gráfico nos saldría como queremos:

```{r, out.width="60%", fig.align="center"}
datos |> 
  ggplot(aes(x = Civil, fill = Civil)) + 
  geom_bar()
```

Sigamos con otra de las variables. En este caso **Esalud** que tiene el estado de salud autoreportado por las personas. Como representa una variable categórica ordinal tenemos que estar atentos al orden de las categorías que R siempre forzará a que cumpla con el alfabético.

Podemos usar directamente `fct_relevel()` con los niveles completos en el orden correcto.

```{r}
class(datos$Esalud)

datos <- datos |> 
  mutate(Esalud = fct_relevel(Esalud,
                              "Muy buena",
                              "Buena",
                              "Regular",
                              "Mala",
                              "Muy mala"))
         
levels(datos$Esalud)
```

Observemos que no hizo falta primero convertir en factor y luego aplicar la función de **forcats**. Todas las funciones comenzadas con **fct\_** aplicadas a un tipo caracter convertiran a factor previamente a la operación que realicen.

En este caso además los niveles tienen un orden lógico que comienza en "Muy buena" salud y termina en "Muy mala". Quizás el orden necesario sea inverso y `fct_rev()` hace la tarea.

```{r}
datos <- datos |> 
  mutate(Esalud = fct_rev(Esalud))

levels(datos$Esalud)
```

Finalmente conseguimos que el factor sea ordenado y que los niveles sigan el esquema de aumentar hacia la derecha.

La siguiente variable es *Ciudad*. Veamos su contenido:

```{r}
datos |> 
  count(Ciudad)
```

Posee 4 etiquetas con nombres de ciudades. Su frecuencia es:

Vemos que mayoritariamente las observaciones pertenecen a Mar del Plata. Muchas veces cuando estamos frente a situaciones como esta, donde hay varias categorías con poca frecuencia, es mejor agruparlas en un "Otras/os". Eso mismo vamos a realizar con la función `fct_other()`.

```{r}
datos <- datos |> 
  mutate(Ciudad = fct_other(Ciudad, 
                            keep = "Mar del Plata", 
                            other_level = "Otras"))

levels(datos$Ciudad)

datos |> 
  count(Ciudad)
```

La última de las variables de la tabla de datos es *Comorbilidades*.

```{r}
datos |> 
  count(Comorbilidades)
```

Sus etiquetas son 7 y se trata de enfermedades que podemos vincular a distintos grupos, es decir, que nos va a servir de excusa para probar otra función de **forcats**.

La función es `fct_collapse()` y permite agrupar niveles a grupos que serían las nuevas etiquetas de nivel.

Lo vamos a hacer asignando a una nueva variable (*Comor_agrupadas*) y generando los niveles Respiratoria, Digestiva y Circulatorio, para enfermedades respiratorias, enfermedades del aparato digestivo y enfermedades del aparato circulatorio.

```{r}
datos <- datos |> 
  mutate(Comor_agrupadas = fct_collapse(Comorbilidades,
                                      Respiratoria = c("EPOC",
                                                       "TBC", 
                                                       "Neumonia"),
                                      Digestiva = c("Hepatitis",
                                                    "Gastritis"),
                                      Circulatorio  = c("aterosclerosis",
                                                        "Hipertensión")))

levels(datos$Comor_agrupadas)

datos |> 
  count(Comor_agrupadas)
```

Nos quedan para ver tres funciones más del paquete presentado.

La primera es `fct_drop()` que elimina los niveles que no se utilizan. Veamosla en acción.

Tomamos el caso de una selección de la tabla original **datos** filtrado por las observaciones que pertenecen a Mar del Plata, guardado en otro dataframe al que llamaremos **datos_MdP**

```{r}
datos_MdP <- datos  |>  
  filter(Ciudad == "Mar del Plata")
```

Si vemos sus niveles confirmaremos que heredó los que tenía la variable en el tibble original. Pero una tabla nos mostraría que no hay datos para el nivel "Otras".

```{r}
levels(datos_MdP$Ciudad)

datos_MdP |> 
  tabyl(Ciudad)
```

Aquí entra en juego la función `fct_drop()` que aplicada a la variable *Ciudad* de **datos_MdP** produce:

```{r}
datos_MdP <- datos_MdP |> 
  mutate(Ciudad = fct_drop(Ciudad))

levels(datos_MdP$Ciudad)

datos_MdP |> 
  tabyl(Ciudad)
```

A la inversa, la función `fct_expand()` incorpora niveles a la lista de niveles de un factor.

Volvemos a trabajar con el dataframe **datos** y vamos a asignar nuevos niveles al factor de la variable *Ciudad*.

```{r}
datos <- datos |> 
  mutate(Ciudad = fct_expand(Ciudad, "La Plata", 
                             "Tandil", 
                             "CABA"))

levels(datos$Ciudad)
```

Esto significa que tenemos tres categorías posibles más en el factor que están disponibles para nuevas observaciones, aunque en el conjunto de datos no esten siendo utilizadas por ahora.

Por último, la función `fct_c()` concatena factores combinandos niveles. Para ejemplificar su uso vamos a construir dos factores tipo vector que finalmente uniremos.

Imaginemos que tenemos que unir dos variables pertenecientes a conjuntos de datos que queremos unificar. En la variable1 hay definidos dos niveles "Corrientes" y "Posadas" y en la variable2 tres niveles "Corrientes", "Resistencia" y "Goya".

```{r}
var1 <- factor(c("Corrientes","Corrientes","Posadas","Corrientes",
                 "Posadas"))

var2 <- factor(c("Resistencia","Goya","Goya","Resistencia","Resistencia",
                 "Corrientes","Goya"))

var1

var2
```

A continuación concatenamos aplicando `fct_c()`:

```{r}
var3 <- fct_c(var1, var2)

var3
```

Observamos que no solo une los datos de las variables sino que respeta los niveles definidos de cada uno fusionando las categorías.
